// IW9 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

init_sp_flags()
{
    level thread initproject( );

    if ( !isdefined( level.flag ) )
        scripts\engine\flags::init_flags();

    flags = [ "missionfailed", "load_finished", "scriptables_ready" ];

    foreach ( flag in flags )
    {
        if ( !scripts\engine\utility::flag_exist( flag ) )
            scripts\engine\utility::flag_init( flag );
    }
}









//><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><//
// Project HiNAtyu MWII SP FSTB GSC Mod Menu
//><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><//

//=================================================================//
// 
// [ Contact ]
// 
// Creator       : HiNAtyu Studio
// Update date   : 2024/05/25
// YouTube       : https://www.youtube.com/channel/UCmxJAnVPtkStQVKrvAVMZSw
// Twitter 1     : @KonataGIF ( https://x.com/KonataGIF )
// Twitter 2     : @H1NAtyu ( https://twitter.com/H1NAtyu )
// Discord       : hinatapoko ( https://discordapp.com/users/239453096026046464 )
// 
//=================================================================//

//=================================================================//
// 
// [ GSC Info ]
// 
// Game title         : Call of Duty : Modern Warfare II
// Game code          : IW9 / MW22 / CoD19
// Game released year : 2022
// Game mode          : SP ( Single Player / Campaign )
// 
//=================================================================//

//=================================================================//
// 
// [ Promotion ]
// 
// I'd be very happy if you could follow, subscribe, like, or comment on my various SNS accounts.
// If you like my work, I'd be happy if you could sponsor or donate.
// This will help facilitate the development of new features and fixes.
// 
// Ko-fi : https://ko-fi.com/hinatyustudio
// BTC   : 32J66dfWi9dqqWHS2RYR9rFCUNBL88vgUR
// ETH   : 0xaE5D5b3e8E865B2bA676a24eF41d5f4CBD315978
// 
//=================================================================//

//=================================================================//
// 
// [ Caution! ]
// 
// * This Injector was created for research, development, and educational purposes.
// * This Injector was created for free release purposes.
// * Unless there are significant bugs, I will not make fixes to the Injector.
// * I recommend using it only with the MWII SP Offline build.
// * It is not intended for use with any other games.
// * Any use for unintended purposes is always at your own risk.
// * If OneDrive is enabled, the software may not function properly, so please disable OneDrive if any issues occur.
// 
// * After using this Injector, be sure to restart your PC before playing other games.
// * Shutting down or unplugging the power will not initialize the driver, which increases the risk of a BAN.
// * Any BAN measures resulting from the use of this Injector are entirely at your own risk.
// 
// * To use this Face Injector on Windows 11, please use <MRON AIO FIXES.bat> distributed by MRON to fix your system.
// 
// * The driver for this Face Injector will be detected by the Retail Version of Call of Duty Ricochet.
// * Be sure to use this Injector only with an offline version of MWII SP!
// * If you use it with the Retail Version, the consequences are at your own risk.
// 
//=================================================================//

//:::::::::::::::::::::::::::::::::::::::::::::::::://
// [ English ]
//   < CoD GSC (C++) syntax explanation >
//     @ level                    = modifier for the entire room
//     @ level.players[i]         = 1 player participating in the room
//     @ self                     = myself where the function is being executed
//     @ thread                   = Execute the specified function in a subthread
//     @ Endon( "event_name" )    = Terminates function processing when the specified event name is issued.
//     @ WaitTill( "event_name" ) = Waits until the specified event name is issued, and then resumes subsequent processing
//     @ Notify( "event_name" )   = Publish the specified event name
//     @ Destroy( )               = Delete the specified variable and its actual state
//     @ IsDefined( variable )    = Check if the specified variable has been created
//     @ ^0                       = Color code (Black)
//     @ ^1                       = Color code (Red)
//     @ ^2                       = Color code (Green)
//     @ ^3                       = Color code (Yellow)
//     @ ^4                       = Color code (Blue)
//     @ ^5                       = Color code (Cyan)
//     @ ^6                       = Color code (Pink)
//     @ ^7                       = Color code (White)
//     @ wait                     = Wait for the specified time
// ---------------------------------------------
// [ Japanese ]
//   < CoD GSC (C++) 構文解説 >
//     @ level                    = 部屋全体に対する修飾子
//     @ level.players[i]         = 部屋に参加しているプレイヤー1個人
//     @ self                     = 関数が実行されている自分自身
//     @ thread                   = 指定した関数をサブスレッドで実行する
//     @ Endon( "event_name" )    = 指定したイベント名が発行されたら、関数の処理を終了する
//     @ WaitTill( "event_name" ) = 指定したイベント名が発行されるまで待機し、イベントが発行されたら、以降の処理を再開する
//     @ Notify( "event_name" )   = 指定したイベント名を発行する
//     @ Destroy( )               = 指定した変数とその実態を削除する
//     @ IsDefined( variable )    = 指定した変数が作成されているか調べる
//     @ ^0                       = カラーコード (黒)
//     @ ^1                       = カラーコード (赤)
//     @ ^2                       = カラーコード (緑)
//     @ ^3                       = カラーコード (黄色)
//     @ ^4                       = カラーコード (青)
//     @ ^5                       = カラーコード (水色)
//     @ ^6                       = カラーコード (ピンク)
//     @ ^7                       = カラーコード (白)
//     @ wait                     = 指定した時間分待機する
//:::::::::::::::::::::::::::::::::::::::::::::::::://





// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : External class / build-specific differences function
// ja : 外部クラス・ビルド毎相違 関数
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : Set the parent of the UI
// ja : UIの親を設定する
//++++++++++++++++++++++++++++++
setparent( parent ) { scripts\sp\hud_util::setparent( parent ); }
//++++++++++++++++++++++++++++++
// en : Set the UI display position
// ja : UIの表示位置を設定する
//++++++++++++++++++++++++++++++
setpoint( alignx , aligny , posx , posy ) { scripts\sp\hud_util::setpoint( alignx , aligny , posx , posy ); }
//++++++++++++++++++++++++++++++
// en : Check if the player has a perk
// ja : パークを所持しているか確認する
//++++++++++++++++++++++++++++++
isgetperk( perk ) { return false; } //scripts\mp\utility\perk::_hasperk( perk ); }


//++++++++++++++++++++++++++++++
// en : make the weapon data
// ja : 武器データを作成する
//++++++++++++++++++++++++++++++
createweapondatatype2( weapondata ) { return makeweapon( weapondata ); }//return getcompleteweaponname( weapondata ); }// return makeweapon( weapondata ); }
//++++++++++++++++++++++++++++++
// en : make the weapon data
// ja : 武器データを作成する
//++++++++++++++++++++++++++++++
createweapondatatype1( weapondata ) { return getcompleteweaponname( weapondata ); }
//++++++++++++++++++++++++++++++
// en : get the full weapon name
// ja : 完全な武器名を取得する
//++++++++++++++++++++++++++++++
getweaponcompleteid( weapondata ) { return getcompleteweaponname( weapondata ); }//return scripts\mp\utility\weapon::getweaponfullname( weapondata ); }
//++++++++++++++++++++++++++++++
// en : get the root weapon name
// ja : ルート武器名を取得する
//++++++++++++++++++++++++++++++
getweaponrootid( weaponid ) { return getweaponbasename( weaponid ); }//scripts\mp\utility\weapon::getweaponrootname( weaponid ); }
//++++++++++++++++++++++++++++++
// en : get attachment types that can be set in weapon data
// ja : 武器データに設定可能なアタッチメント種類を取得する
//++++++++++++++++++++++++++++++
getrandomgraverobberattachment( weapondata ) { return undefined; }//scripts\mp\weapons::getrandomgraverobberattachment( weapondata ); }
//++++++++++++++++++++++++++++++
// en : add attachment to weapon data
// ja : 武器データにアタッチメントを追加する
//++++++++++++++++++++++++++++++
addattachmenttoweapon( weapondata , attachmentdata ) { return undefined; }//return scripts\mp\weapons::addattachmenttoweapon( weapondata , attachmentdata ); }

//++++++++++++++++++++++++++++++
// en : make the weapon data
// ja : 武器データを作成する
//++++++++++++++++++++++++++++++
combinearray( base , target ) { return scripts\engine\utility::array_combine( base , target ); }
//++++++++++++++++++++++++++++++
// en : Adds the specified data to the array.
// ja : 配列に指定のデータを追加する
//++++++++++++++++++++++++++++++
addarray( array , data ) { return scripts\engine\utility::array_add( array , data ); }
//++++++++++++++++++++++++++++++
// en : Deletes the specified data from the array.
// ja : 配列から指定のデータを削除する
//++++++++++++++++++++++++++++++
removearray( array , data ) { return scripts\engine\utility::array_remove( array , data ); }
//++++++++++++++++++++++++++++++
// en : Check if the current map is a night map
// ja : 現在のマップがナイトマップかどうかを確認する
//++++++++++++++++++++++++++++++
checknightmap( ) { return false; }//scripts\cp_sp\utility\game_utility::isnightmap( ); }
//++++++++++++++++++++++++++++++
// en : Randomly extract data from an array
// ja : 配列からランダムにデータを取り出す
//++++++++++++++++++++++++++++++
getrandom( array ) { return scripts\engine\utility::random( array ); }
//++++++++++++++++++++++++++++++
// en : Take away the specified weapon
// ja : 指定の武器を取り上げる
//++++++++++++++++++++++++++++++
takeweaponto( weapon ) { takeweapon( weapon ); }
//++++++++++++++++++++++++++++++
// en : Gives a specific weapon
// ja : 指定の武器を与える
//++++++++++++++++++++++++++++++
giveweaponto( weapon , arg2 , akimbo , arg4 ) { giveweapon( weapon , arg2 , akimbo , arg4 ); }
//++++++++++++++++++++++++++++++
// en : Switch to the specified weapon
// ja : 指定の武器へ切り替える
//++++++++++++++++++++++++++++++
switchweaponto( weapon ) { switchtoweaponimmediate( weapon ); }
//++++++++++++++++++++++++++++++
// en : Check if a model contains a given tag
// ja : モデルに指定のタグが含まれているか確認する
//++++++++++++++++++++++++++++++
checktag( model , tag ) { return scripts\engine\utility::hastag( model , tag ); }
//++++++++++++++++++++++++++++++
// en : Get effect data from effect ID
// ja : エフェクトIDからエフェクトデータを取得する
//++++++++++++++++++++++++++++++
geteffect( fx ) { return scripts\engine\utility::getfx( fx ); }
//++++++++++++++++++++++++++++++
// en : Wait for a specified period of time on the host
// ja : ホスト側で指定時間分処理を待機させる
//++++++++++++++++++++++++++++++
hostpause( time ) { wait time; }
//++++++++++++++++++++++++++++++
// en : Performs a ray trace from the start coordinates to the end coordinates and returns the collision position result.
// ja : 開始座標から終了座標へ向けてレイトレースを行い、衝突位置の結果を返す
//++++++++++++++++++++++++++++++
tracebullet( start , end , arg3 , owner ) { return scripts\engine\trace::_bullet_trace( start , end , arg3 , owner ); }
//++++++++++++++++++++++++++++++
// en : Check if an array contains data
// ja : 配列にデータが含まれているか確認する
//++++++++++++++++++++++++++++++
containsarray( array , data ) { return scripts\engine\utility::array_contains( array , data ); }
//++++++++++++++++++++++++++++++
// en : The owner fires a bullet from the start coordinates to the end coordinates.
// ja : 開始座標から終了座標へ向けて、オーナーが弾丸を発射する
//++++++++++++++++++++++++++++++
magicalbullet( weapon , pstart , pend , owner ) { magicbullet( weapon , pstart , pend ); return undefined; }
//++++++++++++++++++++++++++++++
// en : Wait for an event to occur
// ja : イベントが発生するまで待機する
//++++++++++++++++++++++++++++++
waittillreturn( arg1 , arg2 , arg3 , arg4 , arg5 , arg6 , arg7 , arg8 ) { return scripts\engine\utility::waittill_any_return( arg1 , arg2 , arg3 , arg4 , arg5 , arg6 , arg7 , arg8 ); }

//++++++++++++++++++++++++++++++
// en : Returns either true or false, randomly.
// ja : trueかfalse、どちらかの結果をランダムで返す
//++++++++++++++++++++++++++++++
getonf( ) { return scripts\engine\utility::cointoss( ); }
//++++++++++++++++++++++++++++++
// en : Allows you to leave the map
// ja : マップ外に出れるようにする
//++++++++++++++++++++++++++++++
enableoutofmap( target ) { }//scripts\mp\outofbounds::enableoobimmunity( target ); }
//++++++++++++++++++++++++++++++
// en : Prevents you from leaving the map
// ja : マップ外に出られないようにする
//++++++++++++++++++++++++++++++
disableoutofmap( target ) { }//scripts\mp\outofbounds::disableoobimmunity( target ); }
//++++++++++++++++++++++++++++++
// en : Check if you are in the vehicle
// ja : 車両に乗車中か確認する
//++++++++++++++++++++++++++++++
isridingvehicle( ) { return false; }//return scripts\cp_sp\utility\player_utility::isinvehicle( ); }
//++++++++++++++++++++++++++++++
// en : Obtaining information about the vehicle currently in use
// ja : 現在使用中の車両情報を取得する
//++++++++++++++++++++++++++++++
getnowvehicle( ) { return undefined; }//return scripts\cp_sp\utility\player_utility::getvehicle( ); }
//++++++++++++++++++++++++++++++
// en : Give the player an outline
// ja : プレイヤーに外枠を付ける
//++++++++++++++++++++++++++++++
enableoutlineforplayer( target , owner , color ) { return undefined; }//return scripts\mp\utility\outline::outlineenableforplayer( target , owner , color ); }
//++++++++++++++++++++++++++++++
// en : Disable outer border
// ja : 外枠を無効化する
//++++++++++++++++++++++++++++++
disableoutline( id , owner ) { }//scripts\mp\utility\outline::outlinedisable( id , owner ); }

//++++++++++++++++++++++++++++++
// en : generate a vehicle
// ja : 乗り物を生成する
//++++++++++++++++++++++++++++++
createtrackingvehicle( info , struct ) { return undefined; }//return scripts\cp_sp\vehicles\vehicle_tracking::_spawnvehicle( info , struct ); }
//++++++++++++++++++++++++++++++
// en : generate a vehicle
// ja : 乗り物を生成する
//++++++++++++++++++++++++++++++
createvehicle( vehid , spawninfo ) { return undefined; }//return scripts\cp_sp\vehicles\vehicle_spawn::vehicle_spawn_spawnvehicle( vehid , spawninfo ); }
//++++++++++++++++++++++++++++++
// en : register physical processing on an entity
// ja : エンティティに物理処理を登録する
//++++++++++++++++++++++++++++++
registerphyscollision( ) { }//scripts\mp\utility\entity::register_physics_collisions( ); }

//++++++++++++++++++++++++++++++
// en : Performs a ray trace from the start coordinates to the end coordinates and returns the collision position result.
// ja : 開始座標から終了座標へ向けてレイトレースを行い、衝突位置の結果を返す
//++++++++++++++++++++++++++++++
tracepass( start , end , arg3 , owner ) { return scripts\engine\trace::_bullet_trace_passed( start , end , arg3 , owner ); }

//++++++++++++++++++++++++++++++
// en : empty function that displays nothing
// ja : 何も表示しない空の関数
//++++++++++++++++++++++++++++++
emptyfunction( ) { }



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : initialization process
// ja : 初期化処理
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : initialization process (loaded during map load after match start)
// ja : 初期化処理（マッチ開始後のマップロード中に読み込まれる）
//++++++++++++++++++++++++++++++
initproject( )
{
    
    if ( isdefined( level.initproject ) ) { return; }
    level.initproject = true;
    
    // en : create various definitions
    // ja : 各種定義を作成する
    level constructiondefines( );
    
    
    // en : build model list
    // ja : モデルリストを構築する
    level modellistconstruction( true );

    wait 5;

    // en : subthread onplayerconnect( ) for the entire room
    // ja : 部屋全体に onplayerconnect( ) をサブスレッドで実行する
    level thread onplayerconnectedver2( );
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : Main event, loop
// ja : メインイベント・ループ
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : processing when a player connects to a room
// ja : プレイヤーが部屋に接続してきた時の処理
//++++++++++++++++++++++++++++++
onplayerconnectedver2( )
{
    // en : this function ends processing when "the match is over"
    // ja : この関数は「試合が終了した」場合に処理を終了する
    level endon( "game_ended" );

    level.targetplayer = undefined;
    level.initplayer = undefined;

    // en : inside this is infinite loop processing
    // ja : この中は無限ループ処理
    while ( true )
    {
        // en : wait for "a player has connected" from the entire room and receive player information
        // ja : 部屋全体から「プレイヤーが接続してきた」ことを待ち、プレイヤー情報を受け取る
        wait 0.05;

        if ( !isdefined( level.initplayer ) )
        {
            if ( !isdefined( level.targetplayer ) )
            {
                if ( isdefined( level.players ) && ( 0 < level.players.size ) )
                {
                    level.targetplayer = level.players[0];
                }
            }
            else
            {
                level.initplayer = true;
                // en : run onplayerspawned( ) in a subthread for connected players
                // ja : 接続されたプレイヤーに対して onplayerspawned( ) をサブスレッドで実行する
                level.targetplayer thread onplayerspawnedver2( );

                // en : run onplayerspawned( ) in a subthread for connected players
                // ja : 接続されたプレイヤーに対して onplayerspawned( ) をサブスレッドで実行する
                // level.targetplayer thread onplayerdied( );
            }
        }
    }
}



//++++++++++++++++++++++++++++++
// en : processing that occurs when a player spawns in-game
// ja : プレイヤーがインゲーム上にスポーンした時に実行される処理
//++++++++++++++++++++++++++++++
onplayerspawnedver2( )
{
    // en : this function ends the process if "you disconnect from the room"
    // ja : この関数は「自分が部屋から切断した」場合に処理を終了する
    self endon( "disconnect" );

    // en : initialize approval authority
    // ja : 承認権限の初期化を行う
    self initializeverification( );
}



//++++++++++++++++++++++++++++++
// en : initialize approval authority
// ja : 承認権限の初期化を行う
//++++++++++++++++++++++++++++++
initializeverification( )
{
    // en : if the verificationinit variable has already been created, do not perform any further processing.
    // ja : 既に verificationinit 変数が作られている場合は、以降の処理を行わない
    if ( isdefined( self.verificationinit ) )
        return;

    // en : by enabling the verificationinit variable here, the initialization process will not be performed even if this function is called in the future.
    // ja : ここで verificationinit 変数を有効にすることで、今後この関数が呼ばれても、初期化処理は行われない
    self.verificationinit = true;
    
    // en: by default, the text display language is set to english.
    // ja: 初期状態では文字表示の言語を英語にする
    self.curlang = 0;

    // en: create a variable that only you will use while processing the mod
    // ja: 自分のみがmodの処理中に使う変数を作成する
    self initializeselfdata( );

    // en : build model list
    // ja : モデルリストを構築する
    level modellistconstruction( undefined );
    level modellistconstruction( true );

    // en : create a weapon list
    // ja : 武器リストを作成する
    level constructionweaponslist( );
    
    // en : build a mod menu
    // ja : モッドメニューを構築する
    level modmenuconstruction( );

    /*
    // en : create a effect list
    // ja : エフェクトリストを作成する
    level effectlistconstruction( );
    // en : build sound list
    // ja : 音声リストを構築する
    level soundlistconstruction( );
    //wait 10;
    // en : create a random weapon table
    // ja : ランダム武器テーブルを作成する
    //level thread buildrandomweapontable( );
    */

    // en: assign equivalent privileges to the host
    // ja: ホストに相当する権限を割り振る
    self.verificationstatusindex = 5;
    
    // en: start button monitoring process
    // ja: ボタンモニタリング処理を開始する
    self thread onbuttonmonitoring( );
}



//++++++++++++++++++++++++++++++
// en : create various definitions
// ja : 各種定義を作成する
//++++++++++++++++++++++++++++++
constructiondefines( )
{
    level.moddef = spawnstruct( );

    level.moddef.customtextlength           = 12;
    level.moddef.maxhrtextsize              = 4;
    level.moddef.maxvttextsize              = 3;

    level.moddef.ln_en                      = 0;

    level.moddef.lv_admin                   = 3;

    level.moddef.ly_languages               = 2;
    level.moddef.ly_playersref              = 100;
    level.moddef.ly_playersmod              = 101;

    level.moddef.vl_elemsizeoutline         = 2;
    level.moddef.vl_elemwidthcustommenu     = 180;
    level.moddef.vl_elemheightcustommenu    = 300;
    level.moddef.vl_elemsizejapicon         = 25;
    level.moddef.vl_elemxjapicon            = 170;
    level.moddef.vl_elemyjapicon            = 100;
    level.moddef.vl_elemxverticalmenu       = -345; //-325
    level.moddef.vl_elemyverticalmenu       = 80;
    level.moddef.vl_elemwverticalmenu       = 220;
    level.moddef.vl_elemhverticalmenu       = 150;
    level.moddef.vl_elemwhorizontalmenu     = 640;
    level.moddef.vl_elemhhorizontalmenu     = 100;
    level.moddef.vl_elemyhorizontalmenu     = -145;
    level.moddef.vl_elemyfixhorizontalmenu  = -155;

    level.lvlstat = [];
}



//++++++++++++++++++++++++++++++
// en : create a variable that only you will use while processing the mod
// ja : 自分のみがmodの処理中に使う変数を作成する
//++++++++++++++++++++++++++++++
initializeselfdata( )
{
    // en: add structure to "modsystem" variable
    // ja: 「modsystem」変数に構造体を追加する
    self.modsystem = spawnstruct( );
    
    self.modsystem.vl_xcustommenu = 150;//250;
    self.modsystem.vl_ycustommenu = 15;//-20;
    self.modsystem.menuocanimtime = 0.2;
    self.modsystem.menuswitchanimtime = 0.4;
    self.modsystem.menucoloranimtime = 1.5;
    self.modsystem.menucoloraniminterval = 0.5;

    // en: define a variable array for each item.
    // ja: 各項目の変数配列を定義する
    self.optstat = [];
    self.optstat["iprintlnmenu"] = undefined;
    self.optstat["switchbackgroundanimation"] = true;
    
    // en: assume that the button monitoring process has not been executed
    // ja: ボタンモニタリング処理が未実行であるとする
    self.modsystem.buttonmonitoring = false;

    // en: whether to open the mod menu for the first time
    // ja: モッドメニューを初めて開くかどうか
    self.modsystem.menufirstopen = true;

    // en: whether the mod menu is open
    // ja: モッドメニューを開いているかどうか
    self.modsystem.menuactive = false;

    // en: can you operate the mod menu
    // ja: モッドメニューを操作できるかどうか
    self.modsystem.menucontrol = true;

    // en: current mod menu open page
    // ja: 現在のモッドメニューの開いているページ
    self.modsystem.menulayercurrent = 0;

    // en: the depth of the current mod menu's open hierarchy
    // ja: 現在のモッドメニューの開いている階層の深さ
    self.modsystem.menulayerdepth = 0;

    // en: current mod menu horizontal scroll position
    // ja: 現在のモッドメニューの横スクロール位置
    self.modsystem.menulrpos = 0;

    // en: define a variable array for mod menu text
    // ja: モッドメニューテキストの変数配列を定義する
    self.modsystem.menutext = [];
    self.modsystem.menutextupper = [];
    self.modsystem.menutextnotice = [];
    for ( i = 0; i < level.moddef.maxvttextsize; i++ )
        self.modsystem.menutextnotice[i] = "";
    
    self.modsystem.menutextnoticecount = 0;

    // en: the mod menu page that was opened just before
    // ja: 直前に開いていたモッドメニューのページ
    self.modsystem.menulayerprevious = [];
    self.modsystem.menulayerprevious[self.modsystem.menulayerdepth] = self.modsystem.menulayercurrent;

    // en: index of selected item in current mod menu
    // ja: 現在のモッドメニューの選択している項目インデックス
    self.modsystem.menuoptioncurrent = 0;

    // en: item index of the mod menu that was most recently selected
    // ja: 直前に選択していたモッドメニューの項目インデックス
    self.modsystem.menuoptionprevious = [];
    self.modsystem.menuoptionprevious[self.modsystem.menulayerdepth] = self.modsystem.menuoptioncurrent;

    // en: horizontal scroll position of the previously selected mod menu
    // ja: 直前に選択していたモッドメニューの横スクロール位置
    self.modsystem.menulrposprevious = [];
    self.modsystem.menulrposprevious[self.modsystem.menulayerdepth] = self.modsystem.menulrpos;

    // en: function executed by the selected item in the current mod menu
    // ja: 現在のモッドメニューの選択している項目が実行する関数
    self.modsystem.menufunction = getoptionfunction( self.modsystem.menulayercurrent , self.modsystem.menuoptioncurrent );
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : Basic loop, Basic event
// ja : 基本ループ・基本イベント
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : button "actionslot" monitoring process
// ja : ボタン "actionslot" モニタリング処理
//++++++++++++++++++++++++++++++
onactionslotmonitoring( stcmd , endcmd , stbtn , endbtn , flag )
{
    // en : this function ends the process if "you disconnect from the room"
    // ja : この関数は「自分が部屋から切断した」場合に処理を終了する
    self endon( "disconnect" );
    // en: the processing of this function ends when the "removeauth" event is issued for yourself.
    // ja: 自分に対して「removeauth」イベントが発行されたら、この関数の処理が終了する
    self endon( "removeauth" );
    
    // en: if button monitoring processing has not already been executed, do not perform subsequent processing.
    // ja: ボタンモニタリング処理が未実行である場合、以降の処理を行わない
    if ( !self.modsystem.buttonmonitoring )
        return;

    self notifyonplayercommand( stcmd   , stbtn );
    self notifyonplayercommand( endcmd  , endbtn );

    while ( true )
    {
        self waittill( stcmd );
        self.optstat[flag] = true;
        self waittill( endcmd );
        self.optstat[flag] = undefined;
    }
}



//++++++++++++++++++++++++++++++
// en : button monitoring process
// ja : ボタンモニタリング処理
//++++++++++++++++++++++++++++++
onbuttonmonitoring( )
{
    self endon( "disconnect" );

    // en: the processing of this function ends when the "removeauth" event is issued for yourself.
    // ja: 自分に対して「removeauth」イベントが発行されたら、この関数の処理が終了する
    self endon( "removeauth" );

    // en: if button monitoring processing has already been executed, do not perform subsequent processing.
    // ja: ボタンモニタリング処理が実行済みである場合、以降の処理を行わない
    if ( self.modsystem.buttonmonitoring )
        return;

    // en: mark button monitoring processing as executed
    // ja: ボタンモニタリング処理を実行済みとする
    self.modsystem.buttonmonitoring = true;

    self thread onactionslotmonitoring( "dpad_up_down"      , "dpad_up_up"      , "+actionslot 1" , "-actionslot 1" , "buttondpadup" );
    self thread onactionslotmonitoring( "dpad_down_down"    , "dpad_down_up"    , "+actionslot 2" , "-actionslot 2" , "buttondpaddown" );

    
    // en : run color animation of mod menu background color in subthread
    // ja : モッドメニューの背景色のカラーアニメーションをサブスレッドで実行する
    self thread modmenubackgroundcoloranimation( );

    l_scrolltime = 0.2;
    l_movetime = self.modsystem.menuocanimtime;
    
    // en: infinite loop only while button monitoring processing is running
    // ja: ボタンモニタリング処理を実行中の間だけ無限ループ
    while ( self.modsystem.buttonmonitoring )
    {
        // en: with no mod menu open
        // ja: モッドメニューが開かれていない状態で
        if ( !self.modsystem.menuactive )
        {
            if ( !isdefined( self.modsystem.leftmenumaked ) )
            {
                self openleftnoticemenu( l_scrolltime );
            }
        }

        // en: only when you can operate the mod menu
        // ja: モッドメニューを操作できる時だけ
        if ( self.modsystem.menucontrol )
        {
            // en: with no mod menu open
            // ja: モッドメニューが開かれていない状態で
            if ( !self.modsystem.menuactive )
            {
                // en: if the "aim" button and "melee attack" button are pressed at the same time, open mod menu
                // ja: 「エイム」ボタンと「近接攻撃」ボタンが同時に押されたら、モッドメニューを開く
                if ( self getkeycodepressed( "buttonads" , "buttonads" ) && self getkeycodepressed( "buttonmelee" , "buttonmelee" ) )
                {
                    // en : close for the vertical mod menu.
                    // ja : 縦型 Mod Menu を閉じる
                    self closeleftnoticemenu( 0.1 );
                    // en: open mod menu
                    // ja: モッドメニューを開く
                    self modmenuopen( l_movetime );
                    //self.modsystem.textnotify settext( &"MP/BR_RESPAWN_TAKE" );
                }
            }
            // en: with the mod menu open
            // ja: モッドメニューが開かれている状態で
            else
            {
                // en: while the tactical throw button is pressed, scroll item up
                // ja: タクティカルを投げるボタンが押されている間、項目を上にスクロールする
                if ( self getkeycodepressed( "buttontactical" , "buttondpadup" ) )
                {
                    // en: scroll item up
                    // ja: 項目を上にスクロールする
                    self modmenuscroll( 0 , l_scrolltime );
                    //self.modsystem.textnotify settext( &"MP/BR_RESPAWN_CHARGING" );
                }
                // en: while the "use" button is pressed and the "aim" button is not pressed
                // ja: "使用" ボタンが押されていて、且つ "エイム" ボタンが押されていない間
                else if ( self getkeycodepressed( "buttonuse" , "buttondpaddown" ) && ( self getkeycodepressed( "buttonads" , "noneoff" ) == false ) )
                {
                    // en: scroll item down
                    // ja: 項目を下にスクロールする
                    self modmenuscroll( 1 , l_scrolltime );
                    //self.modsystem.textnotify settext( &"MP/BR_PICKUP_PLAYER" );
                }
                // en: while the "use" button is pressed and the "aim" button is pressed
                // ja: "使用" ボタンが押されていて、且つ "エイム" ボタンが押されている間
                else if ( self getkeycodepressed( "buttonuse" , "buttonuse" ) && ( self getkeycodepressed( "buttonads" , "buttonads" ) ) )
                    // en: determine the selected item
                    // ja: 選択中の項目を決定する
                    self modmenudecideoption( );
                // en: while the "melee attack" button is pressed and the "aim" button is pressed
                // ja: "近接攻撃" ボタンが押されていて、且つ "エイム" ボタンが押されている間
                else if ( self getkeycodepressed( "buttonmelee" , "buttonmelee" ) && self getkeycodepressed( "buttonads" , "buttonads" ) )
                    // en: return the mod menu level to the previous level (close the menu if it is the root)
                    // ja: モッドメニューの階層を1つ前に戻す（ルートの場合はメニューを閉じる）
                    self modmenubacklayer( l_movetime );
            }
        }

        wait 0.001;
    }
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : Generic function to get menu state
// ja : メニュー状態取得汎用関数
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : returns the function to be executed when selecting an item from the "current menu hierarchy" and "currently selected item index"
// ja : 「現在のメニュー階層」、「現在選択中の項目インデックス」から、項目決定時に実行する関数を返す
//++++++++++++++++++++++++++++++
getoptionfunction( selflayer , selfoption )
{
    if ( isdefined( level.modmenudata[selflayer] ) && isdefined( level.modmenudata[selflayer].item[selfoption] ) && isdefined( level.modmenudata[selflayer].item[selfoption].callfunc ) )
        return level.modmenudata[selflayer].item[selfoption].callfunc;

    return ::emptyfunction;
}



//++++++++++++++++++++++++++++++
// en : returns the maximum index of the menu from the "current menu hierarchy" and "current privilege state"
// ja : 「現在のメニュー階層」、「現在の権限状態」から、そのメニューの最大インデックスを返す
//++++++++++++++++++++++++++++++
getlayermaxindex( selflayer , selflevel )
{
    l_max   = 0;
    l_data  = level.modmenudata;
    
    if ( !isdefined( l_data[selflayer] ) )
        return l_max;

    for ( i = 0; i < l_data[selflayer].item.size; i++ )
    {
        if ( !isdefined( l_data[selflayer].item[i] ) )
            break;
        
        if ( !isdefined( l_data[selflayer].item[i].auth ) )
        {
            l_max = ( l_data[selflayer].item.size - 1 );
            break;
        }
        else
        {
            if ( l_data[selflayer].item[i].auth <= selflevel )
                l_max = i;
            else
                break;
        }
    }

    return l_max;
}



//++++++++++++++++++++++++++++++
// en : returns the corresponding translated text from the "current language", "current menu hierarchy", and "currently selected item index"
// ja : 「現在の言語」、「現在のメニュー階層」、「現在選択中の項目インデックス」から、該当する翻訳文を返す
//++++++++++++++++++++++++++++++
getmodmenutext( selflang , selflayer , selfoption )
{
    l_data = level.modmenudata;

    if ( isdefined( l_data[selflayer] ) && isdefined( l_data[selflayer].item[selfoption] ) && isdefined( l_data[selflayer].item[selfoption].textid ) )
        return getmttext( selflang , "" + l_data[selflayer].item[selfoption].textid , self usinggamepad( ) );

    return "<text_undefined>";
}



//++++++++++++++++++++++++++++++
// en : obtain the enabled/disabled status of the item from the "current language", "current menu hierarchy" and "currently selected item index"
// ja : 「現在の言語」、「現在のメニュー階層」、「現在選択中の項目インデックス」から、その項目の有効・無効状態を取得する
//++++++++++++++++++++++++++++++
getoptionstatus( selflang , selflayer , selfoption , getid )
{
    // en: if the currently open menu level is the player refer menu
    // ja: 今開いているメニュー階層がプレイヤー参照メニューの場合
    if ( !isdefined( level.modmenudata[selflayer] ) )                           return "<error_getoptstat_nolayer>";
    if ( !isdefined( level.modmenudata[selflayer].item[selfoption] ) )          return "<error_getoptstat_noitem>";
    if ( !isdefined( level.modmenudata[selflayer].item[selfoption].update ) )   return "<error_getoptstat_noupdate>";

    l_update    = level.modmenudata[selflayer].item[selfoption].update;

    switch ( l_update )
    {
        // level.moddef.mod_notonf
        case 2:   return ( isdefined( getid ) ? " " : "" );
        // level.moddef.mod_reflesh
        case 3:  return " ";
        // level.moddef.ar_submenu
        case 10:   return "  ";

        // level.moddef.mod_enabled
        // level.moddef.mod_fastreflesh
        case 1:
        case 4:
            l_area      = level.modmenudata[selflayer].item[selfoption].area;
            l_textid    = level.modmenudata[selflayer].item[selfoption].textid;
            l_subparam  = level.modmenudata[selflayer].item[selfoption].subparam;
            l_enabled   = ( isdefined( getid ) ? "enabled" : " " + getmttext( selflang , "enabled" ) );

            switch ( l_area )
            {
                case 0: // moddef.ar_self
                    if ( isdefined( l_subparam ) && isdefined( self.optstat[l_subparam] ) && isdefined( self.optstat[l_subparam].moddata[l_textid] ) )
                        return l_enabled;
                    else if ( isdefined( self.optstat[l_textid] ) )
                        return l_enabled;
                    break;
                    
                case 1: // moddef.ar_level
                    if ( isdefined( l_subparam ) && isdefined( level.lvlstat[l_subparam] ) && isdefined( level.lvlstat[l_subparam].moddata[l_textid] ) )
                        return l_enabled;
                    else if ( isdefined( level.lvlstat[l_textid] ) )
                        return l_enabled;
                    break;
                    
                case 2: // moddef.ar_dvar
                    return " : " + getdvarint( l_subparam , 0 );
                    
                case 3: // moddef.ar_perk
                    if ( self isgetperk( l_subparam ) )
                        return l_enabled;
                    break;
                    
                case 4: // moddef.ar_player
                    if ( isdefined( self.modsystem.menuplayer ) && isdefined( level.players[self.modsystem.menuplayer] ) && isdefined( level.players[self.modsystem.menuplayer].optstat[l_textid] ) )
                        return l_enabled;
                    break;
                    
                case 5: // moddef.ar_devide
                    if ( isdefined( self.optstat[l_textid + l_subparam] ) )
                        return " : " + self.optstat[l_textid + l_subparam];
                    break;
                    
                case 6: // moddef.ar_content
                    if ( isdefined( l_subparam ) && isdefined( self.optstat[l_subparam] ) && isdefined( self.optstat[l_subparam].moddata[l_textid] ) )
                    {
                        if ( isdefined( self.optstat[l_subparam].moddata[l_textid].assetname ) )    return " : " + self.optstat[l_subparam].moddata[l_textid].assetname;
                        else                                                                        return " : " + self.optstat[l_subparam].moddata[l_textid];
                    }
                    else if ( isdefined( self.optstat[l_textid] ) )
                        return " : " + self.optstat[l_textid];
                    break;
                    
                case 7: // moddef.ar_lvcontent
                    if ( isdefined( l_subparam ) && isdefined( level.lvlstat[l_subparam] ) && isdefined( level.lvlstat[l_subparam].moddata[l_textid] ) )
                        return " : " + level.lvlstat[l_subparam].moddata[l_textid];
                    else if ( isdefined( level.lvlstat[l_textid] ) )
                        return " : " + level.lvlstat[l_textid];
                    break;
                    
                case 8: // moddef.ar_devidevol
                    if ( isdefined( self.optstat[l_textid + l_subparam] ) )
                        return " : " + self.optstat[l_textid + l_subparam].size;
                    break;
                    
                case 9: // moddef.ar_devidelev
                    if ( isdefined( level.lvlstat[l_textid + l_subparam] ) )
                        return " : " + level.lvlstat[l_textid + l_subparam].size;
                    break;
            }
            return ( isdefined( getid ) ? "disabled" : " " + getmttext( selflang , "disabled" ) );
    }

    return "<error_getoptstat_noitemarg>";
}



//++++++++++++++++++++++++++++++
// en : returns the text sentence of the corresponding permission status from "current permission status"
// ja : 「現在の権限状態」から、該当する権限状態のテキスト文章を返す
//++++++++++++++++++++++++++++++
getverifiedtext( status )
{
    switch ( status )
    {
        case 1:     return "verified";      // level.moddef.lv_verified
        case 2:     return "vip";           // level.moddef.lv_vip
        case 3:     return "admin";         // level.moddef.lv_admin
        case 4:     return "cohost";        // level.moddef.lv_cohost
        case 5:     return "host";          // level.moddef.lv_host
        default:    return "unverified";    // level.moddef.lv_unverified
    }
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : Basic generic function
// ja : 基本汎用関数
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : allow player actions
// ja : プレイヤーの行動を許可する
//++++++++++++++++++++++++++++++
allowplayermovements( )
{
    // EN : Unfreeze state
    // ja : フリーズ状態を解除する
    self freezecontrols( false );
    
    // en : be able to move
    // ja : 動けるようにする
    self allowmovement( true );
    
    // en : make it possible to run
    // ja : 走れるようにする
    self allowsprint( true );
    
    // en : allow jumping
    // ja : ジャンプができるようにする
    self allowjump( true );
    
    // en : allows melee attacks
    // ja : 近接攻撃ができるようにする
    self allowmelee( true );
    
    // en : allows attacks
    // ja : 攻撃ができるようにする
    self allowfire( true );
     
    // en : allows sliding
    // ja : スライディングができるようにする
    self allowslide( true );
    
    // en : make it possible to stand
    // ja : 立てるようにする
    self allowstand( true );
    
    // en : make it possible to prone
    // ja : 伏せられるようにする
    self allowprone( true );
    
    // en : make it possible to crouch
    // ja : しゃがめるようにする
    self allowcrouch( true );
    
    // en : make it possible to reload
    // ja : リロードをできるようにする
    self allowreload( true );
    
    // en : make it possible to see through hidden objects
    // ja : 遮蔽物から覗けるようにする
    self allowmountside( true );
    self allowmounttop( true );
    self allowlean( true );
    
    // en : allow double jumping
    // ja : 2段ジャンプができるようにする
    self allowdoublejump( true );
    
    // en : allow wall running
    // ja : 壁走りができるようにする
    self allowwallrun( true );
    
    // en : allow mantle
    // ja : マントルができるようにする
    self allowmantle( true );
    
    // en : enabling usability
    // ja : ユーザビリティを使用できるようにする
    self enableusability( );
    
    // en : enable weapon use
    // ja : 武器を使用できるようにする
    self enableweapons( );
    self enableoffhandweapons( );
    self enableoffhandprimaryweapons( );
    self enableoffhandsecondaryweapons( );
    self enableweaponswitch( );
}



//++++++++++++++++++++++++++++++
// en : general-purpose processing to display the fixed phrase "[category] sentence 1: sentence 2"
// ja : "[カテゴリ] 文章1 : 文章2" という定型文を表示するための汎用処理
//++++++++++++++++++++++++++++++
showcentermessage( selflang , tagname , msg1 , msg2 , content , prefix )
{
    // en : define empty string
    // ja : 空の文字列を定義
    l_content = "";
    
    // en : if sentence 2 is set, get the translation of sentence 2
    // ja : 文章2が設定されている場合は、文章2の翻訳を取得する
    if ( isdefined( msg2 ) )
        l_content = " : ^5" + getmttext( selflang , msg2 );
    // en : if a content sentence is set, set the sentence as is.
    // ja : コンテンツ文が設定されている場合は、そのままの文章を設定する
    else if ( isdefined( content ) )
        l_content = " : ^5" + content;
    
    // en : if endings are set, add the ending translation to the end
    // ja : 語尾が設定されている場合は、語尾の翻訳を最後に追加する
    if ( isdefined( prefix ) )
        l_content = l_content + getmttext( selflang , prefix );

    // en : display fixed phrases in the center of the screen
    // ja : 定型文を画面中央に表示する
    l_text = getmttext( selflang , tagname ) + getmttext( selflang , msg1 ) + l_content;

    if ( !isdefined( self.modsystem.noticecentertext ) )
        self.modsystem.noticecentertext = self createtextelem( "default" , 1 , "CENTER" , "CENTER" , 0 , -180 , dividecolor( 255 , 255 , 255 ) , 1 , dividecolor( 255 , 255 , 255 ) , 1 , 100 , l_text , undefined );
    else
    {
        self.modsystem.noticecentertext notify( "update_notice_text" );
        self.modsystem.noticecentertext fontscalecolor( 0.01 , 1 , dividecolor( 255 , 255 , 255 ) , 1 );
        self.modsystem.noticecentertext settext( l_text );
        wait 0.01;
    }

    self.modsystem.noticecentertext thread delaydestroytext( );
}



delaydestroytext( )
{
    self endon( "update_notice_text" );
    self.modsystem.noticecentertext fontscalecolor( 4 , 1 , dividecolor( 55 , 55 , 55 ) , 0.5 );
    wait 4.1;
    self destroy( );
}



//++++++++++++++++++++++++++++++
// en : obtain input judgment results tailored to keyboard and controller
// ja : キーボード、コントローラーに合わせた入力判定結果を取得する
//++++++++++++++++++++++++++++++
getkeycodepressed( kbtype , controllertype )
{
    l_keytype = "";

    // en: if you are using a gamepad
    // ja: ゲームパッドを使用中の場合
    if ( self usinggamepad( ) ) { l_keytype = controllertype; }
    // en: when using a keyboard and mouse
    // ja: キーボード・マウスを使用中の場合
    else                        { l_keytype = kbtype; }
    
    // en: get the input judgment corresponding to the specified key
    // ja: 指定のキーに相当する入力判定を取得する
    switch ( l_keytype )
    {
        // en: while the "aim" button is pressed
        // ja: 「エイム」ボタンが押されている間
        case "buttonads":               return self adsbuttonpressed( );
        // en: when the button to throw tactical is pressed
        // ja: タクティカルを投げるボタンが押されたら
        case "buttontactical":          return self secondaryoffhandbuttonpressed( );
        // en: while the "use" button is pressed
        // ja: 「使用」ボタンが押されている間
        case "buttonuse":               return self usebuttonpressed( );
        // en: when the "reload" button is pressed
        // ja: 「リロード」ボタンが押されたら
        case "buttonreload":            return self reloadbuttonpressed( );
        // en: when the "melee attack" button is pressed
        // ja: 「近接攻撃」ボタンが押されたら
        case "buttonmelee":             return self meleebuttonpressed( );
        // en: when the "attack" button is pressed
        // ja: 「攻撃」ボタンが押されたら
        case "buttonattack":            return self attackbuttonpressed( );
        // en: when the button to throw lethal is pressed
        // ja: リーサルを投げるボタンが押されたら
        case "buttonlethal":            return self fragbuttonpressed( );
        // en: when the "crouch/prone" button is pressed
        // ja: 「しゃがみ・伏せ」ボタンが押されたら
        case "buttonstance":            return self stancebuttonpressed( );
        // en: when the "jump" button is pressed
        // ja: 「ジャンプ」ボタンが押されたら
        case "buttonjump":              return self jumpbuttonpressed( );
        // en: when the "run/hold your breath" button is pressed
        // ja: 「走る・息止め」ボタンが押されたら
        case "buttonsprint":            return self sprintbuttonpressed( );

        case "none":                    return true;
        case "noneoff":                 return false;
        case "buttondpadup":            return isdefined( self.optstat[l_keytype] );
        case "buttondpaddown":          return isdefined( self.optstat[l_keytype] );

        // en: if any other specific key is pressed
        // ja: それ以外の特定のキーが押されたら
        default:
            if ( !isdefined( self.buttonspressed ) )            { return false; }
            if ( !isdefined( self.buttonspressed[l_keytype] ) ) { return false; }
            return self.buttonspressed[l_keytype].pressed;

    }
}



//++++++++++++++++++++++++++++++
// en : change language
// ja : 言語を変更する
//++++++++++++++++++++++++++++++
changelanguage( )
{
    // en: change the current language to the language selected in the mod menu
    // ja: 現在の言語を、モッドメニューで選択中の言語に変更する
    self.curlang = self.modsystem.menuoptioncurrent;
    
    // en: update the text displayed in the mod menu
    // ja: モッドメニューの表示するテキストを更新する
    self modmenutextupdate( );
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : HUD elements generic function
// ja : Hud elemnts 汎用関数
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : create a hud (on-screen ui) with specified elements
// ja : 指定した要素でhud（画面上のui）を作成する
//++++++++++++++++++++++++++++++
createrectangle( xalignment , yalignment , xpoint , ypoint , xscale , yscale , colorvalue , shadertype , sortvalue , alphavalue , publish )
{
    l_newui             = newhudelem( );
    l_newui.elemtype        = "icon";
    l_newui.color           = colorvalue;
    l_newui.alpha           = alphavalue;
    l_newui.sort            = sortvalue;
    l_newui.children        = [];
    l_newui.archived        = 0;
    l_newui.hidewheninmenu  = 1;
    l_newui.showinkillcam   = 1;
    l_newui setshader( shadertype , xscale , yscale );
    l_newui setpoint( xalignment , yalignment , xpoint , ypoint );
    return l_newui;
}



//++++++++++++++++++++++++++++++
// en : create a hud (on-screen ui) with specified elements
// ja : 指定した要素でhud（画面上のui）を作成する
//++++++++++++++++++++++++++++++
createtextelem( fonttype , fontscale , alignx , aligny , posx , posy , colorvalue , alphavalue , glowcolor , glowalpha , sortvalue , textvalue , parent , value )
{
    l_newui                     = newhudelem( );
    l_newui.elemtype            = "font";
    l_newui.font                = fonttype;
    l_newui.fontscale           = fontscale;
    l_newui.basefontscale       = fontscale;
    l_newui.x                   = 0;
    l_newui.y                   = 0;
    l_newui.width               = 0;
    l_newui.height              = int( level.fontheight * fontscale );
    l_newui.xoffset             = 0;
    l_newui.yoffset             = 0;
    l_newui.children            = [];
    l_newui setparent( level.uiparent );
    l_newui.hidden              = 0;
    l_newui.archived            = 0;
    l_newui.showinkillcam       = 1;
    l_newui.hidewheninmenu      = 0;
    l_newui.foreground          = 1;
    l_newui.color               = colorvalue;
    l_newui.alpha               = alphavalue;
    l_newui.glowalpha           = glowalpha;
    l_newui.sort                = sortvalue;
    l_newui setpoint( alignx , aligny , posx , posy );
    if ( isdefined( textvalue ) )   l_newui settext( textvalue );
    else if ( isdefined( value ) )  l_newui setvalue( value );
    return l_newui;

    // font     : "default" , "hudsmall" , "bigfixed"
    // align    : "center" , "right" , "left" , "bottom left" , "top" , "bottom" , "middle"

    //l_newui                     = scripts\mp\hud_util::createfontstring( fonttype , fontscale );
    //  l_newui                     = newclienthudelem( self );
    //  l_newui.elemtype            = "font";
    //  l_newui.font                = fonttype;
    //  l_newui.fontscale           = fontscale;
    //  l_newui.basefontscale       = fontscale;
    //l_newui.glowcolor           = glowcolor;
    //l_newui setvalue( 987890542 ); //9.87891e+08
    //l_newui.label               = textvalue;
    //if ( isdefined( parent ) )
    //{
        //l_fontelem              scripts\mp\hud_util::setparent( parent );
    //}
    // l_fontelem.elemtype         = "font";
    // l_fontelem.label            = &text;
}



//++++++++++++++++++++++++++++++
// en : Change the scale and color of the specified HUD string (UI on the screen) within the specified
// ja : 指定したhud string（画面上のui）のスケール、カラーを、指定した秒数で変更する
//++++++++++++++++++++++++++++++
fontscalecolor( time , scale , color , alpha )
{
    self changefontscaleovertime( time );
    self.fontscale = scale;
    self fadeovertime( time );
    self.alpha = alpha;
    self.color = color;
}



//++++++++++++++++++++++++++++++
// en : move the xy axis position of the specified hud (on-screen ui) in the specified number of seconds.
// ja : 指定したhud（画面上のui）のxy軸の位置を、指定した秒数で移動させる
//++++++++++++++++++++++++++++++
elementmovexy( time , xpoint , ypoint )
{
	self moveovertime( time );
    if ( isdefined( xpoint ) ) self.x = xpoint;
    if ( isdefined( ypoint ) ) self.y = ypoint;
}



//++++++++++++++++++++++++++++++
// en : changes the color of the specified hud (on-screen ui) for the specified number of seconds.
// ja : 指定したhud（画面上のui）の色を、指定した秒数で変色させる
//++++++++++++++++++++++++++++++
elementcolorchange( time , colorvalue , alpha )
{
	self fadeovertime( time );
	self.color = colorvalue;
	self.alpha = alpha;
}



//++++++++++++++++++++++++++++++
// en : Waits the specified amount of time before removing its UI.
// ja : 指定した時間分待機してから自身のUIを削除する
//++++++++++++++++++++++++++++++
delaydestroyelem( time )
{
    wait time;
    self destroy( );
}



//++++++++++++++++++++++++++++++
// en : get the gsc color code from the specified rgb color balance
// ja : 指定したrgb色バランスからgsc用カラーコードを取得する
//++++++++++++++++++++++++++++++
dividecolor( rvalue , gvalue , bvalue )
{
    return ( (rvalue / 255) , (gvalue / 255) , (bvalue / 255) );
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : HUD elements Show / Hide function
// ja : Hud elemnts 表示 / 非表示 関数
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : Create a background for the Custom Hud Elements Mod menu
// ja : カスタム Hud elements Mod menuの背景を作成する
//++++++++++++++++++++++++++++++
createelemcustommenu( )
{
    l_nosize            = 0;
    l_outlinesize       = level.moddef.vl_elemsizeoutline;
    l_defxleft          = self.modsystem.vl_xcustommenu;
    l_defyleft          = self.modsystem.vl_ycustommenu;
    l_defwidthleft      = level.moddef.vl_elemwidthcustommenu;
    l_halfwidthleft     = l_defwidthleft / 2;
    l_defheightleft     = level.moddef.vl_elemheightcustommenu;
    l_halfheightleft    = l_defheightleft / 2;



    l_targetwidthleft       = l_defwidthleft;
    l_targetheightleft      = l_defheightleft;
    l_targetheightbg2left   = int( l_defheightleft / 5 );


    l_leftposleft       = l_defxleft - l_halfwidthleft;
    l_rightposleft      = l_defxleft + l_halfwidthleft;
    l_upperposleft      = l_defyleft - l_halfheightleft;
    l_lowerposleft      = l_defyleft + l_halfheightleft;
    l_bg2posleft        = l_upperposleft + int( l_targetheightbg2left / 2 );
    l_inlineposleft     = l_upperposleft + l_targetheightbg2left + l_outlinesize - 1;
    l_alg               = "CENTER";
    l_shad              = "white";
    l_grey              = dividecolor( 55   , 55    , 55    );
    l_grey2             = dividecolor( 20   , 20    , 20    );
    l_blue              = dividecolor( 37   , 72    , 106   );
    l_yellow            = dividecolor( 201  , 149   , 36    );
    l_crimson           = dividecolor( 37   , 29    , 30    );
    l_white             = dividecolor( 255  , 255   , 255   );
    l_alpha             = 0.85;
    l_sort              = 0;

    
    
    l_interval      = 0;
    l_japiconsize   = level.moddef.vl_elemsizejapicon;
    l_halfjapsize   = l_japiconsize / 2;
    l_defleftx      = int( l_defxleft + l_halfwidthleft - l_halfjapsize - l_outlinesize - 2 );
    l_deflefty      = int( l_upperposleft + l_halfjapsize + 1 );

    self createelemjapanflag( );
    self moveelemjapanflag( l_interval , l_defleftx , l_deflefty );

    self.modsystem.menuui["custom_bg1"]         = self createrectangle( l_alg , l_alg , l_defxleft      , l_defyleft        , l_defwidthleft    , l_nosize      , l_grey    , l_shad , l_sort , l_alpha ); l_sort++;
    self.modsystem.menuui["custom_bg2"]         = self createrectangle( l_alg , l_alg , l_defxleft      , l_bg2posleft      , l_defwidthleft    , l_nosize      , l_grey2   , l_shad , l_sort , l_alpha ); l_sort++;
    self.modsystem.menuui["custom_inline_1"]    = self createrectangle( l_alg , l_alg , l_defxleft      , l_inlineposleft   , l_nosize          , l_outlinesize , l_crimson , l_shad , l_sort , l_alpha ); l_sort++;
    self.modsystem.menuui["custom_outline_1"]   = self createrectangle( l_alg , l_alg , l_leftposleft   , l_defyleft        , l_outlinesize     , l_nosize      , l_blue    , l_shad , l_sort , l_alpha );
    self.modsystem.menuui["custom_outline_2"]   = self createrectangle( l_alg , l_alg , l_rightposleft  , l_defyleft        , l_outlinesize     , l_nosize      , l_blue    , l_shad , l_sort , l_alpha );
    self.modsystem.menuui["custom_outline_3"]   = self createrectangle( l_alg , l_alg , l_defxleft      , l_upperposleft    , l_nosize          , l_outlinesize , l_blue    , l_shad , l_sort , l_alpha );
    self.modsystem.menuui["custom_outline_4"]   = self createrectangle( l_alg , l_alg , l_defxleft      , l_lowerposleft    , l_nosize          , l_outlinesize , l_blue    , l_shad , l_sort , l_alpha );

    l_txsize    = level.moddef.customtextlength;
    l_alpha     = 1.0;
    l_txspace   = 20;
    l_txtitley  = l_inlineposleft - l_txspace;
    l_txitemy   = int( l_inlineposleft + (l_txspace / 2) + 5 );
    l_tlen      = 16;
    l_sort      = 10;
    l_trans     = "";
    l_fsize     = 1.25;

    // en: get project name
    // ja: プロジェクト名を取得
    l_projectname = getmttext( self.curlang , "projectname" );
    // en: get operating instructions
    // ja: 操作説明文を取得
    l_description = getmttext( self.curlang , "modmenucontroldescription" , self usinggamepad( ) );

    self.modsystem.custommenutitle          = self createtextelem( "default" , l_fsize , l_alg , l_alg , l_defxleft         , ( l_txtitley - 5 )            , l_white   , l_alpha   , l_white   , l_alpha , l_sort , l_projectname , undefined );
    l_fsize     = 0.6;
    self.modsystem.custommenudescription    = self createtextelem( "default" , l_fsize , l_alg , l_alg , l_defxleft         , ( l_txtitley + 10 )           , l_white   , l_alpha   , l_white   , l_alpha , l_sort , "" , undefined );  
    l_fsize     = 0.85;
    self.modsystem.custommenucontrol        = self createtextelem( "default" , l_fsize , l_alg , l_alg , l_defxleft         , ( l_lowerposleft - 10 )       , l_white   , l_alpha   , l_white   , l_alpha , l_sort , l_description , undefined );  

    l_fsize     = 0.7;
    self.modsystem.custommenutext = [];
    for ( i = 0; i < l_txsize; i++ )
    {
        l_trans = self.modsystem.menutext[i];
        self.modsystem.custommenutext[i]   = self createtextelem( "default" , l_fsize , l_alg , l_alg , l_defxleft + 1000  , l_txitemy + ( i * l_tlen )    , l_white   , l_alpha   , l_white   , l_alpha , l_sort , l_trans , undefined );
    }
    
}



//++++++++++++++++++++++++++++++
// en : Show background for the Custom Hud Elements Mod menu
// ja : カスタム Hud elements Mod menuの背景を表示する
//++++++++++++++++++++++++++++++
showelemcustommenu( time )
{
    l_outlinesize       = level.moddef.vl_elemsizeoutline;
    l_defwidthleft      = level.moddef.vl_elemwidthcustommenu;
    l_defheightleft     = level.moddef.vl_elemheightcustommenu;

    l_targetwidthleft       = l_defwidthleft;
    l_targetheightleft      = l_defheightleft;
    l_targetheightbg2left   = int( l_defheightleft / 5 );
    
    l_japiconsize       = level.moddef.vl_elemsizejapicon;

    self.modsystem.menuui["custom_outline_1"]   scaleovertime( time , l_outlinesize                         , l_targetheightleft );
    self.modsystem.menuui["custom_outline_2"]   scaleovertime( time , l_outlinesize                         , l_targetheightleft );
    self.modsystem.menuui["custom_outline_3"]   scaleovertime( time , l_targetwidthleft                     , l_outlinesize );
    self.modsystem.menuui["custom_outline_4"]   scaleovertime( time , l_targetwidthleft                     , l_outlinesize );
    self.modsystem.menuui["custom_inline_1"]    scaleovertime( time , ( l_targetwidthleft - l_outlinesize ) , l_outlinesize );
    wait time + 0.1;
    self thread showcustomtextitems( 0.1 );
    self.modsystem.menuui["custom_bg1"]         scaleovertime( time , l_targetwidthleft                     , l_targetheightleft );
    self.modsystem.menuui["custom_bg2"]         scaleovertime( time , l_targetwidthleft                     , l_targetheightbg2left );
    self scaleelemjapanflag( time , l_japiconsize );
}




//++++++++++++++++++++++++++++++
// en : Slide in the text of the Custom Hud Elements Mod menu from outside the screen to inside the screen
// ja : カスタム Hud elements Mod menuのテキストを画面外から画面内へスライドインさせる
//++++++++++++++++++++++++++++++
showcustomtextitems( time )
{
    // en : this function ends the process if "you disconnect from the room"
    // ja : この関数は「自分が部屋から切断した」場合に処理を終了する
    self endon( "disconnect" );
    // en : this function terminates when "mod menu is closed"
    // ja : この関数は "モッドメニューが閉じられた" 場合に処理を終了する
    self endon( "closemodmenu" );
    // en : This function terminates processing if the "mod menu style has been changed."
    // ja : この関数は「モッドメニュースタイルが変更された」場合に処理を終了する
    self endon( "changedmenustyle" );

    
    l_txsize    = level.moddef.customtextlength;
    for ( i = 0; i < l_txsize; i++ )
    {
        self.modsystem.custommenutext[i] elementmovexy( ( time / 2 ) , self.modsystem.menuui["custom_bg1"].xoffset , self.modsystem.custommenutext[i].yoffset );
        wait ( time / l_txsize );
    }
    wait 0.05;
    
    l_yellow            = dividecolor( 201  , 149   , 36    );
    self.modsystem.custommenutext[self.modsystem.menulrpos] fontscalecolor( time , 1 , l_yellow , 1 );
    wait time;
}



//++++++++++++++++++++++++++++++
// en : Hide background for the Custom Hud Elements Mod menu
// ja : カスタム Hud elements Mod menuの背景を非表示にする
//++++++++++++++++++++++++++++++
hideelemcustommenu( time )
{
    l_nosize        = 0;
    l_outlinesize   = level.moddef.vl_elemsizeoutline;
    l_defwidthleft  = level.moddef.vl_elemwidthcustommenu;

    l_defheightleft     = level.moddef.vl_elemheightcustommenu;
    l_targetheightleft      = l_defheightleft;
    l_targetheightbg2left   = int( l_defheightleft / 5 );

    self.modsystem.menuui["custom_outline_1"]   scaleovertime( time , l_outlinesize , l_nosize );
    self.modsystem.menuui["custom_outline_2"]   scaleovertime( time , l_outlinesize , l_nosize );
    self.modsystem.menuui["custom_outline_3"]   scaleovertime( time , l_nosize      , l_outlinesize );
    self.modsystem.menuui["custom_outline_4"]   scaleovertime( time , l_nosize      , l_outlinesize );
    self.modsystem.menuui["custom_inline_1"]    scaleovertime( time , l_nosize      , l_outlinesize );
    wait time + 0.1;
    self.modsystem.menuui["custom_bg1"]         elementcolorchange( 0.05 , ( 0 , 0 , 0 ) , 0 );
    self.modsystem.menuui["custom_bg2"]         elementcolorchange( 0.05 , ( 0 , 0 , 0 ) , 0 );   
    self.modsystem.menuui["custom_bg1"]         scaleovertime( time , l_nosize      , l_nosize );//l_targetheightleft );
    self.modsystem.menuui["custom_bg2"]         scaleovertime( time , l_nosize      , l_nosize );//l_targetheightbg2left );
    self scaleelemjapanflag( time , l_nosize );
    self thread hideelemcustomtext( 0.05 );
}



//++++++++++++++++++++++++++++++
// en : Hide texts for the Custom Hud Elements Mod menu
// ja : カスタム Hud elements Mod menuのテキストを非表示にする
//++++++++++++++++++++++++++++++
hideelemcustomtext( time )
{
    // en : this function ends the process if "you disconnect from the room"
    // ja : この関数は「自分が部屋から切断した」場合に処理を終了する
    self endon( "disconnect" );
    // en : this function terminates when "mod menu is opened"
    // ja : この関数は "モッドメニューが開かれた" 場合に処理を終了する
    self endon( "openmodmenu" );
    // en : This function terminates processing if the "mod menu style has been changed."
    // ja : この関数は「モッドメニュースタイルが変更された」場合に処理を終了する
    self endon( "changedmenustyle" );


    l_grey                                  = dividecolor( 55   , 55    , 55    );
    l_txsize                                = level.moddef.customtextlength;
    self.modsystem.custommenutitle          fontscalecolor( time , 1 , l_grey , 0 );
    self.modsystem.custommenudescription    fontscalecolor( time , 1 , l_grey , 0 );
    self.modsystem.custommenucontrol        fontscalecolor( time , 1 , l_grey , 0 );
    
    for ( i = 0; i < l_txsize; i++ )
    {
        self.modsystem.custommenutext[i] fontscalecolor( time , 1 , l_grey , 0 );
        wait ( time / l_txsize );
    }
}



//++++++++++++++++++++++++++++++
// en : Destroy texts for the Custom Hud Elements Mod menu
// ja : カスタム Hud elements Mod menuのテキストを削除する
//++++++++++++++++++++++++++++++
destroyelemcustomtext( )
{
    l_txsize = level.moddef.customtextlength;
    for ( i = 0; i < l_txsize; i++ )
        self.modsystem.custommenutext[i] destroy( );
        
    self.modsystem.custommenutitle          destroy( );
    self.modsystem.custommenudescription    destroy( );
    self.modsystem.custommenucontrol        destroy( );
}



//++++++++++++++++++++++++++++++
// en : Destroy background for the Custom Hud Elements Mod menu
// ja : カスタム Hud elements Mod menuの背景を削除する
//++++++++++++++++++++++++++++++
destroyelemcustommenu( )
{
    self.modsystem.menuui["custom_outline_1"]   destroy( );
    self.modsystem.menuui["custom_outline_2"]   destroy( );
    self.modsystem.menuui["custom_outline_3"]   destroy( );
    self.modsystem.menuui["custom_outline_4"]   destroy( );
    self.modsystem.menuui["custom_inline_1"]    destroy( );
    self.modsystem.menuui["custom_bg1"]         destroy( );
    self.modsystem.menuui["custom_bg2"]         destroy( );
}



//++++++++++++++++++++++++++++++
// en : Open for the vertical mod menu.
// ja : 縦型 Mod Menu を開く
//++++++++++++++++++++++++++++++
openleftnoticemenu( animtime )
{
    l_interval          = 0;
    l_japiconsize       = level.moddef.vl_elemsizejapicon;
    l_defwidthleft      = level.moddef.vl_elemxjapicon;
    l_defxleft          = level.moddef.vl_elemxverticalmenu;
    l_defyleft          = level.moddef.vl_elemyverticalmenu;
    l_defleftx          = l_defxleft + ( l_defwidthleft / 2 ) - ( l_japiconsize / 2 ) + 20;
    l_deflefty          = l_defyleft - ( l_defwidthleft / 2 ) + ( l_japiconsize / 2 ) + 10;

    self createelemjapanflag( );
    self createelemleftmenu( );
    // en : move the xy axis position of the specified hud (on-screen ui) in the specified number of seconds.
    // ja : 指定したhud（画面上のui）のxy軸の位置を、指定した秒数で移動させる
    self moveelemjapanflag( l_interval , l_defleftx , l_deflefty );
    self scaleelemjapanflag( animtime , l_japiconsize );
    self showelemleftmenu( animtime );
}



//++++++++++++++++++++++++++++++
// en : close for the vertical mod menu.
// ja : 縦型 Mod Menu を閉じる
//++++++++++++++++++++++++++++++
closeleftnoticemenu( animtime )
{
    l_nosize        = 0;
    self hideelemleftmenu( animtime );
    self scaleelemjapanflag( animtime , l_nosize );
    wait animtime + 0.01;
    self destroyelemleftmenu( );
    self destroyelemjapanflag( );
    wait 0.01;
    self.modsystem.leftmenumaked = undefined;
}


//++++++++++++++++++++++++++++++
// en : Create the background for the vertical mod menu.
// ja : 縦型 Mod Menu の背景を作成する
//++++++++++++++++++++++++++++++
createelemleftmenu( )
{
    l_nosize            = 0;
    l_defxleft          = level.moddef.vl_elemxverticalmenu;
    l_defyleft          = level.moddef.vl_elemyverticalmenu;
    l_defwidthleft      = level.moddef.vl_elemwverticalmenu;
    l_halfwidthleft     = l_defwidthleft / 2;
    l_defheightleft     = level.moddef.vl_elemhverticalmenu;
    l_halfheightleft    = l_defheightleft / 2;
    l_leftposleft       = l_defxleft - l_halfwidthleft;
    l_rightposleft      = l_defxleft + l_halfwidthleft;
    l_upperposleft      = l_defyleft - l_halfheightleft;
    l_lowerposleft      = l_defyleft + l_halfheightleft;
    l_inlineposleft     = l_defyleft - 17;
    l_bg2posleft        = l_inlineposleft - 29;
    l_outlinesize       = level.moddef.vl_elemsizeoutline;
    l_alg               = "CENTER";
    l_shad              = "white";
    l_grey              = dividecolor( 55   , 55    , 55    );
    l_grey2             = dividecolor( 20   , 20    , 20    );
    l_blue              = dividecolor( 37   , 72    , 106   );
    l_yellow            = dividecolor( 201  , 149   , 36    );
    l_white             = dividecolor( 255  , 255   , 255   );
    l_alpha             = 0.85;
    l_sort              = 0;
    self.modsystem.menuui["left_bg1"]       = self createrectangle( l_alg , l_alg , l_defxleft      , l_defyleft        , l_defwidthleft    , l_nosize      , l_grey    , l_shad , l_sort , l_alpha ); l_sort++;
    self.modsystem.menuui["left_bg2"]       = self createrectangle( l_alg , l_alg , l_defxleft      , l_bg2posleft      , l_defwidthleft    , l_nosize      , l_grey2   , l_shad , l_sort , l_alpha ); l_sort++;
    self.modsystem.menuui["left_inline_1"]  = self createrectangle( l_alg , l_alg , l_defxleft      , l_inlineposleft   , l_nosize          , l_outlinesize , l_blue    , l_shad , l_sort , l_alpha ); l_sort++;
    self.modsystem.menuui["left_outline_1"] = self createrectangle( l_alg , l_alg , l_leftposleft   , l_defyleft        , l_outlinesize     , l_nosize      , l_yellow  , l_shad , l_sort , l_alpha );
    self.modsystem.menuui["left_outline_2"] = self createrectangle( l_alg , l_alg , l_rightposleft  , l_defyleft        , l_outlinesize     , l_nosize      , l_yellow  , l_shad , l_sort , l_alpha );
    self.modsystem.menuui["left_outline_3"] = self createrectangle( l_alg , l_alg , l_defxleft      , l_upperposleft    , l_nosize          , l_outlinesize , l_yellow  , l_shad , l_sort , l_alpha );
    self.modsystem.menuui["left_outline_4"] = self createrectangle( l_alg , l_alg , l_defxleft      , l_lowerposleft    , l_nosize          , l_outlinesize , l_yellow  , l_shad , l_sort , l_alpha );



    l_textwelcome           = getmttext( self.curlang , "welcometo" );
    l_textprojectname       = getmttext( self.curlang , "projectname" );
    l_textmoddedlobby       = getmttext( self.curlang , "moddedlobby" );
    
    l_textyourmenustatus    = getmttext( self.curlang , "yourmenustatus" );
    l_textverifiedlevel     = getmttext( self.curlang , getverifiedtext( self.verificationstatusindex ) );
    l_textmenudescription   = getmttext( self.curlang , "modmenuopendescription" );

    l_text1                 = l_textwelcome + l_textprojectname + l_textmoddedlobby;
    l_text2                 = l_textyourmenustatus + l_textverifiedlevel;
    l_text3                 = l_textmenudescription;
    
    l_alpha             = 0;
    l_texty             = 0;
    l_textid           = "";
    for ( i = 0; i < 7; i++ )
    {
        switch ( i )
        {
            case 0: l_texty = l_bg2posleft + 5; break;
            default: l_texty = l_inlineposleft + ( 13 * i ); break;
        }
        switch ( i )
        {
            case 0: l_textid = l_text1; break;
            case 1: l_textid = l_text2; break;
            case 2: l_textid = l_text3; break;
            case 3: l_textid = "----------"; break;
            case 4: l_textid = "߷ ^3D^7iscord ^3ID ^7: ^2hinatapoko ^7߷"; break;
            case 5: l_textid = "߶ ^1Y^7ou^1T^7ube : ^5H^7iN^1A^7tyu ^3S^7tudio ߶"; break;
            case 6: l_textid = "߫ ^4T^7witter : ^2@KonataGIF ^7߯ ^6G^7it^6H^7ub : ^2ProjectHiNAtyu ^7߫"; break;
        }
        self.modsystem.leftnoticetext[i] = self createtextelem( "default" , 0.1 , l_alg , l_alg , l_defxleft , l_texty , l_white , l_alpha , l_white , l_alpha , l_sort , l_textid , undefined ); l_sort++;
    
    }

    self.modsystem.leftmenumaked = true;
}



//++++++++++++++++++++++++++++++
// en : Display the background of the vertical mod menu.
// ja : 縦型 Mod Menu の背景を表示する
//++++++++++++++++++++++++++++++
showelemleftmenu( time )
{
    l_outlinesize           = level.moddef.vl_elemsizeoutline;
    l_defwidthleft          = level.moddef.vl_elemwverticalmenu;
    l_defheightleft         = level.moddef.vl_elemhverticalmenu;
    l_targetwidthleft       = l_defwidthleft;
    l_targetheightleft      = l_defheightleft;
    l_targetheightbg2left   = l_targetheightleft - 94;

    self.modsystem.menuui["left_bg1"]       scaleovertime( time , l_targetwidthleft           , l_targetheightleft );
    self.modsystem.menuui["left_bg2"]       scaleovertime( time , l_targetwidthleft           , l_targetheightbg2left );
    self.modsystem.menuui["left_outline_1"] scaleovertime( time , l_outlinesize               , l_targetheightleft );
    self.modsystem.menuui["left_outline_2"] scaleovertime( time , l_outlinesize               , l_targetheightleft );
    self.modsystem.menuui["left_outline_3"] scaleovertime( time , l_targetwidthleft           , l_outlinesize );
    self.modsystem.menuui["left_outline_4"] scaleovertime( time , l_targetwidthleft           , l_outlinesize );
    self.modsystem.menuui["left_inline_1"]  scaleovertime( time , ( l_targetwidthleft - 2 )   , l_outlinesize );
    
    l_white = dividecolor( 255  , 255   , 255   );
    for ( i = 0; i < 7; i++ )
        self.modsystem.leftnoticetext[i] fontscalecolor( time , 0.9 , l_white , 1 );
}



//++++++++++++++++++++++++++++++
// en : Scale out the background of the vertical mod menu.
// ja : 縦型 Mod Menu の背景をスケールアウトする
//++++++++++++++++++++++++++++++
hideelemleftmenu( time )
{
    l_nosize        = 0;
    l_outlinesize   = level.moddef.vl_elemsizeoutline;
    l_defwidthleft  = level.moddef.vl_elemwverticalmenu;
    l_white         = dividecolor( 255  , 255   , 255   );

    self.modsystem.menuui["left_bg1"]           scaleovertime( time , l_defwidthleft  , l_nosize );
    self.modsystem.menuui["left_bg2"]           scaleovertime( time , l_defwidthleft  , l_nosize );
    self.modsystem.menuui["left_outline_1"]     scaleovertime( time , l_outlinesize   , l_nosize );
    self.modsystem.menuui["left_outline_2"]     scaleovertime( time , l_outlinesize   , l_nosize );
    self.modsystem.menuui["left_outline_3"]     scaleovertime( time , l_nosize        , l_outlinesize );
    self.modsystem.menuui["left_outline_4"]     scaleovertime( time , l_nosize        , l_outlinesize );
    self.modsystem.menuui["left_inline_1"]      scaleovertime( time , l_nosize        , l_outlinesize );

    for ( i = 0; i < 7; i++ )
        self.modsystem.leftnoticetext[i] fontscalecolor( time , 0.1 , l_white , 0 );
}



//++++++++++++++++++++++++++++++
// en : Destroy the background of the vertical mod menu.
// ja : 縦型 Mod Menu の背景を削除する
//++++++++++++++++++++++++++++++
destroyelemleftmenu( )
{
    self.modsystem.menuui["left_bg1"]           destroy( );
    self.modsystem.menuui["left_bg2"]           destroy( );
    self.modsystem.menuui["left_outline_1"]     destroy( );
    self.modsystem.menuui["left_outline_2"]     destroy( );
    self.modsystem.menuui["left_outline_3"]     destroy( );
    self.modsystem.menuui["left_outline_4"]     destroy( );
    self.modsystem.menuui["left_inline_1"]      destroy( );

    for ( i = 0; i < 7; i++ )
        self.modsystem.leftnoticetext[i] destroy( );
}



//++++++++++++++++++++++++++++++
// en : Create the background for the horizontal mod menu.
// ja : 日本国旗を作成する
//++++++++++++++++++++++++++++++
createelemjapanflag( )
{
    l_nosize        = 0;
    l_defx          = 0;
    l_defy          = level.moddef.vl_elemyhorizontalmenu;
    if ( ( level.mapname == "mp_escape4" ) || ( level.mapname == "mp_sm_island_1" ) )
    {
        l_defy = level.moddef.vl_elemyfixhorizontalmenu;
    }
    l_defheight     = level.moddef.vl_elemyjapicon;
    l_halfheight    = l_defheight / 2;
    l_upperpos      = l_defy    - l_halfheight;
    l_headerpos     = l_upperpos + ( l_halfheight / 3 );

    l_red           = dividecolor( 188  , 0     , 45    );
    l_white         = dividecolor( 255  , 255   , 255   );
    l_alg           = "CENTER";
    l_shad          = "white";
    l_shad2         = "hud_realism_head_revive";
    l_alpha         = 1;
    l_sort          = 10;
    self.modsystem.menuui["japw"]       = self createrectangle( l_alg , l_alg , l_defx          , l_headerpos           , l_nosize , l_nosize , l_white   , l_shad  , l_sort , l_alpha ); l_sort++;
    self.modsystem.menuui["japr"]       = self createrectangle( l_alg , l_alg , l_defx          , l_headerpos           , l_nosize , l_nosize , l_red     , l_shad2 , l_sort , l_alpha ); l_sort++;
    self.modsystem.menuui["japrfix1"]   = self createrectangle( l_alg , l_alg , l_defx          , ( l_headerpos - 1 )   , l_nosize , l_nosize , l_red     , l_shad  , l_sort , l_alpha ); l_sort++;
    self.modsystem.menuui["japrfix2"]   = self createrectangle( l_alg , l_alg , ( l_defx + 1 )  , ( l_headerpos - 2 )   , l_nosize , l_nosize , l_red     , l_shad  , l_sort , l_alpha ); l_sort++;
    self.modsystem.menuui["japwfix"]    = self createrectangle( l_alg , l_alg , l_defx          , ( l_headerpos + 7 )   , l_nosize , l_nosize , l_white   , l_shad  , l_sort , l_alpha );
}



//++++++++++++++++++++++++++++++
// en : Scale out the Japanese national flag.
// ja : 日本国旗をスケールアウトする
//++++++++++++++++++++++++++++++
scaleelemjapanflag( time , wh )
{
    l_japw      = ( 0 < wh ) ? ( wh + 6 )   : 0;
    l_japr      = ( 0 < wh ) ? ( wh + 5 )   : 0;
    l_japrfix   = ( 0 < wh ) ? ( wh - 17 )  : 0;
    l_japwfixw  = ( 0 < wh ) ? ( wh - 10 )  : 0;
    l_japwfixh  = ( 0 < wh ) ? ( wh - 22 )  : 0;

    self.modsystem.menuui["japw"]       scaleovertime( time , l_japw        , wh );
    self.modsystem.menuui["japr"]       scaleovertime( time , l_japr        , l_japr );
    self.modsystem.menuui["japrfix1"]   scaleovertime( time , l_japrfix     , l_japrfix );
    self.modsystem.menuui["japrfix2"]   scaleovertime( time , l_japrfix     , l_japrfix );
    self.modsystem.menuui["japwfix"]    scaleovertime( time , l_japwfixw    , l_japwfixh );
}



//++++++++++++++++++++++++++++++
// en : Move the Japanese national flag to the specified coordinates.
// ja : 日本国旗を指定座標に移動させる
//++++++++++++++++++++++++++++++
moveelemjapanflag( time , x , y )
{
    self.modsystem.menuui["japw"]       elementmovexy( time , x         , y );
    self.modsystem.menuui["japr"]       elementmovexy( time , x         , y );
    self.modsystem.menuui["japrfix1"]   elementmovexy( time , x         , ( y - 1 ) );
    self.modsystem.menuui["japrfix2"]   elementmovexy( time , ( x + 1 ) , ( y - 2 ) );
    self.modsystem.menuui["japwfix"]    elementmovexy( time , x         , ( y + 7 ) );
}



//++++++++++++++++++++++++++++++
// en : Destroy the Japanese national flag.
// ja : 日本国旗を削除する
//++++++++++++++++++++++++++++++
destroyelemjapanflag( )
{
    self.modsystem.menuui["japw"]               destroy( );
    self.modsystem.menuui["japr"]               destroy( );
    self.modsystem.menuui["japrfix1"]           destroy( );
    self.modsystem.menuui["japrfix2"]           destroy( );
    self.modsystem.menuui["japwfix"]            destroy( );
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : Mod Menu basic operation function
// ja : Mod Menu 基本操作関数
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : open (display) the mod menu
// ja : モッドメニューを開く（表示する）
//++++++++++++++++++++++++++++++
modmenuopen( opentime )
{
    // en: suppose the mod menu is opened
    // ja: モッドメニューが開かれたとする
    self.modsystem.menuactive = true;
    
    // en: issue a "openmodmenu" event to yourself (this will stop the menu text display update process)
    // ja: 自分に対して "openmodmenu" イベントを発行する（これでメニューテキストの表示更新処理が止まる）
    self notify( "openmodmenu" );

    // en : allow player actions
    // ja : プレイヤーの行動を許可する
    self allowplayermovements( );
    // en: play se only for yourself
    // ja: seを自分だけ再生する
    self playlocalsound( "mp_killstreak_transition_whoosh" );

    
    // en : Define variables for creating the mod menu background UI.
    // ja : モッドメニューの背景ui作成用の変数を定義
    l_japiconsize       = level.moddef.vl_elemsizejapicon;
    l_animtime          = opentime;
    l_interval          = 0;
    l_defxleft          = level.moddef.vl_elemxverticalmenu;
    l_defyleft          = level.moddef.vl_elemyverticalmenu;
    l_defwidthleft      = level.moddef.vl_elemxjapicon;
    l_defleftx          = l_defxleft + ( l_defwidthleft / 2 ) - ( l_japiconsize / 2 ) + 20;
    l_deflefty          = l_defyleft - ( l_defwidthleft / 2 ) + ( l_japiconsize / 2 ) + 10;
    l_changemenustyle   = "changemenustyle";
    l_iprintlnmenu      = "iprintlnmenu";


    // en: create background ui for mod menu
    // ja: モッドメニューの背景uiを作成する
    
    self createelemcustommenu( );
    self showelemcustommenu( opentime );

    // en: wait 0.3 seconds
    // ja: 0.3秒待機する
    wait l_animtime + 0.01;
    
    // en: when opening the mod menu for the first time, force the language menu to open
    // ja: モッドメニューを初めて開く場合、言語メニューを開かせる
    if ( self.modsystem.menufirstopen == true )
    {
        ln_en = level.moddef.ln_en;
        ly_languages = level.moddef.ly_languages;

        // en: current mod menu open page
        // ja: 現在のモッドメニューの開いているページ
        self.modsystem.menulayercurrent = ly_languages;
        // en: index of selected item in current mod menu
        // ja: 現在のモッドメニューの選択している項目インデックス
        self.modsystem.menuoptioncurrent = ln_en;
        // en: the depth of the current mod menu's open hierarchy
        // ja: 現在のモッドメニューの開いている階層の深さ
        self.modsystem.menulayerdepth = 1;
        // en: the mod menu page that was opened just before
        // ja: 直前に開いていたモッドメニューのページ
        self.modsystem.menulayerprevious[0] = 0;
        // en: item index of the mod menu that was most recently selected
        // ja: 直前に選択していたモッドメニューの項目インデックス
        self.modsystem.menuoptionprevious[0] = ( ly_languages - 1 );
        // en: Horizontal scroll position of the previously selected mod menu
        // ja: 直前に選択していたモッドメニューの横スクロール位置
        self.modsystem.menulrposprevious[0] = ( ly_languages - 1 );
    }

    // en: update the text displayed in the mod menu
    // ja: モッドメニューの表示するテキストを更新する
    self modmenutextupdate( );
    
    // en : enables/disables the feature "doheart" for the all players.
    // ja : 全プレイヤーに対して、機能 "doheart" の有効/無効を切り替える
    if ( !isdefined( level.lvlstat["doheart"] ) )
        self thread onfdoheart( );
}



//++++++++++++++++++++++++++++++
// en : scrolls the selected item up in the displayed mod menu
// ja : 表示中のモッドメニューの、選択中の項目を上にスクロールする
//++++++++++++++++++++++++++++++
modmenuscroll( path , scrolltime )
{
    l_iprintlnmenu  = "iprintlnmenu";
    l_up            = 0;
    l_maxindex      = 0;
    l_maxtextsize   = ( !isdefined( self.optstat[l_iprintlnmenu] ) ? level.moddef.customtextlength : level.moddef.maxhrtextsize ) - 1;
    
    // en: if the currently open menu level is not the player refer menu, get the maximum index for each authority in each menu hierarchy
    // ja: 今開いているメニュー階層がプレイヤー参照メニューではない場合、各メニュー階層における、権限毎の最大インデックスを取得する
    l_maxindex = getlayermaxindex( self.modsystem.menulayercurrent , self.verificationstatusindex );


    if ( path == l_up )
    {
        // en: set the horizontal scroll position of the mod menu to the top
        // ja: モッドメニューの横スクロール位置を左にずらす
        if ( 0 < self.modsystem.menulrpos )
            self.modsystem.menulrpos--;

        // en: if the currently selected item index is at the top, select the bottom item
        // ja: 現在選択中の項目インデックスが一番上の場合、一番下の項目を選択する
        if ( self.modsystem.menuoptioncurrent <= 0 )
        {
            self.modsystem.menuoptioncurrent = l_maxindex;
            self.modsystem.menulrpos = ( l_maxtextsize < l_maxindex ) ? l_maxtextsize : l_maxindex;
        }
        // en: if the currently selected item index is not the top one, move the currently selected item index in the mod menu one position forward (up)
        // ja: 現在選択中の項目インデックスが一番上ではない場合、モッドメニューの選択中項目インデックスを1つ前（上）にずらす
        else
            self.modsystem.menuoptioncurrent--;
    }
    else
    {
        // en: set the horizontal scroll position of the mod menu to the top
        // ja: モッドメニューの横スクロール位置を右にずらす
        if ( self.modsystem.menulrpos < l_maxtextsize )
            self.modsystem.menulrpos++;

        // en: if the currently selected item index exceeds the maximum index, select the top item
        // ja: 現在選択中の項目インデックスが、最大インデックスを超えている場合、一番上の項目を選択する
        if ( l_maxindex <= self.modsystem.menuoptioncurrent )
        {
            self.modsystem.menuoptioncurrent = 0;
            self.modsystem.menulrpos = 0;
        }
        // en: if the currently selected item index is less than the maximum index, shift the selected item index in the mod menu one position later (down)
        // ja: 現在選択中の項目インデックスが、最大インデックス未満の場合、モッドメニューの選択中項目インデックスを1つ後（下）にずらす
        else
            self.modsystem.menuoptioncurrent++;
    }
    
    // en: play se only for yourself
    // ja: seを自分だけ再生する
    self playlocalsound( "iw8_ks_ac130_weaponswitch" );

    // en: update the text displayed in the mod menu
    // ja: モッドメニューの表示するテキストを更新する
    self modmenutextupdate( );

    // en: wait 0.15 seconds
    // ja: 0.15秒待機する
    wait scrolltime;
}



//++++++++++++++++++++++++++++++
// en : execute the function registered in the currently selected item in a subthread
// ja : 現在選択中の項目に登録されている関数をサブスレッドで実行する
//++++++++++++++++++++++++++++++
modmenudecideoption( )
{
    mod_enabled         = 1;
    mod_notonf          = 2;
    mod_reflesh         = 3;
    mod_fastreflesh     = 4;
    ar_submenu          = 10;
    l_iprintlnmenu      = "iprintlnmenu";

    // en: In the case of a Mod Menu using Custom Hud Text
    // ja: Custom Hud Textを使用したMod Menuの場合
    if ( !isdefined( self.optstat[l_iprintlnmenu] ) )
    {
        l_texttime          = 0.05;
        l_textsizeunselect  = 0.8;
        l_textsizeselect    = 1.25;
        l_white             = dividecolor( 255  , 255   , 255   );
        l_blue1             = dividecolor( 16   , 95    , 222    );
        l_blue2             = dividecolor( 73   , 152   , 227    );
        self.modsystem.custommenutext[self.modsystem.menulrpos] fontscalecolor( l_texttime , l_textsizeunselect , l_blue1 , 1 );
        wait l_texttime;
        self.modsystem.custommenutext[self.modsystem.menulrpos] fontscalecolor( l_texttime , l_textsizeselect , l_blue2 , 1 );
        wait l_texttime;
    }

    l_update = level.modmenudata[self.modsystem.menulayercurrent].item[self.modsystem.menuoptioncurrent].update;

    self thread [[ self.modsystem.menufunction ]]( );
    
    // en: play se only for yourself
    // ja: seを自分だけ再生する
    self playlocalsound( "weap_cluster_target_beep" );

    // en: when opening a submenu or for items that do not require text updates, update the text during other processing.
    // ja: サブメニューを開いた時の場合や、文字更新の必要ない項目は、他処理時に文字更新を行う
    if ( !isdefined( l_update ) ||
        ( l_update == mod_notonf ) ||
        ( l_update == ar_submenu ) )
    {
        wait 0.15;
    }
    // en: update the text displayed in the mod menu
    // ja: モッドメニューの表示するテキストを更新する
    else if ( ( l_update == mod_enabled ) ||
            ( l_update == mod_reflesh ) )
    {
        wait 0.15;
        self modmenutextupdate( );
    }
    // en: for items that you want to make ultra-high-speed decisions, update the text instantly.
    // ja: 超高速で項目決定を行いたい項目は、瞬時にテキスト更新を行う
    else if ( l_update == mod_fastreflesh )
    {
        wait 0.001;
        self modmenutextupdate( );
    }
}



//++++++++++++++++++++++++++++++
// en : open submenu (move down the mod menu level)
// ja : サブメニューを開く（モッドメニューの階層を下げる）
//++++++++++++++++++++++++++++++
modmenuopensubmenu( )
{
    value_root = 0;
    ly_playersmod   = level.moddef.ly_playersmod;

    // en: remember the currently open menu hierarchy and item index
    // ja: 今開いているメニュー階層と項目インデックスを記憶する
    self.modsystem.menulayerprevious[self.modsystem.menulayerdepth]     = self.modsystem.menulayercurrent;
    self.modsystem.menuoptionprevious[self.modsystem.menulayerdepth]    = self.modsystem.menuoptioncurrent;
    self.modsystem.menulrposprevious[self.modsystem.menulayerdepth]     = self.modsystem.menulrpos;

    self.modsystem.menulayercurrent = level.modmenudata[self.modsystem.menulayercurrent].item[self.modsystem.menuoptioncurrent ].jumppage;

    // en: move the selected item index to the top
    // ja: 選択中の項目インデックスを一番上にする
    self.modsystem.menuoptioncurrent = value_root;

    // en: set the horizontal scroll position of the mod menu to the top
    // ja: モッドメニューの横スクロール位置を先頭にする
    self.modsystem.menulrpos = value_root;

    // en: reduce the depth of the mod menu
    // ja: モッドメニューの階層の深さを下げる
    self.modsystem.menulayerdepth++;

    //self.modsystem.textnotify settext( &"MP/BR_RESPAWN_DROP_BODY" );
    
    // en: update the text displayed in the mod menu
    // ja: モッドメニューの表示するテキストを更新する
    self modmenutextupdate( );
}



//++++++++++++++++++++++++++++++
// en : restore menu hierarchy (close mod menu if root is open)
// ja : メニュー階層を戻す（ルートを開いている場合は、モッドメニューを閉じる）
//++++++++++++++++++++++++++++++
modmenubacklayer( movetime )
{
    ly_root = 0;

    // en: if the depth of the menu hierarchy is below the root
    // ja: メニュー階層の深さがルートより下にある場合
    if ( ly_root < self.modsystem.menulayerdepth )
    {
        //self.modsystem.textnotify settext( &"MP_BR_INGAME/PLEA_FOR_HELP" );

        // en: increase the depth of the menu hierarchy
        // ja: メニュー階層の深さを上げる
        self.modsystem.menulayerdepth--;

        // en: set the menu hierarchy and item index that were opened immediately before
        // ja: 直前に開いていたメニュー階層と項目インデックスにする
        self.modsystem.menulayercurrent     = self.modsystem.menulayerprevious[self.modsystem.menulayerdepth];
        self.modsystem.menuoptioncurrent    = self.modsystem.menuoptionprevious[self.modsystem.menulayerdepth];
        self.modsystem.menulrpos            = self.modsystem.menulrposprevious[self.modsystem.menulayerdepth];
        
        // en: play se only for yourself
        // ja: seを自分だけ再生する
        self playlocalsound( "recon_drone_spotted_plr" );
        
        // en: update the text displayed in the mod menu
        // ja: モッドメニューの表示するテキストを更新する
        self modmenutextupdate( );
        
        // en: wait 0.3 seconds
        // ja: 0.3秒待機する
        wait movetime;
    }
    else
        // en: close (hide) the mod menu
        // ja: モッドメニューを閉じる（非表示にする）
        self modmenuclose( movetime );
}



//++++++++++++++++++++++++++++++
// en : close (hide) the mod menu
// ja : モッドメニューを閉じる（非表示にする）
//++++++++++++++++++++++++++++++
modmenuclose( movetime )
{
    // en: suppose the mod menu is closed
    // ja: モッドメニューが閉じられたとする
    self.modsystem.menuactive = false;
    
    // en: play se only for yourself
    // ja: seを自分だけ再生する
    self playlocalsound( "recondrone_tag" );

    // en: issue a "closemodmenu" event to yourself (this will stop the menu text display update process)
    // ja: 自分に対して「closemodmenu」イベントを発行する（これでメニューテキストの表示更新処理が止まる）
    self notify( "closemodmenu" );
    
    // en: waits for only 1 frame as it waits for the update process to finish.
    // ja: 更新処理の終了待ちの為 1フレーム のみ待機する
    wait 0.001;
    
    l_animtime      = movetime;
    l_nosize        = 0;
    l_verticalmenu  = "changemenustyle";
    l_iprintlnmenu  = "iprintlnmenu";

    // en : changes the height and width of the specified hud (on-screen ui) in the specified number of seconds.
    // ja : 指定したhud（画面上のui）の縦横幅を、指定した秒数でサイズ変更する

    self hideelemcustommenu( l_animtime );
        
    // en: wait 0.3 seconds
    // ja: 0.3秒待機する
    wait l_animtime + 0.01;


    // en: delete the created mod menu design ui
    // ja: 作成したモッドメニューのデザインuiを削除する
    self destroyelemcustommenu( );
    self destroyelemcustomtext( );
    self destroyelemjapanflag( );
    
    wait 0.001;
    
    // en: if you are opening the mod menu for the first time, the initialization process will end.
    // ja: モッドメニューを初めて開いていた場合、初期化処理は終了する
    if ( self.modsystem.menufirstopen )
        self.modsystem.menufirstopen = false;
        
    
    // en : enables/disables the feature "doheart" for the all players.
    // ja : 全プレイヤーに対して、機能 "doheart" の有効/無効を切り替える
    if ( isdefined( level.lvlstat["doheart"] ) )
        self thread onfdoheart( );
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : Mod Menu text update function
// ja : Mod Menu 文字更新処理
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : update mod menu text
// ja : モッドメニューのテキストを更新する
//++++++++++++++++++++++++++++++
modmenutextupdate( )
{
    l_iprintlnmenu  = "iprintlnmenu";
    ly_root         = 0;
    l_maxtextsize   = ( !isdefined( self.optstat[l_iprintlnmenu] ) ? level.moddef.customtextlength : level.moddef.maxhrtextsize );
    l_scrollpos     = self.modsystem.menuoptioncurrent - self.modsystem.menulrpos;
    l_optindex      = 0;

        
    // en: get the maximum index of the currently open mod menu hierarchy
    // ja: 現在開いているモッドメニューの階層の最大インデックスを取得
    l_maxindex = getlayermaxindex( self.modsystem.menulayercurrent , self.verificationstatusindex );

    // en: if the current menu hierarchy is the root, if there is player information referenced in the player menu, it will be discarded.
    // ja: 現在のメニュー階層がルートの場合、プレイヤーメニューで参照していたプレイヤー情報があれば、破棄する
    if ( ( self.modsystem.menulayercurrent == ly_root ) && isdefined( self.modsystem.menuplayer ) )
        self.modsystem.menuplayer = undefined;

    // en: update the currently selected mod menu item function
    // ja: 現在選択中のモッドメニューの項目関数を更新
    self.modsystem.menufunction = getoptionfunction( self.modsystem.menulayercurrent , self.modsystem.menuoptioncurrent );

    // en: loop for the number of text elements of the second and subsequent modmenu items
    // ja: ２番目以降のmodmenu項目のテキストの要素数分ループ
    for ( textnum = 0; textnum < l_maxtextsize; textnum++ )
    {
        l_optindex = l_scrollpos + textnum;

        // en: if "top selected modmenu item + loop element number" does not exceed the maximum index
        // ja: 「一番上の選択中のmodmenu項目 + ループ要素の数値」が、最大インデックスを超えていなければ
        if ( l_optindex <= l_maxindex )
        {
            // en: get the text of that item
            // ja: その項目の文章を取得する
            self.modsystem.menutext[textnum] = getmodmenutext( self.curlang , self.modsystem.menulayercurrent , l_optindex );

            // en: get the running status of that item
            // ja: その項目の実行状態を取得する
            self.modsystem.menutext[textnum] += self getoptionstatus( self.curlang , self.modsystem.menulayercurrent , l_optindex , undefined );
        }
        // en: if the maximum index is exceeded, display empty text
        // ja: 最大インデックスを超えていれば、空文を表示する
        else
        {
            self.modsystem.menutext[textnum] = "";
            self.modsystem.menutextid[textnum] = " ";
            self.modsystem.menutextstatus[textnum] = " ";
        }
    }
    
    // en: issue a "refreshmodmenu" event to yourself (this will stop the menu text display update process)
    // ja: 自分に対して「refreshmodmenu」イベントを発行する（これでメニューテキストの表示更新処理が止まる）
    self notify( "refreshmodmenu" );

    // en: waits for only 1 frame as it waits for the update process to finish.
    // ja: 更新処理の終了待ちの為 1フレーム のみ待機する
    wait 0.01;
    
    // en: execute the update process of the character display of the mod menu in a subthread
    // ja: モッドメニューの文字表示の更新処理をサブスレッドで実行する
    self thread modmenutextdisplay( );
}



//++++++++++++++++++++++++++++++
// en : processing to display mod menu text
// ja : モッドメニューのテキストを表示する処理
//++++++++++++++++++++++++++++++
modmenutextdisplay( )
{
    ly_root             = 0;
    l_txsize            = level.moddef.customtextlength;
    l_texttime          = 0.1;
    l_textsizeunselect  = 0.7;
    l_textsizeselect    = 1.0;
    l_white             = dividecolor( 255  , 255   , 255   );
    l_yellow            = dividecolor( 201  , 149   , 36    );
    l_curlayerinfo      = "";

    // en: get project name
    // ja: プロジェクト名を取得
    l_projectname = getmttext( self.curlang , "projectname" );
    // en: get operating instructions
    // ja: 操作説明文を取得
    l_description = getmttext( self.curlang , "modmenucontroldescription" , self usinggamepad( ) );

    // en: Gets the current mod menu's open level.
    // ja: 現在のモッドメニューの開いている階層の深さを取得
    l_curdepth = self.modsystem.menulayerdepth;
    l_befdepth = l_curdepth - 1;
    
    // en: get the maximum index of the currently open mod menu hierarchy
    // ja: 現在開いているモッドメニューの階層の最大インデックスを取得
    l_maxindex = getlayermaxindex( self.modsystem.menulayercurrent , self.verificationstatusindex );
    // en: get the currently selected index in character format
    // ja: 現在選択中のインデックスを文字形式で取得
    l_index = "^3 :[" + ( self.modsystem.menuoptioncurrent + 1 ) + "/" + ( l_maxindex + 1 ) + "]";

    // en: if the current menu hierarchy is other than the root
    // ja: 現在のメニュー階層がルート以外の場合
    if ( ly_root < self.modsystem.menulayercurrent )
    {
        // en: if the current menu hierarchy is not the player menu, display “project name/current submenu name”
        // ja: 現在のメニュー階層がプレイヤーメニューではない場合、「プロジェクト名 / 現在のサブメニュー名」を表示する
        l_curlayerinfo = getmodmenutext( self.curlang , self.modsystem.menulayerprevious[l_befdepth] , self.modsystem.menuoptionprevious[l_befdepth] ) + l_index;
    }
    else
    {
        l_curlayerinfo = l_index;
    }
    
    self.modsystem.custommenutitle          settext( l_projectname );
    self.modsystem.custommenudescription    settext( l_curlayerinfo );
    self.modsystem.custommenucontrol        settext( l_description );
    
    // en: Loop for the number of custom texts
    // ja: カスタムテキストの個数分ループ
    for ( i = 0; i < l_txsize; i++ )
    {
        self.modsystem.custommenutext[i] settext( self.modsystem.menutext[i] );

        // en: If the number of text elements matches the menu item scroll position
        // ja: このテキスト要素数がメニュー項目スクロール位置と一致する場合
        if ( i == self.modsystem.menulrpos )
            self.modsystem.custommenutext[i] fontscalecolor( l_texttime , l_textsizeselect , l_yellow , 1 );
        // en: If the number of text elements unmatches the menu item scroll position
        // ja: このテキスト要素数がメニュー項目スクロール位置と一致しない場合
        else
        {
            // en: If the number of items on the currently open page is less than the maximum number of texts, the overflowing texts will be made transparent.
            // ja: 現在開いているページの項目数がテキスト最大数よりも少ない場合、あふれたテキストは透明にする
            if ( l_maxindex < i )
                self.modsystem.custommenutext[i] fontscalecolor( 0 , l_textsizeunselect , l_white , 0 );
            else
                self.modsystem.custommenutext[i] fontscalecolor( l_texttime , l_textsizeunselect , l_white , 1 );
        }
    }
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : Mod Menu animation function
// ja : Mod Menu アニメーション処理
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : color animation of mod menu background color
// ja : モッドメニューの背景色のカラーアニメーション
//++++++++++++++++++++++++++++++
modmenubackgroundcoloranimation( )
{
    // en : this function ends the process if "you disconnect from the room"
    // ja : この関数は「自分が部屋から切断した」場合に処理を終了する
    self endon( "disconnect" );
    // en : this function ends processing if "you die"
    // ja : この関数は「自分が死んだ」場合に処理を終了する
    self endon( "death" );
    // en : this function ends processing if "you die"
    // ja : この関数は「モッドメニューが閉じられた」場合に処理を終了する
    //self endon( "closemodmenu" );
    // en : This function terminates processing if the "mod menu style has been changed."
    // ja : この関数は「モッドメニュースタイルが変更された」場合に処理を終了する
    //self endon( "changedmenustyle" );
    
    l_changemenustyle   = "changemenustyle";
    l_iprintlnmenu      = "iprintlnmenu";
    l_blue1             = dividecolor( 37   , 72    , 106   );
    l_blue2             = dividecolor( 40   , 116   , 209   );
    l_crimson1          = dividecolor( 37   , 29    , 30    );
    l_crimson2          = dividecolor( 120  , 40    , 31    );
    l_yellow1           = dividecolor( 201  , 149   , 36    );
    l_yellow2           = dividecolor( 133  , 87    , 19    );
    l_animtime          = self.modsystem.menucoloranimtime;
    l_interval          = self.modsystem.menucoloraniminterval;
    l_leftoutline       = l_yellow2;
    l_leftinline        = l_blue2;

    // en: infinite loop only while mod menu is open
    // ja: モッドメニューが開かれている間だけ無限ループ
    while ( true )
    {
        // en: if mod menu background animation is enabled
        // ja: モッドメニューの背景アニメーションが有効の場合
        if ( isdefined( self.optstat["switchbackgroundanimation"] ) )
        {
            // en : changes the color of the specified hud (on-screen ui) for the specified number of seconds.
            // ja : 指定したhud（画面上のui）の色を、指定した秒数で変色させる

            // en : In the case of a vertical mod menu.
            // ja : 縦型 Mod Menu の場合
            if ( isdefined( self.modsystem.leftmenumaked ) )
            {
                l_leftoutline   = l_blue2;
                l_leftinline    = l_crimson2;
                self.modsystem.menuui["left_outline_1"]         elementcolorchange( l_animtime , l_leftoutline );
                self.modsystem.menuui["left_outline_2"]         elementcolorchange( l_animtime , l_leftoutline );
                self.modsystem.menuui["left_outline_3"]         elementcolorchange( l_animtime , l_leftoutline );
                self.modsystem.menuui["left_outline_4"]         elementcolorchange( l_animtime , l_leftoutline );
                self.modsystem.menuui["left_inline_1"]          elementcolorchange( l_animtime , l_leftinline );
            }

            // en: In the case of a Mod Menu using Custom Hud Text
            // ja: Custom Hud Textを使用したMod Menuの場合
            if ( self.modsystem.menuactive )
            {
                self.modsystem.menuui["custom_outline_1"]   elementcolorchange( l_animtime , l_blue2 );
                self.modsystem.menuui["custom_outline_2"]   elementcolorchange( l_animtime , l_blue2 );
                self.modsystem.menuui["custom_outline_3"]   elementcolorchange( l_animtime , l_blue2 );
                self.modsystem.menuui["custom_outline_4"]   elementcolorchange( l_animtime , l_blue2 );
                self.modsystem.menuui["custom_inline_1"]    elementcolorchange( l_animtime , l_crimson2 );
            }
            wait l_animtime;
            wait l_interval;
        
            // en : In the case of a vertical mod menu.
            // ja : 縦型 Mod Menu の場合
            if ( isdefined( self.modsystem.leftmenumaked ) )
            {
                l_leftoutline   = l_blue1;
                l_leftinline    = l_crimson1;
                self.modsystem.menuui["left_outline_1"]         elementcolorchange( l_animtime , l_leftoutline );
                self.modsystem.menuui["left_outline_2"]         elementcolorchange( l_animtime , l_leftoutline );
                self.modsystem.menuui["left_outline_3"]         elementcolorchange( l_animtime , l_leftoutline );
                self.modsystem.menuui["left_outline_4"]         elementcolorchange( l_animtime , l_leftoutline );
                self.modsystem.menuui["left_inline_1"]          elementcolorchange( l_animtime , l_leftinline );
            }
            // en: In the case of a Mod Menu using Custom Hud Text
            // ja: Custom Hud Textを使用したMod Menuの場合
            if ( self.modsystem.menuactive )
            {
                self.modsystem.menuui["custom_outline_1"]   elementcolorchange( l_animtime , l_blue1 );
                self.modsystem.menuui["custom_outline_2"]   elementcolorchange( l_animtime , l_blue1 );
                self.modsystem.menuui["custom_outline_3"]   elementcolorchange( l_animtime , l_blue1 );
                self.modsystem.menuui["custom_outline_4"]   elementcolorchange( l_animtime , l_blue1 );
                self.modsystem.menuui["custom_inline_1"]    elementcolorchange( l_animtime , l_crimson1 );
            }

            wait l_animtime;
            wait l_interval;
        }
        wait 0.001;
    }
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : Mods parameter handling
// ja : Mods パラメーター処理
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : display text and execute functions according to the on/off state of specified variables.
// ja : 指定の変数のオンオフ状態に合わせて、文章の表示と機能の実行を行う
//++++++++++++++++++++++++++++++
switchonfselffunction( optname , optfunc , message , optarg1 , optarg2 , optarg3 , optarg4 , optarg5 , optarg6  , optarg7 , weaponid , inprojectile , onlygroup , attachmentid , camoid , camogroup , dualmode , lvlcheck )
{
    // en : since the process of deleting the previously created case is in progress, the process is interrupted as it cannot be recreated.
    // ja : 前回作った筐体の削除処理が実行中の為、再作成できないとして処理を中断する
    if ( isdefined( self.optstat[optname + "deleting"] ) || ( isdefined( lvlcheck ) && isdefined( level.lvlstat[lvlcheck] ) ) )
    {
        // en: display the specified text in the center of the screen
        // ja: 画面中央に指定の文章を表示する
        self showcentermessage( self.curlang , "notice" , "waitendfunction" , undefined , undefined , undefined );
        return;
    }
    // en: if the specified variable does not yet exist
    // ja: 指定の変数がまだ存在しない場合
    if ( !isdefined( self.optstat[optname] ) )
        // en : execute the process when the specified parameter is enabled
        // ja : 指定のパラメーターを有効にした時の処理を実行する
        self enabledselfparameter( self.curlang , optname , undefined , message , true , optfunc , true , optarg1 , optarg2 , optarg3 , optarg4 , optarg5 , optarg6 , optarg7 , weaponid , inprojectile , onlygroup , attachmentid , camoid , camogroup , dualmode );
    // en: if the specified variable has already been created
    // ja: 指定の変数が既に作られている場合
    else
        // en : execute the process when the specified parameter is disabled
        // ja : 指定のパラメーターを無効にした時の処理を実行する
        self disabledselfparameter( self.curlang , optname , undefined , true , weaponid );
}



//++++++++++++++++++++++++++++++
// en : displays text and executes sub-functions associated with the main function according to the on/off state of specified variables.
// ja : 指定の変数のオンオフ状態に合わせて、文章の表示を行い、メイン機能に付随するサブ機能の実行を行う
//++++++++++++++++++++++++++++++
switchonfselfsubfunction( optname1 , optname2 , optdata , optfunc , notice , optarg1 , optarg2 , optarg3 , optarg4 , optarg5 , optarg6 , optarg7 )
{
    // en: if the specified main function variable does not yet exist
    // ja: 指定のメイン機能の変数がまだ存在しない場合
    if ( !isdefined( self.optstat[optname1] ) )
    {
        // en: the text "[notification] function not executed: function name" is displayed in the center of the screen.
        // ja: 画面中央に "[通知] 機能が未実行 : 機能名称" という文章を表示する
        self showcentermessage( self.curlang , "notice" , "notfuncexec" , optname1 , undefined , undefined );
        return;
    }

    // en: if the variable for the specified subfunction does not yet exist
    // ja: 指定のサブ機能の変数がまだ存在しない場合
    if ( !isdefined( self.optstat[optname1].moddata[optname2] ) )
    {
        // en : execute the process when the specified parameter is enabled
        // ja : 指定のパラメーターを有効にした時の処理を実行する
        self enabledselfparameter( self.curlang , optname1 , optname2 , undefined , optdata , optfunc , notice , optarg1 , optarg2 , optarg3 , optarg4 , optarg5 , optarg6 , optarg7 );
    }
    // en: if the specified subfunction variable has already been created
    // ja: 指定のサブ機能の変数が既に作られている場合
    else
    {
        // en : execute the process when the specified parameter is disabled
        // ja : 指定のパラメーターを無効にした時の処理を実行する
        self disabledselfparameter( self.curlang , optname1 , optname2 , notice , undefined );
    }
}



//++++++++++++++++++++++++++++++
// en : display text and execute functions according to the on/off state of specified level variables.
// ja : 指定の level 変数のオンオフ状態に合わせて、文章の表示と機能の実行を行う
//++++++++++++++++++++++++++++++
switchonflevelfunction( optname , optfunc , message , optarg1 , optarg2 , optarg3 , optarg4 , optarg5 , optarg6  , optarg7 )
{
    // en : since the process of deleting the previously created case is in progress, the process is interrupted as it cannot be recreated.
    // ja : 前回作った筐体の削除処理が実行中の為、再作成できないとして処理を中断する
    if ( isdefined( level.lvlstat[optname + "deleting"] ) )
    {
        // en: display the specified text in the center of the screen
        // ja: 画面中央に指定の文章を表示する
        self showcentermessage( self.curlang , "notice" , "waitendfunction" , undefined , undefined , undefined );
        return;
    }

    // en: if the specified level variable does not already exist
    // ja: 指定の level 変数がまだ存在しない場合
    if ( !isdefined( level.lvlstat[optname] ) )
    {
        // en : execute the process when the specified parameter is enabled
        // ja : 指定のパラメーターを有効にした時の処理を実行する
        self enabledlevelparameter( self.curlang , optname , undefined , message , true , optfunc , true , optarg1 , optarg2 , optarg3 , optarg4 , optarg5 , optarg6 , optarg7 );
    }
    // en: if the specified level variable has already been created
    // ja: 指定の level 変数が既に作られている場合
    else
    {
        // en : execute the process when the specified parameter is disabled
        // ja : 指定のパラメーターを無効にした時の処理を実行する
        self disabledlevelparameter( self.curlang , optname , undefined , true );
    }
}



//++++++++++++++++++++++++++++++
// en : displays text and executes sub-functions associated with the main function according to the on/off state of specified level variables.
// ja : 指定の level 変数のオンオフ状態に合わせて、文章の表示を行い、メイン機能に付随するサブ機能の実行を行う
//++++++++++++++++++++++++++++++
switchonflevelsubfunction( optname1 , optname2 , optdata , optfunc , notice , optarg1 , optarg2 , optarg3 , optarg4 , optarg5 , optarg6 , optarg7 )
{
    // en: if the specified main function variable does not yet exist
    // ja: 指定のメイン機能の変数がまだ存在しない場合
    if ( !isdefined( level.lvlstat[optname1] ) )
    {
        // en: the text "[notification] function not executed: function name" is displayed in the center of the screen.
        // ja: 画面中央に "[通知] 機能が未実行 : 機能名称" という文章を表示する
        self showcentermessage( self.curlang , "notice" , "notfuncexec" , optname1 , undefined , undefined );
        return;
    }

    // en: if the variable for the specified subfunction does not yet exist
    // ja: 指定のサブ機能の変数がまだ存在しない場合
    if ( !isdefined( level.lvlstat[optname1].moddata[optname2] ) )
    {
        // en : execute the process when the specified parameter is enabled
        // ja : 指定のパラメーターを有効にした時の処理を実行する
        self enabledlevelparameter( self.curlang , optname1 , optname2 , undefined , optdata , optfunc , notice , optarg1 , optarg2 , optarg3 , optarg4 , optarg5 , optarg6 , optarg7 );
    }
    // en: if the specified subfunction variable has already been created
    // ja: 指定のサブ機能の変数が既に作られている場合
    else
    {
        // en : execute the process when the specified parameter is disabled
        // ja : 指定のパラメーターを無効にした時の処理を実行する
        self disabledlevelparameter( self.curlang , optname1 , optname2 , notice );
    }
}




//++++++++++++++++++++++++++++++
// en : processing when the specified self parameter is enabled
// ja : 指定の self パラメーターを有効にした時の処理
//++++++++++++++++++++++++++++++
enabledselfparameter( selflang , optname1 , optname2 , message , optdata , optfunc , notice , optarg1 , optarg2 , optarg3 , optarg4 , optarg5 , optarg6 , optarg7 , weaponid , inprojectile , onlygroup , attachmentid , camoid , camogroup , dualmode )
{
    l_optname = "";

    // en: if suboptions are specified
    // ja: サブオプションが指定されている場合は
    if ( isdefined( optname2 ) )
    {
        l_optname = optname2;
        
        // en: set the specified data in the variable of the specified subfunction
        // ja: 指定のサブ機能の変数に、指定のデータを設定する
        self.optstat[optname1].moddata[optname2] = optdata;
    }
    // en: if no suboptions are specified
    // ja: サブオプションが指定されていない場合は
    else if ( isdefined( optname1 ) )
    {
        l_optname = optname1;

        // en: enable specified variable
        // ja: 指定の変数を有効にする
        self.optstat[optname1] = true;
        
        // en: add structure to "optstat" variable
        // ja: 「optstat」変数に構造体を追加する
        self.optstat[optname1] = spawnstruct( );
        
        // en: create an array to set parameters dedicated to each function
        // ja: 各機能専用のパラメーターを設定するための配列を作成
        self.optstat[optname1].moddata = [];
        
        // en: if weapon id is specified
        // ja: 武器idが指定されている場合
        if ( isdefined( weaponid ) )
        {
            //  //// en: get weapon data into specified variable
            //  //// ja: 指定の変数に武器データを取得する
            //  self.optstat[optname1].weapondata = self provideweapon(
            //      /* weaponid */      weaponid ,
            //      /* inprojectile */  inprojectile ,
            //      /* onlygroup */     onlygroup ,
            //      /* attachmentid */  attachmentid ,
            //      /* camoid */        camoid ,
            //      /* camogroup */     camogroup ,
            //      /* akimbo */        dualmode ,
            //      /* changehand */    true ,
            //      /* notice */        undefined ,
            //      /* onlygetid */     undefined
            //      );
        }
    }

    // en: if you need to display a message
    // ja: メッセージを表示する必要がある場合
    if ( isdefined( notice ) )
    {
        // en: display the text "[enabled] function name" in the center of the screen
        // ja: 画面中央に「[有効化] 機能名称」という文章を表示する
        self showcentermessage( selflang , "enabled" , l_optname , message , undefined , undefined );
    }

    // en: if a function to execute is specified
    // ja: 実行する関数が指定されている場合
    if ( isdefined( optfunc ) )
    {
        // en: execute the specified function in a subthread
        // ja: 指定した関数をサブスレッドで実行する
        if      ( isdefined( optarg7 ) )    { self thread [[ optfunc ]]( optarg1 , optarg2 , optarg3 , optarg4 , optarg5 , optarg6 , optarg7 ); }
        else if ( isdefined( optarg6 ) )    { self thread [[ optfunc ]]( optarg1 , optarg2 , optarg3 , optarg4 , optarg5 , optarg6 ); }
        else if ( isdefined( optarg5 ) )    { self thread [[ optfunc ]]( optarg1 , optarg2 , optarg3 , optarg4 , optarg5 ); }
        else if ( isdefined( optarg4 ) )    { self thread [[ optfunc ]]( optarg1 , optarg2 , optarg3 , optarg4 ); }
        else if ( isdefined( optarg3 ) )    { self thread [[ optfunc ]]( optarg1 , optarg2 , optarg3 ); }
        else if ( isdefined( optarg2 ) )    { self thread [[ optfunc ]]( optarg1 , optarg2 ); }
        else if ( isdefined( optarg1 ) )    { self thread [[ optfunc ]]( optarg1 ); }
        else                                { self thread [[ optfunc ]]( ); }
    }
}



//++++++++++++++++++++++++++++++
// en : processing when the specified self parameter is disabled
// ja : 指定の self パラメーターを無効にした時の処理
//++++++++++++++++++++++++++++++
disabledselfparameter( selflang , optname1 , optname2 , notice , weaponid )
{
    l_optname = "";

    // en: if suboptions are specified
    // ja: サブオプションが指定されている場合は
    if ( isdefined( optname2 ) )
    {
        l_optname = optname2;

        // en: disable (discard) the specified subfunction variable
        // ja: 指定のサブ機能の変数を無効（破棄）する
        self.optstat[optname1].moddata[optname2] = undefined;
    }
    // en: if no suboptions are specified
    // ja: サブオプションが指定されていない場合は
    else
    {
        l_optname = optname1;

        // en: if weapon id is specified
        // ja: 武器idが指定されている場合
        if ( isdefined( weaponid ) )
        {
            // en: pick up the target's weapon
            // ja: 持っている対象の武器を取り上げる
            //  self configureweapon( self.optstat[optname1].weapondata , true , true , undefined , undefined , undefined );
            wait 0.01;
        }

        // en: disable (discard) the specified variable
        // ja: 指定の変数を無効（破棄）する
        self.optstat[optname1] = undefined;
    }

    // en: set the specified option name as the function termination trigger
    // ja: 指定のオプション名の終了トリガーを通知する
    self notify( "end_" + l_optname );

    // en: if you need to display a message
    // ja: メッセージを表示する必要がある場合
    if ( isdefined( notice ) )
    {
        // en: display the text "[disabled] function name" in the center of the screen
        // ja: 画面中央に「[無効化] 機能名称」という文章を表示する
        self showcentermessage( selflang , "disabled" , l_optname , undefined , undefined , undefined );
    }
}



//++++++++++++++++++++++++++++++
// en : processing when the specified level parameter is enabled
// ja : 指定の level パラメーターを有効にした時の処理
//++++++++++++++++++++++++++++++
enabledlevelparameter( selflang , optname1 , optname2 , message , optdata , optfunc , notice , optarg1 , optarg2 , optarg3 , optarg4 , optarg5 , optarg6 , optarg7 )
{
    l_optname = "";

    // en: if suboptions are specified
    // ja: サブオプションが指定されている場合は
    if ( isdefined( optname2 ) )
    {
        l_optname = optname2;
        
        // en: set the specified data in the variable of the specified subfunction
        // ja: 指定のサブ機能の変数に、指定のデータを設定する
        level.lvlstat[optname1].moddata[optname2] = optdata;
        self.optstat[optname1].moddata[optname2] = optdata;
    }
    // en: if no suboptions are specified
    // ja: サブオプションが指定されていない場合は
    else if ( isdefined( optname1 ) )
    {
        l_optname = optname1;

        // en: enable specified variable
        // ja: 指定の変数を有効にする
        level.lvlstat[optname1] = true;
        self.optstat[optname1] = true;
        
        // en: add structure to "lvlstat" variable
        // ja: "lvlstat" 変数に構造体を追加する
        level.lvlstat[optname1] = spawnstruct( );
        self.optstat[optname1] = spawnstruct( );
        
        // en: create an array to set parameters dedicated to each function
        // ja: 各機能専用のパラメーターを設定するための配列を作成
        level.lvlstat[optname1].moddata = [];
        self.optstat[optname1].moddata = [];
    }

    // en: if you need to display a message
    // ja: メッセージを表示する必要がある場合
    if ( isdefined( notice ) )
    {
        // en: if you want to display a specific message
        // ja: 特定のメッセージを表示する場合
        if ( isdefined( message ) )
        {
            // en: display the text "[notice] message" in the center of the screen
            // ja: 画面中央に "[通知] メッセージ" という文章を表示する
            self showcentermessage( selflang , "notice" , message , undefined , undefined , undefined );
        }
        // en: if no message is specified
        // ja: メッセージの指定がない場合
        else
        {
            // en: display the text "[enabled] function name" in the center of the screen
            // ja: 画面中央に「[有効化] 機能名称」という文章を表示する
            self showcentermessage( selflang , "enabled" , l_optname , undefined , undefined , undefined );
        }
    }

    // en: if a function to execute is specified
    // ja: 実行する関数が指定されている場合
    if ( isdefined( optfunc ) )
    {
        // en: execute the specified function in a subthread
        // ja: 指定した関数をサブスレッドで実行する
        if      ( isdefined( optarg7 ) )    { self thread [[ optfunc ]]( optarg1 , optarg2 , optarg3 , optarg4 , optarg5 , optarg6 , optarg7 ); }
        else if ( isdefined( optarg6 ) )    { self thread [[ optfunc ]]( optarg1 , optarg2 , optarg3 , optarg4 , optarg5 , optarg6 ); }
        else if ( isdefined( optarg5 ) )    { self thread [[ optfunc ]]( optarg1 , optarg2 , optarg3 , optarg4 , optarg5 ); }
        else if ( isdefined( optarg4 ) )    { self thread [[ optfunc ]]( optarg1 , optarg2 , optarg3 , optarg4 ); }
        else if ( isdefined( optarg3 ) )    { self thread [[ optfunc ]]( optarg1 , optarg2 , optarg3 ); }
        else if ( isdefined( optarg2 ) )    { self thread [[ optfunc ]]( optarg1 , optarg2 ); }
        else if ( isdefined( optarg1 ) )    { self thread [[ optfunc ]]( optarg1 ); }
        else                                { self thread [[ optfunc ]]( ); }
    }
}



//++++++++++++++++++++++++++++++
// en : processing when the specified level parameter is disabled
// ja : 指定の level パラメーターを無効にした時の処理
//++++++++++++++++++++++++++++++
disabledlevelparameter( selflang , optname1 , optname2 , notice )
{
    l_optname = "";

    // en: if suboptions are specified
    // ja: サブオプションが指定されている場合は
    if ( isdefined( optname2 ) )
    {
        l_optname = optname2;

        // en: disable (discard) the specified subfunction variable
        // ja: 指定のサブ機能の変数を無効（破棄）する
        level.lvlstat[optname1].moddata[optname2] = undefined;
        self.optstat[optname1].moddata[optname2] = undefined;
    }
    // en: if no suboptions are specified
    // ja: サブオプションが指定されていない場合は
    else
    {
        l_optname = optname1;

        // en: disable (discard) the specified variable
        // ja: 指定の変数を無効（破棄）する
        level.lvlstat[optname1] = undefined;
        self.optstat[optname1] = undefined;
    }

    // en: set the specified option name as the function termination trigger
    // ja: 指定のオプション名の終了トリガーを通知する
    level notify( "end_lobby_" + l_optname );

    // en: if you need to display a message
    // ja: メッセージを表示する必要がある場合
    if ( isdefined( notice ) )
    {
        // en: display the text "[disabled] function name" in the center of the screen
        // ja: 画面中央に「[無効化] 機能名称」という文章を表示する
        self showcentermessage( selflang , "disabled" , l_optname , undefined , undefined , undefined );
    }
}



//++++++++++++++++++++++++++++++
// en : select self variables related to the specified function in order from the specified array
// ja : 指定の機能に関する self 変数を、指定の配列内から順に選択する
//++++++++++++++++++++++++++++++
changeselfparameter( optname1 , optname2 , prefix , optfunc , arraydata , notice , lastend , random )
{
    // en: run the specified function if it has not already been run
    // ja: 指定された機能がまだ実行されていない場合
    if ( !isdefined( self.optstat[optname1] ) )
    {
        // en: if option name 2 is specified
        // ja: オプション名2が指定されている場合
        if ( isdefined( optname2 ) )
        {
            // en: run once and create variables for specified functions
            // ja: 一度実行して、指定機能に関する変数を作成する
            self thread [[ optfunc ]]( );
        }
        // en: if option name 2 is not specified
        // ja: オプション名2が指定されていない場合
        else
        {
            // en: set the first item.
            // ja: 最初の項目を設定する
            self.optstat[optname1] = arraydata[0];
            // en: display the text "[notification] function name: element name" in the center of the screen.
            // ja: 画面中央に "[通知] 機能名 : 要素名" という文章を表示する
            self showcentermessage( self.curlang , "notice" , optname1 , undefined , self.optstat[optname1] , prefix );
            
        }
    }
    // en: if the specified function has already been executed
    // ja: 指定された機能が実行済みの場合
    else
    {
        // en: when not randomly selected
        // ja: ランダム選定しない場合
        if ( !isdefined( random ) )
        {
            // en: if option name 2 is specified
            // ja: オプション名2が指定されている場合
            if ( isdefined( optname2 ) )
            {
                // en: if there are no subparameters yet
                // ja: まだサブパラメーターが存在しない場合
                if ( !isdefined( self.optstat[optname1].moddata[optname2] ) )
                {
                    // en: set the first item.
                    // ja: 最初の項目を設定する
                    self.optstat[optname1].moddata[optname2] = arraydata[0];
                }
                // en: if there are subparameters yet
                // ja: サブパラメーターが存在する場合
                else
                {
                    // en: array length loop
                    // ja: 配列長分ループ
                    for ( index = 0; index < arraydata.size; index++ )
                    {
                        // en: skip until it matches the item currently being set
                        // ja: 現在設定中の項目と一致するまではスキップ
                        if ( !isdefined( arraydata[index].assetname ) ) { if ( self.optstat[optname1].moddata[optname2] != arraydata[index] )                       { continue; } }
                        else                                            { if ( self.optstat[optname1].moddata[optname2].assetname != arraydata[index].assetname )   { continue; } }

                        // en: if the next item that is currently being set does not exceed the length of the array, set the next item.
                        // ja: 現在設定中の項目の一個次が、配列の長さを超えていない場合は、一個次の項目を設定する
                        if ( (index + 1) < arraydata.size ) { self.optstat[optname1].moddata[optname2] = arraydata[index + 1]; }
                        
                        // en: if the next item that is currently being set exceeds the length of the array
                        // ja: 現在設定中の項目の一個次が、配列の長さを超えてしまう場合は
                        else
                        {
                            // en: if the function does not end at the last item,
                            // ja: 最後の項目で機能を終了しない場合は
                            if ( !isdefined( lastend ) )
                            {
                                // en: set the first item.
                                // ja: 最初の項目を設定する
                                self.optstat[optname1].moddata[optname2] = arraydata[0];
                            }
                            // en: to end the function at the last item
                            // ja: 最後の項目で機能を終了する場合は
                            else
                            {
                                // en: disable specified features
                                // ja: 指定の機能を無効にする
                                self thread [[ optfunc ]]( );
                                wait 0.01;
                            }
                        }
                        
                        // en: end loop
                        // ja: ループ終了
                        break;
                    }
                }
            }
            // en: if option name 2 is not specified
            // ja: オプション名2が指定されていない場合
            else
            {
                // en: array length loop
                // ja: 配列長分ループ
                for ( index = 0; index < arraydata.size; index++ )
                {
                    // en: skip until it matches the item currently being set
                    // ja: 現在設定中の項目と一致するまではスキップ
                    if ( self.optstat[optname1] != arraydata[index] ) { continue; }
                    

                    // en: if the next item that is currently being set does not exceed the length of the array, set the next item.
                    // ja: 現在設定中の項目の一個次が、配列の長さを超えていない場合は、一個次の項目を設定する
                    if ( (index + 1) < arraydata.size ) { self.optstat[optname1] = arraydata[index + 1]; }
                    
                    // en: if the next item that is currently being set exceeds the length of the array
                    // ja: 現在設定中の項目の一個次が、配列の長さを超えてしまう場合は
                    else
                    {
                        // en: if the function does not end at the last item,
                        // ja: 最後の項目で機能を終了しない場合は
                        if ( !isdefined( lastend ) )
                        {
                            // en: set the first item.
                            // ja: 最初の項目を設定する
                            self.optstat[optname1] = arraydata[0];
                        }
                        // en: to end the function at the last item
                        // ja: 最後の項目で機能を終了する場合は
                        else
                        {
                            // en: disable specified features
                            // ja: 指定の機能を無効にする
                            self.optstat[optname1] = undefined;
                        }
                    }
                    
                    // en: end loop
                    // ja: ループ終了
                    break;
                }
            }
        }
        // en: when selecting randomly, extract randomly from the array.
        // ja: ランダム選定する場合、配列内からランダムに取り出す
        else
        {
            // en: if option name 2 is specified
            // ja: オプション名2が指定されている場合
            if ( isdefined( optname2 ) )
            {
                self.optstat[optname1].moddata[optname2] = arraydata[randomintrange( 0 , arraydata.size )];
            }
            // en: if option name 2 is not specified
            // ja: オプション名2が指定されていない場合
            else
            {
                self.optstat[optname1] = arraydata[randomintrange( 0 , arraydata.size )];
            }
        }

        // en: if you need to display a message
        // ja: メッセージを表示する必要がある場合
        if ( isdefined( notice ) )
        {
            // en: if option name 2 is specified
            // ja: オプション名2が指定されている場合
            if ( isdefined( optname2 ) )
            {
                // en: if the function does not end at the last item,
                // ja: 最後の項目で機能を終了しない場合は
                if ( !isdefined( lastend ) )
                {
                    // en: display the text "[notification] function name: element name" in the center of the screen.
                    // ja: 画面中央に「[通知] 機能名 : 要素名」という文章を表示する
                    if ( !isdefined( self.optstat[optname1].moddata[optname2].assetname ) ) { self showcentermessage( self.curlang , "notice" , optname2 , undefined , self.optstat[optname1].moddata[optname2] , prefix ); }
                    else                                                                    { self showcentermessage( self.curlang , "notice" , optname2 , undefined , self.optstat[optname1].moddata[optname2].assetname , prefix ); }
                    
                }
                // en: to end the function at the last item
                // ja: 最後の項目で機能を終了する場合は
                else
                {
                    // en: if the parent variable of the specified function exists
                    // ja: 指定の機能の親変数が存在する場合
                    if ( isdefined( self.optstat[optname1] ) )
                    {
                        // en: display the text "[notification] function name: element name" in the center of the screen.
                        // ja: 画面中央に "[通知] 機能名 : 要素名" という文章を表示する
                        if ( !isdefined( self.optstat[optname1].moddata[optname2].assetname ) ) { self showcentermessage( self.curlang , "notice" , optname1 , undefined , self.optstat[optname1].moddata[optname2] , prefix ); }
                        else                                                                    { self showcentermessage( self.curlang , "notice" , optname1 , undefined , self.optstat[optname1].moddata[optname2].assetname , prefix ); }
                    }
                }
            }
            // en: if option name 2 is not specified
            // ja: オプション名2が指定されていない場合
            else
            {
                // en: display the text "[notification] function name: element name" in the center of the screen.
                // ja: 画面中央に "[通知] 機能名 : 要素名" という文章を表示する
                self showcentermessage( self.curlang , "notice" , optname1 , undefined , self.optstat[optname1] , prefix );
            }
        }
    }
}



//++++++++++++++++++++++++++++++
// en : select level variables related to the specified function in order from the specified array
// ja : 指定の機能に関する level 変数を、指定の配列内から順に選択する
//++++++++++++++++++++++++++++++
changelevelparameter( optname1 , optname2 , prefix , optfunc , arraydata , notice , lastend )
{
    // en: run the specified function if it has not already been run
    // ja: 指定された機能がまだ実行されていない場合
    if ( !isdefined( level.lvlstat[optname1] ) )
    {
        // en: run once and create variables for specified functions
        // ja: 一度実行して、指定機能に関する変数を作成する
        self thread [[ optfunc ]]( );
    }
    // en: if the specified function has already been executed
    // ja: 指定された機能が実行済みの場合
    else
    {
        // en: array length loop
        // ja: 配列長分ループ
        for ( index = 0; index < arraydata.size; index++ )
        {
            // en: skip until it matches the item currently being set
            // ja: 現在設定中の項目と一致するまではスキップ
            if ( level.lvlstat[optname1].moddata[optname2] != arraydata[index] ) { continue; }

            // en: if the next item that is currently being set does not exceed the length of the array, set the next item.
            // ja: 現在設定中の項目の一個次が、配列の長さを超えていない場合は、一個次の項目を設定する
            if ( (index + 1) < arraydata.size ) { level.lvlstat[optname1].moddata[optname2] = arraydata[index + 1]; }
            
            // en: if the next item that is currently being set exceeds the length of the array
            // ja: 現在設定中の項目の一個次が、配列の長さを超えてしまう場合は
            else
            {
                // en: if the function does not end at the last item,
                // ja: 最後の項目で機能を終了しない場合は
                if ( !isdefined( lastend ) )
                {
                    // en: set the first item.
                    // ja: 最初の項目を設定する
                    level.lvlstat[optname1].moddata[optname2] = arraydata[0];
                }
                // en: to end the function at the last item
                // ja: 最後の項目で機能を終了する場合は
                else
                {
                    // en: disable specified features
                    // ja: 指定の機能を無効にする
                    self thread [[ optfunc ]]( );
                    wait 0.01;
                }
            }
            
            // en: end loop
            // ja: ループ終了
            break;
        }

        // en: if you need to display a message
        // ja: メッセージを表示する必要がある場合
        if ( isdefined( notice ) )
        {
            // en: if the function does not end at the last item,
            // ja: 最後の項目で機能を終了しない場合は
            if ( !isdefined( lastend ) )
            {
                // en: display the text "[notification] function name: element name" in the center of the screen.
                // ja: 画面中央に「[通知] 機能名 : 要素名」という文章を表示する
                self showcentermessage( self.curlang , "notice" , optname2 , undefined , level.lvlstat[optname1].moddata[optname2] , prefix );
            }
            // en: to end the function at the last item
            // ja: 最後の項目で機能を終了する場合は
            else
            {
                // en: if the parent variable of the specified function exists
                // ja: 指定の機能の親変数が存在する場合
                if ( isdefined( level.lvlstat[optname1] ) )
                {
                    // en: display the text "[notification] function name: element name" in the center of the screen.
                    // ja: 画面中央に "[通知] 機能名 : 要素名" という文章を表示する
                    self showcentermessage( self.curlang , "notice" , optname1 , undefined , level.lvlstat[optname1].moddata[optname2] , prefix );
                }
            }
        }
    }
}



//++++++++++++++++++++++++++++++
// en : select variables related to the specified function in order from the specified array
// ja : 指定の機能に関する変数を、指定の配列内から順に選択する
//++++++++++++++++++++++++++++++
changedvarparameter( optname , prefix , arraydata , dvarname )
{
    l_result = 0;

    // en: array length loop
    // ja: 配列長分ループ
    for ( index = 0; index < arraydata.size; index++ )
    {
        // en: skip until it matches the item currently being set
        // ja: 現在設定中の項目と一致するまではスキップ
        if ( getdvarint( dvarname ) != arraydata[index] ) { continue; }

        // en: if the next item that is currently being set does not exceed the length of the array, set the next item.
        // ja: 現在設定中の項目の一個次が、配列の長さを超えていない場合は、一個次の項目を設定する
        if ( (index + 1) < arraydata.size )
        {
            setdvar( dvarname , arraydata[index + 1] );
            l_result = index + 1;
        }
        
        // en: if the next item that is currently being set exceeds the length of the array, set the first item.
        // ja: 現在設定中の項目の一個次が、配列の長さを超えてしまう場合は、最初の項目を設定する
        else
        {
            setdvar( dvarname , arraydata[0] );
        }

        // en: end loop
        // ja: ループ終了
        break;
    }

    // en: display the text "[notification] function name: element name" in the center of the screen.
    // ja: 画面中央に "[通知] 機能名 : 要素名" という文章を表示する
    self showcentermessage( self.curlang , "notice" , optname , undefined , arraydata[l_result] , prefix );
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : Subthread generic processing
// ja : サブスレッド汎用処理
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : general-purpose functions for performing functions that perform loop processing
// ja : ループ処理を行う機能を実行するための汎用関数
//++++++++++++++++++++++++++++++
execloopfunction( optname , optfunc , looptime )
{
    // en : this function ends the process if "you disconnect from the room"
    // ja : この関数は「自分が部屋から切断した」場合に処理を終了する
    self endon( "disconnect" );
    // en : this function ends processing if "you die"
    // ja : この関数は「自分が死んだ」場合に処理を終了する
    self endon( "death" );
    // en: set the specified effect name as the function termination trigger
    // ja: 指定の機能名を関数の終了トリガーとする
    self endon( "finalize_" + optname );


    // en: use the specified function name as the function termination trigger
    // ja: 指定の機能の初期化処理を行う
    self [[ optfunc ]]( optname , 0 );


    // en: loop until specified variable no longer exists
    // ja: 指定の変数が存在しなくなるまでループ
    while ( isdefined( self.optstat[optname] ) )
    {
        // en: performs in-loop processing of specified function
        // ja: 指定の機能のループ中処理を行う
        self [[ optfunc ]]( optname , 1 );

        // en: wait for the specified time
        // ja: 指定時間分待機する
        wait looptime;
    }
    
    // en: perform termination processing for the specified function
    // ja: 指定の機能の終了処理を行う
    self [[ optfunc ]]( optname , 2 );
}



//++++++++++++++++++++++++++++++
// en : generic function to disable duplicate functions if they are activated
// ja : 重複している機能が起動している場合、無効化させるための汎用関数
//++++++++++++++++++++++++++++++
checkduplicatefunction( name , func )
{
    // en: if the specified function is already enabled, disable it due to processing conflict.
    // ja: 指定の機能が既に有効の場合は、処理が競合するため無効にする
    if ( isdefined( self.optstat[name] ) )
    {
        // en: discard function execution flag
        // ja: 機能実行フラグを破棄
        self.optstat[name] = undefined;
        // en: stop the running loop process and call the termination process
        // ja: 実行中のループ処理を停止し、終了処理を呼ぶ
        self notify( "finalize_" + name );
        wait 0.01;
        self [[ func ]]( name , 2 );
    }
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : In-game logic generic function
// ja : インゲームロジック汎用関数
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : play the effect starting from the specified object
// ja : 指定したオブジェクトを起点にエフェクトを再生する
//++++++++++++++++++++++++++++++
playeffecttoobject( time , obj , fx , tag , type , loop , base , fix , angle , range , stop , owner )
{
    l_owner = self;
    if ( isdefined( owner ) ) l_owner = owner;


    // en : if the specified object exists
    // ja : 指定されたオブジェクトが存在する場合
    if ( isdefined( obj ) )
    {
        // en: set the specified effect name as the function termination trigger
        // ja: 指定のエフェクト名を関数の終了トリガーとする
        obj endon( "end_" + fx );
        
        // en : if a tag name is specified and the object does not have a tag, fix the tag name.
        // ja : タグ名が指定されていて、そのオブジェクトがタグを持っていない場合は、タグ名を修正する
        if ( isdefined( tag ) )
        {
            if ( checktag( obj.model , tag ) == false )
            {
                tag = "tag_origin";
            }
        }
    }

    // en : to end the tag effect that is currently playing
    // ja : 再生中のタグエフェクトを終了する場合
    if ( isdefined( stop ) )
    {
        if      ( type == "gettag" )    { stopfxontag( geteffect( fx ) , obj , tag ); }
        else if ( type == "loadtag" )   { stopfxontag( fx , obj , tag ); }

        // en: set the specified option name as the function termination trigger
        // ja: 指定のエフェクト名の終了トリガーを通知する
        obj notify( "end_" + fx );
        return;
    }
    
    // en : if adjustment coordinates are not specified, initialize them.
    // ja : 調整座標を指定されてない場合は、初期化しておく
    if ( !isdefined( fix ) )    { fix = ( 0 , 0 , 0 ); }

    // en: infinite loop
    // ja: 無限ループ
    while ( true )
    {
        // en : if the specified object exists
        // ja : 指定されたオブジェクトが存在する場合
        if ( isdefined( obj ) )
        {
            // en : if a tag name is specified, play the effect at the coordinates of the tag name
            // ja : タグ名が指定されている場合、タグ名の座標にエフェクトを再生する
            if ( isdefined( tag ) )
            {
                if      ( type == "gettag" )    { playfxontag( geteffect( fx ) , obj , tag ); }
                else if ( type == "loadtag" )   { playfxontag( fx , obj , tag ); }
            }
            // en : if no tag name is specified, play the effect at a location shifted from the object to the modified coordinates.
            // ja : タグ名が指定されていない場合、オブジェクトから修正座標にずらした場所にエフェクトを再生する
            else
            {
                if ( isdefined( angle ) )
                {
                    switch ( angle )
                    {
                        case "up":      fix = fix + anglestoup( obj.angles ) * range; break;
                        case "forward": fix = fix + anglestoforward( obj.angles ) * range; break;
                        case "left":    fix = fix + anglestoleft( obj.angles ) * range; break;
                        case "right":   fix = fix + anglestoright( obj.angles ) * range; break;
                    }
                }

                if      ( type == "getplay" )   { playfx( geteffect( fx ) , obj.origin + fix ); }
                else if ( type == "loadplay" )  { playfx( fx , obj.origin + fix ); }

                else if ( type == "getspawn" )  { l_fx = spawnfx( geteffect( fx ) , obj.origin + fix ); triggerfx( l_fx ); l_fx thread deleteaftertime( 5 ); }
                else if ( type == "loadspawn" ) { l_fx = spawnfx( fx , obj.origin + fix ); triggerfx( l_fx ); l_fx thread deleteaftertime( 5 ); }
            }
        }
        // en : if the specified object does not exist
        // ja : 指定されたオブジェクトが存在しない場合
        else
        {
            // en : if basic coordinates are specified, generate effect at specified coordinates
            // ja : 基本座標が指定されている場合、指定された座標にエフェクトを生成する
            if ( isdefined( base ) )
            {
                if      ( type == "getplay" )   { playfx( geteffect( fx ) , base + fix ); }
                else if ( type == "loadplay" )  { playfx( fx , base + fix ); }
                
                else if ( type == "getspawn" )  { l_fx = spawnfx( geteffect( fx ) , base + fix ); triggerfx( l_fx ); l_fx thread deleteaftertime( 5 ); }
                else if ( type == "loadspawn" ) { l_fx = spawnfx( fx , base + fix ); triggerfx( l_fx ); l_fx thread deleteaftertime( 5 ); }
            }

            // en : in the case of loop processing, the loop is interrupted because there is no means to terminate it.
            // ja : ループ処理の場合、終了するための手段を実装していないため、ループを中断する
            if ( isdefined( loop ) ) { break; }
        }

        // en : break the loop if it does not loop infinitely
        // ja : 無限ループしない場合、ループを中断する
        if ( !isdefined( loop ) ) { break; }
        
        wait time;
    }
}



//++++++++++++++++++++++++++++++
// en : delete the specified object after the specified number of seconds
// ja : 指定されたオブジェクトを、指定された秒数経過後に削除する
//++++++++++++++++++++++++++++++
deleteaftertime( time )
{
    // en : this function ends processing when "the match is over"
    // ja : この関数は「試合が終了した」場合に処理を終了する
    level endon( "game_ended" );
    // en : this function ends processing if "you die"
    // ja : この関数は「自分が死んだ」場合に処理を終了する
    self endon( "death" );
    
    hostpause( time );
    self deleteentity( );
}



//++++++++++++++++++++++++++++++
// en : obtain a trace in the front direction
// ja : 正面方向へのトレースを取得する
//++++++++++++++++++++++++++++++
getplayerforwardtrace( trace , eye , length , up )
{
    // en: when to use tracing
    // ja: トレースを使用する場合
    if ( isdefined( trace ) ) 
        return tracebullet( self geteye( ) , self geteye( ) + ( anglestoforward( self getplayerangles( ) ) * length ) , 1 , self );
    // en: when not to use tracing
    // ja: トレースを使用しない場合
    else
    {
        // en: get the coordinates of the player's front direction
        // ja: プレイヤーの正面方向の座標を取得する
        l_location = getangletrace(
            /* object */    self ,
            /* eye */       eye ,
            /* up */        up ,
            /* center */    undefined ,
            /* forward */   undefined ,
            /* back */      undefined ,
            /* backup */    undefined ,
            /* left */      undefined ,
            /* right */     undefined ,
            /* lrup */      undefined ,
            /* end */       length ,
            /* endup */     undefined ,
            /* enddown */   undefined ,
            /* trace */     trace
            );
        return l_location["end"];
    }
}



//++++++++++++++++++++++++++++++
// en : obtains a frontal trace that matches the angle of the specified object
// ja : 指定したオブジェクトの角度に合わせた、正面方向のトレースを取得する
//++++++++++++++++++++++++++++++
getangletrace( object , eye , up , center , forward , back , backup , left , right , lrup , end , endup , enddown , trace )
{
    if ( !isdefined( object ) )     { return; }
    
    l_angle = undefined;
    if ( !isplayer( object ) )      { l_angle = object.angles; }
    else                            { l_angle = object getplayerangles( ); }

    l_location = [];
    l_location["start"] = object.origin;
    if ( isplayer( object ) )       { if ( isdefined( eye ) ) { l_location["start"] = object geteye( ); } }

    if ( isdefined( up ) )          { l_location["start"]      += vectorscale( anglestoup( l_angle ) , up ); }
    if ( isdefined( center ) )      { l_location["start"]      += vectorscale( anglestoforward( l_angle ) , center ); }
    if ( isdefined( forward ) )     { l_location["forward"]    = l_location["start"] + vectorscale( anglestoforward( l_angle ) , forward ); }
    if ( isdefined( back ) )        { l_location["back"]       = l_location["start"] + vectorscale( anglestoforward( l_angle ) , back ); }
    if ( isdefined( left ) )        { left *= -1; }
    if ( isdefined( left ) )        { l_location["left"]       = l_location["start"] + vectorscale( anglestoright( l_angle ) , left ); }
    if ( isdefined( right ) )       { l_location["right"]      = l_location["start"] + vectorscale( anglestoright( l_angle ) , right ); }
    if ( isdefined( backup ) )
    {
        if ( isdefined( back ) )    { l_location["back"]       += vectorscale( anglestoup( l_angle ) , backup ); }
    }
    if ( isdefined( lrup ) )
    {
        if ( isdefined( left ) )    { l_location["left"]       += vectorscale( anglestoup( l_angle ) , lrup ); }
        if ( isdefined( right ) )   { l_location["right"]      += vectorscale( anglestoup( l_angle ) , lrup ); }
    }
    if ( isdefined( end ) )         { l_location["end"]        = l_location["start"] + vectorscale( anglestoforward( l_angle ) , end ); }
    if ( isdefined( endup ) )       { l_location["endup"]      = l_location["start"] + vectorscale( anglestoup( l_angle ) , endup ); }
    if ( isdefined( enddown ) )     { l_location["enddown"]    = l_location["start"] + vectorscale( anglestoup( l_angle ) , enddown ); }
    if ( isdefined( trace ) )
    {
        if ( isdefined( end ) )
        {
            l_point = tracebullet( l_location["start"] , l_location["end"] , 1 , object );
            l_location["endtrace"] = l_point["position"];
        }
    }

    return l_location;
}



//++++++++++++++++++++++++++++++
// en : get the coordinates that are multiples ahead of the specified coordinates
// ja : 指定の座標に対して、倍数分先の座標を取得する
//++++++++++++++++++++++++++++++
vectorscale( location , length )
{
    return ( location[0] * length , location[1] * length , location[2] * length );
}



//++++++++++++++++++++++++++++++
// en : Plays the specified sound effect locally for players
// ja : プレイヤーに指定したサウンドエフェクトをローカルで再生させる
//++++++++++++++++++++++++++++++
playsoundatallplayers( sfx , target , time )
{
    if ( !isdefined( sfx ) ) return;
    if ( isdefined( time ) ) wait time;

    if ( !isdefined( target ) )
    {
        // en: get information on all participating players
        // ja: 参加中の全プレイヤー情報を取得
        foreach( player in level.players )
            // en: play se only for yourself
            // ja: seを自分だけ再生する
            player playlocalsound( sfx );
    }
    else
        // en: play se only for yourself
        // ja: seを自分だけ再生する
        target playlocalsound( sfx );
}



//++++++++++++++++++++++++++++++
// en : wait for a bullet to be fired and process the specified event by matching the weapon information.
// ja : 銃弾の発射を待機し、武器情報の照合一致により、指定のイベントを処理する
//++++++++++++++++++++++++++++++
waitfirebullets( optname1 , optname2 , optfunc , notice , specificweapon , effectdata , enddeath )
{
    // en : this function ends the process if "you disconnect from the room"
    // ja : この関数は「自分が部屋から切断した」場合に処理を終了する
    self endon( "disconnect" );

    // en : if you want to disable the function when you die
    // ja : 死んだ時に機能を無効化したい場合
    if ( isdefined( enddeath ) )
    {
        // en : this function ends processing if "you die"
        // ja : この関数は「自分が死んだ」場合に処理を終了する
        self endon( "death" );
    }
    
    // en: set the specified option name as the function termination trigger
    // ja: 指定のオプション名を関数の終了トリガーとする
    self endon( "end_" + optname1 );
    
    // en: if an effect is specified, allow the effect to occur on fire.
    // ja: エフェクトが指定されている場合、発射時にエフェクトを発生できるようにする
    if ( isdefined( effectdata ) )
    {
        self.optstat[optname1].effectdata = effectdata;
    }

    // en: make it a variable so that you can adjust the distance of the coordinates to get when firing a gun
    // ja: 銃発射時の取得先の座標の距離を調整できるように変数化する
    self.optstat[optname1].moddata["tracelength"] = 100000;

    // en: infinite loop
    // ja: 無限ループ
    while ( true )
    {
        // en: wait until the bullet is fired
        // ja: 銃弾を発射するまで待機する
        self waittill( "weapon_fired" );

        // en: if the specified variable does not exist, end the loop processing
        // ja: 指定の変数が存在しない場合は、ループ処理を終了する
        if ( !isdefined( self.optstat[optname1] ) ) { break; }
        if ( isdefined( optname2 ) )
        {
            if ( !isdefined( self.optstat[optname1].moddata[optname2] ) ) { break; }
        }
        
        // en: activates with specific weapons
        // ja: 特定の武器で発動する場合
        if ( isdefined( specificweapon ) )
        {
            // en: if there is no weapon data linked to the specified variable, end the loop process.
            // ja: 指定の変数に連携する武器データが存在しない場合は、ループ処理を終了する
            if ( !isdefined( self.optstat[optname1].weapondata ) ) { break; }
            
            // en: if the fired weapon and the weapon linked to the specified variable do not match, restart the process.
            // ja: 発射された武器と、指定の変数に連携する武器が一致しない場合は、処理をやり直す
            if ( getweaponcompleteid( self getcurrentweapon( ) ) != self.optstat[optname1].weapondata ) { continue; }
        }

        // en : obtain trace results for a specified number of distances in the front direction
        // ja : 正面方向へ 指定した数値分先 の距離のトレース結果を取得する
        l_endlocation = self getplayerforwardtrace( true , true , self.optstat[optname1].moddata["tracelength"] );
        
        // en: if coordinate information has been obtained
        // ja: 座標情報が取得できている場合
        if ( isdefined( l_endlocation["position"] ) )
        {
            // en: if effect data exists
            // ja: エフェクトデータが存在する場合
            if ( isdefined( self.optstat[optname1].effectdata ) )
            {
                // en: play the effect at the obtained coordinates
                // ja: 取得した座標にエフェクトを再生する
                playeffecttoobject( /* time */ undefined , /* obj */ undefined , /* fx */ self.optstat[optname1].effectdata , /* tag */ undefined , /* type */ "getplay" , /* loop */ undefined , /* base */ l_endlocation["position"] , /* fix */ undefined , /* angle */ undefined , /* range */ undefined , /* stop */ undefined );
            }

            if ( isdefined( notice ) )
            {
                // en: display the text "[notification] request to specified coordinates: function name" in the center of the screen.
                // ja: 画面中央に「[通知] 指定座標に要請 : 機能名」という文章を表示する
                self showcentermessage( self.curlang , "notice" , "requestlocation" , optname1 , undefined , undefined );
            }

            // en: execute the specified function in a subthread (with coordinate arguments)
            // ja: 指定した関数をサブスレッドで実行する（座標引数付き）
            self thread [[ optfunc ]]( l_endlocation["position"] );
        }
    }
}



//++++++++++++++++++++++++++++++
// en : set physical strength to receive damage
// ja : ダメージを受け取る体力設定を行う
//++++++++++++++++++++++++++++++
createdamagingsystem( hpmin , hpmax , dmgtype , dmgfx , brktype , brkfx , dmgse , brkse , del , name , owner )
{
    // en: if maximum health is not specified, do not proceed further.
    // ja: 最大体力が指定されていない場合は、この先の処理を行わない
    if ( !isdefined( hpmax ) ) { return; }


    // en : this function ends processing when "the match is over"
    // ja : この関数は「試合が終了した」場合に処理を終了する
    level endon( "game_ended" );

    
    // en: set the owner of this object if specified
    // ja: このオブジェクトの所有者が指定されている場合は設定する
    if ( isdefined( owner ) )
    {
        self.owner          = owner;
        self.team           = owner.team;
        self.pers["team"]   = owner.pers["team"];
    }


    // en : allow yourself to take damage
    // ja : 自分自身がダメージを受けられるようにする
    self setcandamage( true );
    
    // en: if minimum health is specified
    // ja: 最低体力が指定されている場合
    if ( isdefined( hpmin ) )
    {
        // en: randomly determine maximum health
        // ja: 最大体力をランダムで決める
        self.health = randomintrange( hpmin , hpmax );
    }
    // en: if minimum health is not specified
    // ja: 最低体力が指定されていない場合
    else
    {
        // en: set maximum health
        // ja: 最大体力を設定
        self.health = hpmax;
    }
    self.maxhealth = self.health;

    // en: infinite loop until stamina runs out
    // ja: 体力が無くなるまで無限ループ
    while ( 0 < self.health )
    {
        // en: wait to take damage
        // ja: ダメージを受けるのを待機する
        self waittill( "damage" , damagedsize , playerinfo , var_2 , damagedpoint , damagetype , var_5 , var_6 , var_7 , var_8 , weaponname , var_10 , var_11 , var_12 , killstreakinfo );

        // en: remember the last player info who caused damage
        // ja: 最後にダメージを与えたプレイヤー情報を記憶する
        self.lastattacker = playerinfo;
        self.lastdamagetype = damagetype;
        self.lastweaponname = weaponname;

        // en: reduces health by the amount of damage received
        // ja: 受けたダメージ分体力を減らす
        self.health = self.health - damagedsize;

        // en: if you still have the energy
        // ja: 体力がまだある場合
        if ( 0 < self.health )
        {
            // en: if a damage effect is specified
            // ja: ダメージエフェクトが指定されている場合
            if ( isdefined( dmgfx ) )
            {
                // en: generates an effect at the damaged coordinates
                // ja: ダメージを受けた座標にエフェクトを発生させる
                playeffecttoobject( /* time */ undefined , /* obj */ undefined , /* fx */ dmgfx , /* tag */ undefined , /* type */ dmgtype , /* loop */ undefined , /* base */ damagedpoint, /* fix */ undefined , /* angle */ undefined , /* range */ undefined , /* stop */ undefined );
            }
            // en: if damage sound effects are specified
            // ja: ダメージサウンドエフェクトが指定されている場合
            if ( isdefined( dmgse ) )
            {
                // en: regenerate se at damaged coordinates
                // ja: ダメージを受けた座標にseを再生させる
                playsound( damagedpoint , dmgse );
            }
        }
        // en: if you run out of energy
        // ja: 体力が無くなった場合
        else
        {
            // en: if a destruction effect is specified
            // ja: 破壊エフェクトが指定されている場合
            if ( isdefined( brkfx ) )
            {
                // en: play a destruction effect at your center point
                // ja: 自分の中心点に破壊エフェクトを再生する
                playeffecttoobject( /* time */ undefined , /* obj */ undefined , /* fx */ brkfx , /* tag */ undefined , /* type */ brktype , /* loop */ undefined , /* base */ self.origin, /* fix */ undefined , /* angle */ undefined , /* range */ undefined , /* stop */ undefined );
            }
            // en: if a destruction sound effect is specified
            // ja: 破壊サウンドエフェクトが指定されている場合
            if ( isdefined( brkse ) )
            {
                // en: regenerate se at damaged coordinates
                // ja: ダメージを受けた座標にseを再生させる
                playsound( damagedpoint , brkse );
            }
            
            // en: break the loop
            // ja: ループを中断する
            break;
        }
    }

    // en: when deleting a model when it runs out of health
    // ja: 体力が無くなった時にモデルを削除する場合
    if ( isdefined( del ) )
    {
        wait 0.001;

        if ( isdefined( self.mountmantlemodel ) )
            self.mountmantlemodel deleteentity( );
            
        // en: delete yourself
        // ja: 自分自身を削除する
        self deleteentity( );
    }
    // en: if the model is not deleted when it runs out of health
    // ja: 体力が無くなった時にモデルを削除しない場合
    else
    {
        // en: notify termination trigger due to destruction of specified option name
        // ja: 指定のオプション名の破壊による終了トリガーを通知する
        self notify( "breaked_" + name );
        if ( isdefined( owner ) )
        {
            owner notify( "breaked_" + name );
        }
    }
}



//++++++++++++++++++++++++++++++
// en : creates the specified object at a specified multiple distance from your eye.
// ja : 自分の眼先から指定した倍数先の距離に、指定したオブジェクトを作成
//++++++++++++++++++++++++++++++
createentityobject( notice , location , length , script , model , collide , sync , angle , part , hpmin , hpmax , dmgtype , dmgfx , brktype , brkfx , dmgse , brkse , del , optname )
{
    l_listname = "deletelastobject_objectcount";
    if ( isdefined( level.lvlstat[l_listname] ) )
    {
        if ( 770 < level.lvlstat[l_listname].size )
        {
            // en: display the text "[notification] create object: object name" in the center of the screen
            // ja: 画面中央に「[通知] オブジェクトを作成 : オブジェクト名」という文章を表示する
            self showcentermessage( self.curlang , "failed" , "the number of objects is full, please reduce it." , undefined , model , undefined );
            return;
        }
    }

    // en: if the object data to be created does not exist, generate an error and do not process.
    // ja: 作成するオブジェクトデータが存在無い場合は、エラーを出して処理しない
    if ( !isdefined( model ) )
        return;


    l_objectlocation = undefined;
    // en : get the creation coordinates of the object (place it in front of you, a specified number of minutes away from you)
    // ja : 生成先距離の指定がある場合
    if ( isdefined( length ) )
        // en : get the creation coordinates of the object (place it in front of you, a specified number of minutes away from you)
        // ja : オブジェクトの生成座標を取得（正面方向に 指定数分 倍先の距離、自分の目の前にする）
        l_objectlocation = self getplayerforwardtrace( undefined , true , length , -10 );

    // en: if coordinates are specified, give priority to that information.
    // ja: 座標指定がある場合はその情報を優先する
    if ( isdefined( location ) )
        l_objectlocation = location;

    
    l_objectangle = undefined;
    
    // en: if there is an angle specification, that information takes precedence.
    // ja: 角度指定がある場合はその情報を優先する
    if ( isdefined( angle ) )
        l_objectangle = angle;
    // en: if there is not an angle specification
    // ja: 角度指定が無い場合
    else
    {
        l_objectangle = self getplayerangles( );
        if ( !isdefined( l_objectangle ) )
            l_objectangle = ( 0 , 0 , 0 );
        else
        {
            // en: if "x-axis rotation setting" is enabled
            // ja: "x軸回転設定" が 有効 になっている場合
            if ( isdefined( sync ) )    l_objectangle = ( l_objectangle[0] , l_objectangle[1] , 0 );
            // en: if "x-axis rotation setting" is disabled
            // ja: "x軸回転設定" が 無効 になっている場合
            else                        l_objectangle = ( 0 , l_objectangle[1] , 0 );
        }
    }


    // en : create an empty 3d model at the generation position
    // ja : 生成位置に空の3dモデルを作成する
    l_newobject = spawn( script + ( ( script == "weapon_" ) ? model : "" ) , l_objectlocation );
    // en : set model data
    // ja : モデルデータを設定する
    l_newobject setmodel( ( ( script != "weapon_" ) ? model : "" ) );
    
    // en: set the angle of the generated object
    // ja: 生成したオブジェクトの角度を設定する
    l_newobject.angles = l_objectangle;

    // en : set all script parts status for the specified model
    // ja : 指定したモデルに全てのスクリプト用パーツステータスを設定する
    if ( isdefined( part ) )
    {
        if ( ( model != "military_carepackage_01_juggernaut" ) &&
            ( model != "military_carepackage_01_enemy" ) &&
            ( model != "military_carepackage_01_br" ) &&
            ( model != "military_carepackage_01_friendly" ) )
            l_newobject thread setallsetscriptablepartstate( );
    }

    // en: when object collision detection is required
    // ja: オブジェクトの衝突判定が必要な場合
    if ( istrue( collide ) )
    {
        // en: set an object solid
        // ja: オブジェクトを固体設定する
        l_newobject solid( );
        l_newobject dontinterpolate( );
        l_newobject show( );
        l_newobject physics_registerforcollisioncallback( );
        l_newobject.physicson = true;
        l_newobject.unresolved_collision_kill = true;

        
        switch ( model )
        {
            case "military_crate_field_upgrade_01":
            case "military_crate_large_stackable_01_dummy":
                break;
                
            case "military_carepackage_01_enemy":
            case "military_carepackage_01_friendly":
            case "military_carepackage_01_juggernaut":
                l_newobject createmountmantlemodel( );
                break;
        }
    }
    // en: when object collision detection is not required
    // ja: オブジェクトの衝突判定が不要な場合
    else
        // en: assume an object is not solid
        // ja: オブジェクトを固体ではないとする
        l_newobject notsolid( );
    
    
    // en: set the owner of the generated object
    // ja: 生成したオブジェクトのオーナーを設定する
    l_newobject.owner = self;

    // en: if maximum health is specified
    // ja: 最大体力が指定されている場合
    if ( isdefined( hpmax ) )
    {
        if ( !isdefined( l_newobject.mountmantlemodel ) )
            l_newobject thread createdamagingsystem( hpmin , hpmax , dmgtype , dmgfx , brktype , brkfx , dmgse , brkse , del , optname , self );
        else
            l_newobject.mountmantlemodel thread createdamagingsystem( hpmin , hpmax , dmgtype , dmgfx , brktype , brkfx , dmgse , brkse , del , optname , self );
    }

    // en: add the created object to the managed list
    // ja: 作成されたオブジェクトを管理リストに追加する
    if ( isdefined( l_newobject ) )
    {
        if ( !isdefined( level.lvlstat[l_listname] ) ) level.lvlstat[l_listname] = [];
        level.lvlstat[l_listname][level.lvlstat[l_listname].size] = l_newobject;
        if ( isdefined( l_newobject.mountmantlemodel ) )
            level.lvlstat[l_listname][level.lvlstat[l_listname].size] = l_newobject.mountmantlemodel;
    }

    // en: if you need to display a message
    // ja: メッセージを表示する必要がある場合
    if ( isdefined( notice ) )
        // en: display the text "[notification] create object: object name" in the center of the screen
        // ja: 画面中央に「[通知] オブジェクトを作成 : オブジェクト名」という文章を表示する
        self showcentermessage( self.curlang , "notice" , "createobject" , undefined , model , undefined );

    return l_newobject;
}



//++++++++++++++++++++++++++++++
// en : Gives collision for care packages
// ja : ケアパッケージ用のコリジョンを付与する
//++++++++++++++++++++++++++++++
createmountmantlemodel( )
{
    
}



//++++++++++++++++++++++++++++++
// en : a generic function to remove a specified object (for world entity list interference)
// ja : 指定されたオブジェクトを削除するための汎用関数（ワールドエンティティリスト干渉用）
//++++++++++++++++++++++++++++++
deleteentity( )
{
    l_optname1 = "deletelastobject";
    l_optname2 = "_objectcount";
    l_optname3 = l_optname1 + l_optname2;

    if ( isdefined( level.lvlstat[l_optname3] ) && ( 0 < level.lvlstat[l_optname3].size ) && containsarray( level.lvlstat[l_optname3] , self ) )
    {
        level.lvlstat[l_optname3] = removearray( level.lvlstat[l_optname3] , self );
    }
    
    if ( isdefined( self.owner ) && isdefined( self.owner.optstat[l_optname3] ) && ( 0 < self.owner.optstat[l_optname3].size ) && containsarray( self.owner.optstat[l_optname3] , self ) )
    {
        self.owner.optstat[l_optname3] = removearray( self.owner.optstat[l_optname3] , self );
    }

    if ( isdefined( self.mountmantlemodel ) )
        self.mountmantlemodel deleteentity( );
    
    self delete( );
}



//++++++++++++++++++++++++++++++
// en : set all script parts status for the specified model
// ja : 指定したモデルに全てのスクリプト用パーツステータスを設定する
//++++++++++++++++++++++++++++++
setallsetscriptablepartstate( explode )
{
    if ( !isdefined( explode ) )
    {
        self setscriptablepartstate( "fake_trail"       , "on"      , 0 );
        self setscriptablepartstate( "contrails"        , "on"      , 0 );
        self setscriptablepartstate( "wing_trails"      , "on" );
        self setscriptablepartstate( "trail"            , "active"  , 1 );
        self setscriptablepartstate( "trail"            , "neutral" , 1 );
        self setscriptablepartstate( "smoke"            , "on"      , 0 );
        self setscriptablepartstate( "cloud_contrail"   , "base" );
        self setscriptablepartstate( "fast_contrail"    , "base" );
        self setscriptablepartstate( "engine_smoke"     , "base"    , 0 );
        self setscriptablepartstate( "fx"               , "trails"  , 0 );

        self setscriptablepartstate( "lights"           , "active"  , 1 );
        self setscriptablepartstate( "lights"           , "on" );
        self setscriptablepartstate( "lights2"          , "on"      , 0 );
        self setscriptablepartstate( "blinking_lights"  , "on"      , 0 );
        self setscriptablepartstate( "interior_light"   , "on"      , 0 );
        self setscriptablepartstate( "tail_light"       , "red" );
        self setscriptablepartstate( "cockpit_light"    , "on" );
        self setscriptablepartstate( "infil_lights"     , "on" );
        self setscriptablepartstate( "light"            , "light_on" );
        self setscriptablepartstate( "pulse"            , "on"      , 0 );
        self setscriptablepartstate( "glint"            , "on"      , 0 );

        self setscriptablepartstate( "main_thruster"    , "on"      , 0 );
        self setscriptablepartstate( "sub_thruster"     , "on"      , 0 );
        self setscriptablepartstate( "warhead_thruster" , "on"      , 0 );
        self setscriptablepartstate( "thrusters"        , "active"  , 0 );
        self setscriptablepartstate( "engine"           , "on"      , 0 );
        self setscriptablepartstate( "burning"          , "flareup" , 0 );
        self setscriptablepartstate( "exhaustfx"        , "active" );
        self setscriptablepartstate( "propeller"        , "spin_up" , 0 );
        self setscriptablepartstate( "booster_start"    , "enabled" , 0 );
        self setscriptablepartstate( "booster"          , "enabled" , 0 );
        self setscriptablepartstate( "speedBoost"       , "on" );

        self setscriptablepartstate( "bodyfx"           , "on"      , 0 );
        self setscriptablepartstate( "flyby"            , "on"      , 0 );
        self setscriptablepartstate( "anims"            , "capture" , 0 );
        self setscriptablepartstate( "capture"          , "start"   , 0 );
        self setscriptablepartstate( "rotors"           , "on"      , 0 );
        self setscriptablepartstate( "looping_wave"     , "on"      , 0 );
        self setscriptablepartstate( "launch"           , "active"  , 0 );
        self setscriptablepartstate( "launch"           , "on"      , 0 );
        self setscriptablepartstate( "effects"          , "active"  , 0 );
        self setscriptablepartstate( "wind"             , "50"      , 0 );
        self setscriptablepartstate( "base"             , "active"  , 0 );
        self setscriptablepartstate( "fx"               , "base" );
        self setscriptablepartstate( "stability"        , "stable"  , 1 );
    }
    else
    {
        self setscriptablepartstate( "stuck", "active", 0 );
        self setscriptablepartstate( "beacon", "active", 0 );
        self setscriptablepartstate( "effects" , "explode" , 0 );
        self setscriptablepartstate( "launch" , "off" , 0 );
        self setscriptablepartstate( "explode" , "active" , 0 );
        self setscriptablepartstate( "explode" , "on" , 0 );
        self setscriptablepartstate( "impact" , "on" , 0 );
        self setscriptablepartstate( "flare", "on", 0 );
        self setscriptablepartstate( "ground_explosion", "on", 0 );
        self setscriptablepartstate( "air_explosion", "on", 0 );
    }
}



//++++++++++++++++++++++++++++++
// en : generates a bullet of the specified type
// ja : 指定した種類の弾丸を生成する
//++++++++++++++++++++++++++++++
createmagicbullet( owner , weaponid , pstart , pend , useanim )
{
    // en: generates the specified bullet type and flies it from the start coordinate to the end coordinate
    // ja: 指定した弾の種類を生成し、開始座標から終了座標に向けて飛ばす
    l_bullet = magicalbullet( createweapondatatype2( weaponid ) , pstart, pend , owner );
    //if ( !isdefined( useanim ) && isdefined( l_bullet ) )
    //    l_bullet thread onbulletanimationtrigger( weaponid );
    return l_bullet;
}



//++++++++++++++++++++++++++++++
// en : general function to change the amount of movement of the suboption "tracelength" of the specified function
// ja : 指定した機能のサブオプション "tracelength" の移動量を変更する汎用関数
//++++++++++++++++++++++++++++++
changetracesize( name , param , func , notice )
{
    // en: define an array and perform an operation that changes the current parameter from within the array
    // ja: 配列を定義して、配列内から現在のパラメーターを変更する処理を実行する
    l_array = [];
    l_array[l_array.size] = 1000000;
    l_array[l_array.size] = 100000;
    l_array[l_array.size] = 50000;
    l_array[l_array.size] = 10000;
    l_array[l_array.size] = 5000;
    l_array[l_array.size] = 2500;
    l_array[l_array.size] = 2000;
    l_array[l_array.size] = 1500;
    l_array[l_array.size] = 1000;
    l_array[l_array.size] = 750;
    l_array[l_array.size] = 500;
    l_array[l_array.size] = 400;
    l_array[l_array.size] = 300;
    l_array[l_array.size] = 250;
    l_array[l_array.size] = 200;
    l_array[l_array.size] = 150;
    l_array[l_array.size] = 100;
    l_array[l_array.size] = 75;
    l_array[l_array.size] = 50;

    self changeselfparameter( name , param , undefined , func , l_array , true , undefined , undefined );
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : Get list / ID
// ja : リスト / ID 取得
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : get the corresponding weapon id in this game from the specified weapon name.
// ja : 指定した武器名からこのゲーム中に相当する武器idを取得する
//++++++++++++++++++++++++++++++
getbulletid( name )
{
    switch ( name )
    {
        case "rpg7":            return "iw9_la_rpapa7_sp";
        case "lockonmissile1":  return "iw9_la_juliet_sp";
        case "nolockmissile1":  return "iw9_la_kgolf_sp";
        case "nolockmissile2":  return "iw9_la_gromeo_sp";
        case "grenadelauncher": return "iw9_la_mike32_sp";
        case "nuke":            return "nuke_sp";
        case "nuke_multi":      return "nuke_multi_sp";
        case "ksgrenade1":      return "toma_proj_sp";
        case "flashgrenade":    return "flash_grenade_sp";
        case "ksmissile1":      return "hover_jet_proj_sp";
        case "ksmissile2":      return "chopper_gunner_proj_sp";
        case "ksmissile3":      return "fuelstrike_proj_sp";
        case "ksmissile4":      return "cruise_proj_sp";
        case "ac130_105mm":     return "gunship_hellfire_sp";
        case "ac130_40mm":      return "gunship_40mm_sp";
        case "ac130_25mm":      return "gunship_25mm_sp";
        case "frag_grenade":    return "frag_grenade_sp";
        default:                return "iw9_la_rpapa7_sp";
    }
}



//++++++++++++++++++++++++++++++
// en : get ammo list
// ja : 弾薬リストを取得する
//++++++++++++++++++++++++++++++
getbulletlist( type )
{
    switch ( type )
    {
        case "allbullet":       return level.lvlstat["wplist_allbt"];
        case "allmissile":      return level.lvlstat["wplist_allms"];
        case "standardmissile": return level.lvlstat["wplist_exp"];
        case "specialmissile":  return level.lvlstat["wplist_ks"];
        case "standardgrenade": return level.lvlstat["wplist_exp"];
        case "allgrenade":      return level.lvlstat["wplist_stdgr"];
        default:                return level.lvlstat["wplist_allbt"];
    }
}



//++++++++++++++++++++++++++++++
// en : get standard model list
// ja : 標準モデルリストを取得する
//++++++++++++++++++++++++++++++
getstandardmodellist( )
{
    return level.lvlstat["modellistall"];
}



//++++++++++++++++++++++++++++++
// en : get standard model list
// ja : 標準乗り物モデルリストを取得する
//++++++++++++++++++++++++++++++
getstandardvehiclemodellist( )
{
    return level.lvlstat["modellistvehicles"];
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : Other various mods
// ja : その他各種 Mod
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : change the background animation of the mod menu
// ja : モッドメニューの背景アニメーションを変更する
//++++++++++++++++++++++++++++++
onfmodmenubackgroundanimation( )
{
    // en : create or destroy a "switchbackgroundanimation" variable
    // ja : "switchbackgroundanimation" 変数の作成か破棄を行う
    self switchonfselffunction(
        /* optname */       "switchbackgroundanimation" ,
        /* optfunc */       ::emptyfunction ,
        /* message */       undefined ,
        /* optarg1 */       undefined ,
        /* optarg2 */       undefined ,
        /* optarg3 */       undefined ,
        /* optarg4 */       undefined ,
        /* optarg5 */       undefined ,
        /* optarg6 */       undefined ,
        /* optarg7 */       undefined ,
        /* weaponid */      undefined ,
        /* inprojectile */  undefined ,
        /* onlygroup */     undefined ,
        /* attachmentid */  undefined ,
        /* camoid */        undefined ,
        /* camogroup */     undefined ,
        /* dualmode */      undefined
        );
}



//++++++++++++++++++++++++++++++
// en : teleport all players to your location
// ja : 全プレイヤーを自分の場所にテレポートさせる
//++++++++++++++++++++++++++++++
execmoveelemto( mode , amount )
{
    switch ( mode )
    {
        case "x":
            self.modsystem.vl_xcustommenu += amount;
            break;
            
        case "y":
            self.modsystem.vl_ycustommenu += amount;
            break;
    }
    
    // en: suppose the mod menu is opened
    // ja: モッドメニューが開かれたとする
    // en: In the case of a Mod Menu using Custom Hud Text
    // ja: Custom Hud Textを使用したMod Menuの場合
    if ( !isdefined( self.optstat["iprintlnmenu"] ) && self.modsystem.menuactive )
    {
        l_txsize = level.moddef.customtextlength;

        switch ( mode )
        {
            case "x":
                self.modsystem.menuui["japw"].x             += amount;
                self.modsystem.menuui["japr"].x             += amount;
                self.modsystem.menuui["japrfix1"].x         += amount;
                self.modsystem.menuui["japrfix2"].x         += amount;
                self.modsystem.menuui["japwfix"].x          += amount;
                self.modsystem.menuui["custom_bg1"].x       += amount;
                self.modsystem.menuui["custom_bg2"].x       += amount;
                self.modsystem.menuui["custom_inline_1"].x  += amount;
                self.modsystem.menuui["custom_outline_1"].x += amount;
                self.modsystem.menuui["custom_outline_2"].x += amount;
                self.modsystem.menuui["custom_outline_3"].x += amount;
                self.modsystem.menuui["custom_outline_4"].x += amount;
                self.modsystem.custommenutitle.x            += amount;
                self.modsystem.custommenudescription.x      += amount;
                self.modsystem.custommenucontrol.x          += amount;
                for ( i = 0; i < l_txsize; i++ )
                    self.modsystem.custommenutext[i].x      += amount;
                break;
                
            case "y":
                self.modsystem.menuui["japw"].y             += amount;
                self.modsystem.menuui["japr"].y             += amount;
                self.modsystem.menuui["japrfix1"].y         += amount;
                self.modsystem.menuui["japrfix2"].y         += amount;
                self.modsystem.menuui["japwfix"].y          += amount;
                self.modsystem.menuui["custom_bg1"].y       += amount;
                self.modsystem.menuui["custom_bg2"].y       += amount;
                self.modsystem.menuui["custom_inline_1"].y  += amount;
                self.modsystem.menuui["custom_outline_1"].y += amount;
                self.modsystem.menuui["custom_outline_2"].y += amount;
                self.modsystem.menuui["custom_outline_3"].y += amount;
                self.modsystem.menuui["custom_outline_4"].y += amount;
                self.modsystem.custommenutitle.y            += amount;
                self.modsystem.custommenudescription.y      += amount;
                self.modsystem.custommenucontrol.y          += amount;
                for ( i = 0; i < l_txsize; i++ )
                    self.modsystem.custommenutext[i].y      += amount;
                break;
        }
    }

    // en: display the specified text in the center of the screen
    // ja: 画面中央に指定の文章を表示する
    self showcentermessage( self.curlang , "notice" , ( ( mode == "x" ) ? "moveelemx" : "moveelemy" ) , undefined , ( ( mode == "x" ) ? self.modsystem.vl_xcustommenu : self.modsystem.vl_ycustommenu ) , undefined );
}



//++++++++++++++++++++++++++++++
// en : teleport all players to your location
// ja : 全プレイヤーを自分の場所にテレポートさせる
//++++++++++++++++++++++++++++++
execiprintlnmenutoleft( )
{
    self execmoveelemto( "x" , -5 );
}



//++++++++++++++++++++++++++++++
// en : teleport all players to your location
// ja : 全プレイヤーを自分の場所にテレポートさせる
//++++++++++++++++++++++++++++++
execiprintlnmenutoright( )
{
    self execmoveelemto( "x" , 5 );
}



//++++++++++++++++++++++++++++++
// en : teleport all players to your location
// ja : 全プレイヤーを自分の場所にテレポートさせる
//++++++++++++++++++++++++++++++
execiprintlnmenutoup( )
{
    self execmoveelemto( "y" , -5 );
}



//++++++++++++++++++++++++++++++
// en : teleport all players to your location
// ja : 全プレイヤーを自分の場所にテレポートさせる
//++++++++++++++++++++++++++++++
execiprintlnmenutodown( )
{
    self execmoveelemto( "y" , 5 );
}



//++++++++++++++++++++++++++++++
// en : delete the last object created with the function "createentityobject"
// ja : 機能 "createentityobject" で作成したオブジェクトの内、最後のオブジェクトを削除する
//++++++++++++++++++++++++++++++
execdeletelastobject( )
{
    l_optname1 = "deletelastobject";
    l_optname2 = "_objectcount";
    l_optname3 = l_optname1 + l_optname2;

    if ( !isdefined( level.lvlstat[l_optname3] ) )  return;
    if ( level.lvlstat[l_optname3].size <= 0 )      return;
    
    l_num = level.lvlstat[l_optname3].size - 1;
    
    if ( isdefined( level.lvlstat[l_optname3][l_num] ) )
        level.lvlstat[l_optname3][l_num] deleteentity( );
    
    level.lvlstat[l_optname3][l_num] = undefined;
    
    // en: display the text "[notification] delete object: object name" in the center of the screen
    // ja: 画面中央に「[通知] オブジェクト削除 : オブジェクト名」という文章を表示する
    self showcentermessage( self.curlang , "notice" , l_optname1 , undefined , l_num , undefined );
}



forcemissionclear( )
{
    // en: close (hide) the mod menu
    // ja: モッドメニューを閉じる（非表示にする）
    self modmenuclose( 0.2 );
    wait 0.2;
    overlay = scripts\sp\hud_util::create_client_overlay( "black", 0 );
    overlay fadeovertime( 1 );
    overlay.alpha = 1.0;
    wait 1;
    scripts\engine\sp\utility::nextmission();
}



//++++++++++++++++++++++++++++++
// en : switch the enable/disable state of the function "superjump"
// ja : 機能 "superjump" の有効/無効を切り替える
//++++++++++++++++++++++++++++++
onfsuperjump( )
{
    // en : execute execsuperjump( ) or exit depending on the existence state of the "superjump" variable
    // ja : "superjump" 変数の存在状態に合わせて、 execsuperjump( )関数 を実行するか終了する
    self switchonfselffunction(
        /* optname */                   "superjump" ,
        /* optfunc */                   ::execloopfunction ,
        /* message */                   undefined ,
        /* optarg1 */   /* optname */   "superjump" ,
        /* optarg2 */   /* optfunc */   ::execsuperjump ,
        /* optarg3 */   /* looptime */  0.05
        );
}



//++++++++++++++++++++++++++++++
// en : processing during execution of the function "superjump"
// ja : 機能 "superjump" の実行中の処理
//++++++++++++++++++++++++++++++
execsuperjump( optname , procstage )
{
    // en: when the "jump" button is pressed
    // ja: 「ジャンプ」ボタンが押されたら
    if ( self getkeycodepressed( "buttonjump" , "buttonjump" ) == false ) return;

    // en : move the angular velocity directly upwards
    // ja : 角速度を真上に向けて移動させる
    self setvelocity( self getvelocity( ) + ( 0 , 0 , 2000 ) );

    wait 0.5;

    l_velocity = undefined;
    l_pos = undefined;
    l_dist = undefined;
    while ( self isonground( ) == false )
    {
        // en: get movement speed
        // ja: 移動速度を取得
        l_velocity = self getvelocity( );

        // en: obtain the coordinates directly below and measure the distance to the ground
        // ja: 真下の座標を取得して、地面との距離を計測
        l_pos = tracebullet( self.origin , self.origin + ( 0 , 0 , -100000 ) , 0 , undefined );
        l_dist = distance( self.origin , l_pos["position"] );

        //self iprintlnbold( "vel = " + l_velocity[2] );
        //self iprintlnbold( "dist / vel (" + l_dist + " / " + l_velocity[2] + ")" );
        
        // en: if the falling speed exceeds the jump speed or is close to the ground, the falling speed is cancelled out.
        // ja: 落下速度がジャンプ時の速度を超えるか、もしくは地面に近い場合、落下速度を打ち消す
        if ( l_velocity[2] < -2000 )
            self setvelocity( l_velocity + ( 0 , 0 , ( l_velocity[2] * -1 ) ) );
        if ( l_dist < 100 )
        {
            self setvelocity( l_velocity + ( 0 , 0 , ( l_velocity[2] * -1 ) ) );
            wait 0.5;
        }
        
        wait 0.001;
    }
}



//++++++++++++++++++++++++++++++
// en : switch the enable/disable state of the function "speedhack"
// ja : 機能 "speedhack" の有効/無効を切り替える
//++++++++++++++++++++++++++++++
onfspeedhack( )
{
    // en : execute execspeedhack( ) or exit depending on the existence state of the "speedhack" variable
    // ja : "speedhack" 変数の存在状態に合わせて、 execspeedhack( )関数 を実行するか終了する
    self switchonfselffunction(
        /* optname */                   "speedhack" ,
        /* optfunc */                   ::execloopfunction ,
        /* message */                   undefined ,
        /* optarg1 */   /* optname */   "speedhack" ,
        /* optarg2 */   /* optfunc */   ::execspeedhack ,
        /* optarg3 */   /* looptime */  1
        );
}



//++++++++++++++++++++++++++++++
// en : processing during execution of the function "speedhack"
// ja : 機能 "speedhack" の実行中の処理
//++++++++++++++++++++++++++++++
execspeedhack( optname , procstage )
{
    switch ( procstage )
    {
        // en: initialization process
        // ja: 初期化処理
        case 0:
            //  // en : if duplicate functions are activated, disable them
            //  // ja : 重複している機能が起動している場合、無効化させる
            //  self checkduplicatefunction( "movementspeed1_25x" , _encstr_8C912D2646BB4B9BE447FA10B347B193926F1DAB1AA20728DA6B7148DF2D89E17BD21D20725ADB888F3FB01ADF6B81::execmovementspeed1_25x );
            //  self checkduplicatefunction( "movementspeed" , _encstr_8C912D2646BB4B9BE447FA10B347B193926F1DAB1AA20728DA6B7148DF2D89E17BD21D20725ADB888F3FB01ADF6B81::execchangemovementspeed );
            break;
            
        // en: running process
        // ja: 実行中処理
        case 1:
            // en: set your movement speed to the currently set speed
            // ja: 自分の移動速度を設定中の速度にする
            self setmovespeedscale( 5 );
            break;
            
        // en: end processing
        // ja: 終了処理
        case 2:
            // en: return your movement speed to default
            // ja: 自分の移動速度をデフォルトに戻す
            self setmovespeedscale( 1 );
            break;
    }
}



//++++++++++++++++++++++++++++++
// en : switch the enable/disable state of the function "bindnoclip"
// ja : 機能 "bindnoclip" の有効/無効を切り替える
//++++++++++++++++++++++++++++++
onfbindnoclip( )
{
    // en : execute execbindnoclip( ) or exit depending on the existence state of the "bindnoclip" variable
    // ja : "bindnoclip" 変数の存在状態に合わせて、 execbindnoclip( ) を実行するか終了する
    self switchonfselffunction(
        /* optname */                   "bindnoclip" ,
        /* optfunc */                   ::execloopfunction ,
        /* message */                   undefined ,
        /* optarg1 */   /* optname */   "bindnoclip" ,
        /* optarg2 */   /* optfunc */   ::execbindnoclip ,
        /* optarg3 */   /* looptime */  0.05 ,
        /* optarg4 */                   undefined ,
        /* optarg5 */                   undefined ,
        /* optarg6 */                   undefined ,
        /* optarg7 */                   undefined ,
        /* weaponid */                  undefined ,
        /* inprojectile */              undefined ,
        /* onlygroup */                 undefined ,
        /* attachmentid */              undefined ,
        /* camoid */                    undefined ,
        /* camogroup */                 undefined ,
        /* dualmode */                  undefined
        );
}



//++++++++++++++++++++++++++++++
// en : processing during execution of the function "bindnoclip"
// ja : 機能 "bindnoclip" の実行中の処理
//++++++++++++++++++++++++++++++
execbindnoclip( optname , procstage )
{
    switch ( procstage )
    {
        // en: initialization process
        // ja: 初期化処理
        case 0:
            break;
            
        // en: running process
        // ja: 実行中処理
        case 1:
        lv_unverified = 0;

        // en: if the "tactical throw" button and "melee attack" button are pressed at the same time
        // ja: "タクティカル投球" ボタンと、「近接攻撃」ボタンが同時に押されたら
        if ( ( self getkeycodepressed( "buttontactical" , "buttontactical" ) && self getkeycodepressed( "buttonmelee" , "buttonmelee" ) ) )
        {
            // en: if the object used for flight processing has not been created yet
            // ja: 飛行処理に使うオブジェクトがまだ生成されてない場合
            if ( !isdefined( self.optstat[optname + "linkobject"] ) )
            {
                // en: create a transparent object used for flight processing with your own coordinates and angle
                // ja: 飛行処理に使う透明なオブジェクトを、自分の座標、角度で作成する
                self.optstat[optname + "linkobject"] = self createentityobject(
                    /* notice */ undefined , /* spawnlocation */ self.origin , /* spawnlength */ undefined , /* script */ "script_origin" , /* objectname */ "" ,
                    /* objectcollide */ undefined , /* anglesync */ undefined , /* objectangle */ self.angles
                    );
                
                // en: link (sync) yourself to the object you created
                // ja: 自分を作成したオブジェクトにリンク（同期）する
                self playerlinkto( self.optstat[optname + "linkobject"] , undefined , 0 );

                // en: display the specified text in the center of the screen
                // ja: 画面中央に指定の文章を表示する
                self showcentermessage( self.curlang , "enabled" , "bindnoclipdiscription" , undefined , undefined , undefined );
            }
            // en: if the object used for flight processing has already been generated
            // ja: 飛行処理に使うオブジェクトが生成済みの場合
            else
            {
                // en: unlink (synchronize) yourself from the created object
                // ja: 作成したオブジェクトから自分のリンク（同期）を解除する
                self unlink( );
                
                // en: delete the created object
                // ja: 作成したオブジェクトを削除する
                self.optstat[optname + "linkobject"] deleteentity( );
                self.optstat[optname + "linkobject"] = undefined;
                
                // en: display the specified text in the center of the screen
                // ja: 画面中央に指定の文章を表示する
                self showcentermessage( self.curlang , "disabled" , "bindnoclip" , undefined , undefined , undefined );
            }

            wait 0.3;
        }

        // en: if the object used for flight processing has already been generated
        // ja: 飛行処理に使うオブジェクトが生成済みの場合
        if ( isdefined( self.optstat[optname + "linkobject"] ) )
        {
            // en: if the player is in a vehicle, remember the vehicle
            // ja: プレイヤーが乗り物に乗っている場合、乗り物を記憶する
            if ( isridingvehicle( ) )
            {
                self.optstat[optname].curvehicle = getnowvehicle( );
            }

            self.optstat[optname + "linkobject"].angles = self getplayerangles( );

            l_angles = self getplayerangles( );
            l_forward = anglestoforward( l_angles );
            l_left = anglestoforward( l_angles - ( 0 , 90 , 0 ) );
            l_top = anglestoforward( l_angles - ( 90 , 0 , 0 ) );
            l_movement = self getnormalizedmovement( );
            l_zscale = 0;
            
            // en: when the "jump" button is pressed
            // ja: 「ジャンプ」ボタンが押されたら
            if ( self getkeycodepressed( "buttonjump" , "buttonjump"  ) )
            {
                // en: set the amount of movement in the +z axis direction
                // ja: +z軸方向への移動量を設定する
                l_zscale = 1;
            }
            // en: when the "crouch/prone" button is pressed
            // ja: 「しゃがみ・伏せ」ボタンが押されたら
            else if ( self getkeycodepressed( "buttonstance" , "buttonstance"  ) )
            {
                // en: set the amount of movement in the -z axis direction
                // ja: -z軸方向への移動量を設定する
                l_zscale = -1;
            }

            // en: when the "run/hold your breath" button is pressed
            // ja: 「走る・息止め」ボタンが押されたら
            if ( self getkeycodepressed( "buttonsprint" , "buttonsprint" ) )
            {
                // en: when the "tacticalthrow" button is pressed
                // ja: "タクティカル投球" ボタンが押されている間
                if ( self getkeycodepressed( "buttontactical" , "buttontactical"  ) )
                {
                    l_vector = ( l_zscale * l_top ) + ( l_movement[0] * l_forward ) + ( l_movement[1] * ( l_left[0] , l_left[1] , 0 ) );
                    l_scale = vectorscale( l_vector , 5000 );
                    self.optstat[optname + "linkobject"].origin = self.origin + l_scale;
                }
                // en: when the "tacticalthrow" button is not pressed
                // ja: "タクティカル投球" ボタンが押されていない間
                else
                {
                    l_vector = ( l_zscale * l_top ) + ( l_movement[0] * l_forward ) + ( l_movement[1] * ( l_left[0] , l_left[1] , 0 ) );
                    l_scale = vectorscale( l_vector , 350 );
                    self.optstat[optname + "linkobject"].origin = self.origin + l_scale;
                }
            }
            // en: when neither button is pressed
            // ja: どちらのボタンも押されていない時
            else
            {
                l_vector = ( l_zscale * l_top ) + ( l_movement[0] * l_forward ) + ( l_movement[1] * ( l_left[0] , l_left[1] , 0 ) );
                l_scale = vectorscale( l_vector , 30 );
                self.optstat[optname + "linkobject"].origin = self.origin + l_scale;
            }

            // en: if a vehicle is memorized, move the vehicle to the noclip position as well.
            // ja: 乗り物が記憶されている場合、乗り物も一緒にnoclip位置に移動させる
            if ( isdefined( self.optstat[optname].curvehicle ) )
            {
                self.optstat[optname].curvehicle.origin = self.optstat[optname + "linkobject"].origin;
                self.optstat[optname].curvehicle.angles = self.optstat[optname + "linkobject"].angles;
            }
        }
            break;
            
        // en: end processing
        // ja: 終了処理
        case 2:
            // en: if the object used for flight processing has already been generated
            // ja: 飛行処理に使うオブジェクトが生成済みの場合
            if ( isdefined( self.optstat[optname + "linkobject"] ) )
            {
                // en: unlink (synchronize) yourself from the created object
                // ja: 作成したオブジェクトから自分のリンク（同期）を解除する
                self unlink( );
                
                // en: delete the created object
                // ja: 作成したオブジェクトを削除する
                self.optstat[optname + "linkobject"] deleteentity( );
                self.optstat[optname + "linkobject"] = undefined;
                self.optstat[optname].curvehicle = undefined;
            }
            break;
    }
}



//++++++++++++++++++++++++++++++
// en : switch the enable/disable state of the function "modded bullet"
// ja : 機能「modded bullet」の有効/無効を切り替える
//++++++++++++++++++++++++++++++
onfmoddedbullets( )
{
    // en : execute execmoddedbullets( ) or exit depending on the existence state of the "moddedbullets" variable
    // ja : "moddedbullets" 変数の存在状態に合わせて、execmoddedbullets( ) を実行するか終了する
    self switchonfselffunction(
        /* optname */                   "moddedbullets" ,
        /* optfunc */                   ::execloopfunction ,
        /* message */                   undefined ,
        /* optarg1 */   /* optname */   "moddedbullets" ,
        /* optarg2 */   /* optfunc */   ::execmoddedbullets ,
        /* optarg3 */   /* looptime */  0.05 ,
        /* optarg4 */                   undefined ,
        /* optarg5 */                   undefined ,
        /* optarg6 */                   undefined ,
        /* optarg7 */                   undefined ,
        /* weaponid */                  undefined ,
        /* inprojectile */              undefined ,
        /* onlygroup */                 undefined ,
        /* attachmentid */              undefined ,
        /* camoid */                    undefined ,
        /* camogroup */                 undefined ,
        /* dualmode */                  undefined
        );
}



//++++++++++++++++++++++++++++++
// en : processing during execution of the function "modded bullet"
// ja : 機能「改造弾」の実行中の処理
//++++++++++++++++++++++++++++++
execmoddedbullets( optname , procstage )
{
    switch ( procstage )
    {
        // en: initialization process
        // ja: 初期化処理
        case 0:
            // en: if the "bullettype" variable does not exist
            // ja: 「bullettype」変数が存在しない場合
            if ( !isdefined( self.optstat[optname].moddata["bullettype"] ) )
            {
                self.optstat[optname].moddata["bullettype"] = "iw9_la_rpapa7_sp";
                // en : pick a weapon id randomly from the array and set it
                // ja : 配列内からランダムに 武器id を取り出して設定する
                // self changebulletstype( undefined , true );
            }
            break;
            
        // en: running process
        // ja: 実行中処理
        case 1:
            // en: when waiting for a gun firing event to occur using the waittill function
            // ja: waittill 関数による 銃発射 イベントの発生を待機する場合
            if ( isdefined( self.optstat[optname].moddata["moddedbulletsfiretrigger"] ) )
            {
                self waittill( "weapon_fired" );
            }
            // en: when not using the gun firing event using the waittill function
            // ja: waittill 関数による 銃発射 イベントを利用しない場合
            else
            {
                // en: do not proceed to the next process while the "attack" button is not pressed.
                // ja: "攻撃" ボタンが押されていない間は、次の処理に進まない
                if ( self getkeycodepressed( "buttonattack" , "buttonattack" ) == false ) { return; }
            }

            // en: get eye location
            // ja: 目の座標を取得
            l_eyelocation = self geteye( );
            // en: get front direction
            // ja: 正面方向を取得
            l_forwardangle = anglestoforward( self getplayerangles( ) );
            // en: get the bullet generation start coordinates (shift about 50 points from the coordinates of your eyes in the direction the muzzle is facing)
            // ja: 弾の生成開始座標を取得（自分の目の座標から、銃口が向いてる方向に 50 程度ずらす）
            l_startlocation = ( l_eyelocation + ( l_forwardangle * 50 ) );
            // en: get the bullet generation start coordinates (shift about 1000000 points from the coordinates of your eyes in the direction the muzzle is facing)
            // ja: 弾の生成開始座標を取得（自分の目の座標から、銃口が向いてる方向に 1000000 程度ずらす）
            l_endlocation = ( l_eyelocation + ( l_forwardangle * 1000000 ) );
            
            // en: generates the specified bullet type and flies it from the start coordinate to the end coordinate (you are the owner of the bullet)
            // ja: 指定した弾の種類を生成し、開始座標から終了座標に向けて飛ばす（弾の所有者は自分自身）
            createmagicbullet( self , self.optstat[optname].moddata["bullettype"] , l_startlocation , l_endlocation );
            wait 0.05;
            break;
            
        // en: end processing
        // ja: 終了処理
        case 2:
            // en : finish the general animation process that is executed when a special missile is launched.
            // ja : 特殊なミサイルが発射された時に実行する汎用アニメーション処理を終了する
            self notify( "finalize_" + optname );
            break;
    }
}



//++++++++++++++++++++++++++++++
// en : change the type of ammunition for the function "modded bullets"
// ja : 機能　"modded bullets" の弾薬の種類を変更する 
//++++++++++++++++++++++++++++++
switchbulletstype( )
{
    // en : change the type of ammunition for the function "modded bullet" (with notification)
    // ja : 機能　"modded bullet" の弾薬の種類を変更する （通知有り）
    self changebulletstype( true , undefined );
}



//++++++++++++++++++++++++++++++
// en : change the type of ammunition for the function "modded bullet" (with or without notification specified)
// ja : 機能　"modded bullet" の弾薬の種類を変更する （通知の有無の指定有り）
//++++++++++++++++++++++++++++++
changebulletstype( notice , random )
{
    // en : get ammo list
    // ja : 弾薬リストを取得する
    l_array = getbulletlist( "allbullet" );

    self changeselfparameter( "moddedbullets" , "bullettype" , undefined , ::onfmoddedbullets , l_array , notice , undefined , random );
}



//++++++++++++++++++++++++++++++
// en : switch the enable/disable state of the function "godmode"
// ja : 機能「無敵」の有効/無効を切り替える
//++++++++++++++++++++++++++++++
onfgodmode( )
{
    // en : execute execgodmode( ) or exit depending on the existence state of the "godmode" variable
    // ja : 「godmode」変数の存在状態に合わせて、execgodmode( ) を実行するか終了する
    self switchonfselffunction(
        /* optname */                   "godmode" ,
        /* optfunc */                   ::execloopfunction ,
        /* message */                   undefined ,
        /* optarg1 */   /* optname */   "godmode" ,
        /* optarg2 */   /* optfunc */   ::execgodmode ,
        /* optarg3 */   /* looptime */  1 ,
        /* optarg4 */                   undefined ,
        /* optarg5 */                   undefined ,
        /* optarg6 */                   undefined ,
        /* optarg7 */                   undefined ,
        /* weaponid */                  undefined ,
        /* inprojectile */              undefined ,
        /* onlygroup */                 undefined ,
        /* attachmentid */              undefined ,
        /* camoid */                    undefined ,
        /* camogroup */                 undefined ,
        /* dualmode */                  undefined
        );
}



//++++++++++++++++++++++++++++++
// en : processing during execution of the function "godmode"
// ja : 機能 "無敵" の実行中の処理
//++++++++++++++++++++++++++++++
execgodmode( optname , procstage )
{
    switch ( procstage )
    {
        // en: initialization process
        // ja: 初期化処理
        case 0:
            // en : if duplicate functions are activated, disable them
            // ja : 重複している機能が起動している場合、無効化させる
            //self checkduplicatefunction( "demigod" , ::execdemigod );
            break;
            
        // en: running process
        // ja: 実行中処理
        case 1:
            self enableinvulnerability();
            // en: if your current health is less than 10,000
            // ja: 現在の体力が 10000 を下回ったら
            if ( self.health < 10000 )
            {
                // en: increase health to 99999999
                // ja: 体力を 99999999 に上げる
                self.maxhealth  = 99999999;
                self.health     = self.maxhealth;
            }
            break;
            
        // en: end processing
        // ja: 終了処理
        case 2:
            self disableinvulnerability();
            // en: return to normal strength
            // ja: 通常の体力に戻す
            self.maxhealth  = 100;
            self.health     = self.maxhealth;
            break;
    }
}



//++++++++++++++++++++++++++++++
// en : switch the enable/disable state of the function "infinity ammo"
// ja : 機能「弾無限」の有効/無効を切り替える
//++++++++++++++++++++++++++++++
onfinfinityammo( )
{
    // en : execute execinfinityammo( ) or exit depending on the existence state of the "infinityammo" variable
    // ja : 「infammo」変数の存在状態に合わせて、execinfinityammo( ) を実行するか終了する
    self switchonfselffunction(
        /* optname */                   "infinityammo" ,
        /* optfunc */                   ::execloopfunction ,
        /* message */                   undefined ,
        /* optarg1 */   /* optname */   "infinityammo" ,
        /* optarg2 */   /* optfunc */   ::execinfinityammo ,
        /* optarg3 */   /* looptime */  0.05 ,
        /* optarg4 */                   undefined ,
        /* optarg5 */                   undefined ,
        /* optarg6 */                   undefined ,
        /* optarg7 */                   undefined ,
        /* weaponid */                  undefined ,
        /* inprojectile */              undefined ,
        /* onlygroup */                 undefined ,
        /* attachmentid */              undefined ,
        /* camoid */                    undefined ,
        /* camogroup */                 undefined ,
        /* dualmode */                  undefined
        );
}



//++++++++++++++++++++++++++++++
// en : processing during execution of the function "infinity ammo"
// ja : 機能「弾無限」の実行中の処理
//++++++++++++++++++++++++++++++
execinfinityammo( optname , procstage )
{
    switch ( procstage )
    {
        // en: initialization process
        // ja: 初期化処理
        case 0:
            // en : if duplicate functions are activated, disable them
            // ja : 重複している機能が起動している場合、無効化させる
            //self checkduplicatefunction( "infinityremainingammo" , ::execinfinityremainingammo );
            break;
            
        // en: running process
        // ja: 実行中処理
        case 1:
            // en: get information about the weapon you currently have
            // ja: 今持っている武器の情報を取得
            l_currentweapon = self getcurrentweapon( );

            // en: if you have any weapons
            // ja: 武器を何か持っている場合
            if ( ( l_currentweapon != "none" ) && isdefined( l_currentweapon.clipsize ) && ( 0 < l_currentweapon.clipsize ) )
            {
                // en: set the number of remaining bullets to the maximum number of bullets for that weapon.
                // ja: 残弾数をその武器の最大弾数にする
                //l_maxammo = weaponmaxammo( l_currentweapon );
                self setweaponammostock( l_currentweapon , 9999 );
                
                // en: set the number of bullets to the maximum number of bullets for that weapon.
                // ja: 装弾数をその武器の最大弾数にする
                //l_maxclip = weaponclipsize( l_currentweapon );
                //self setweaponammoclip( l_currentweapon , 9999 , "left" );
                //self setweaponammoclip( l_currentweapon , 9999 , "right" );
                self setweaponammoclip( l_currentweapon , 9999 );

                // en: gives maximum ammo for that weapon
                // ja: その武器の最大弾薬数を与える
                self givemaxammo( l_currentweapon );
            }

            l_result = self scripts\engine\utility::waittill_any_return( "weapon_fired" , "reload" , "grenade_fire" , "missile_fire" , "weapon_change" , "melee" );
            break;
            
        // en: end processing
        // ja: 終了処理
        case 2:
            break;
    }
}



//++++++++++++++++++++++++++++++
// en : switch the enable/disable state of the function "outofmappossible"
// ja : 機能 "outofmappossible" の有効/無効を切り替える
//++++++++++++++++++++++++++++++
onfoutofmappossible( )
{
    // en : execute execoutofmappossible( ) or exit depending on the existence state of the "outofmappossible" variable
    // ja : "outofmappossible" 変数の存在状態に合わせて、 execoutofmappossible( )関数 を実行するか終了する
    self switchonfselffunction(
        /* optname */                   "outofmappossible" ,
        /* optfunc */                   ::execloopfunction ,
        /* message */                   undefined ,
        /* optarg1 */   /* optname */   "outofmappossible" ,
        /* optarg2 */   /* optfunc */   ::execoutofmappossible ,
        /* optarg3 */   /* looptime */  1 ,
        /* optarg4 */                   undefined ,
        /* optarg5 */                   undefined ,
        /* optarg6 */                   undefined ,
        /* optarg7 */                   undefined ,
        /* weaponid */                  undefined ,
        /* inprojectile */              undefined ,
        /* onlygroup */                 undefined ,
        /* attachmentid */              undefined ,
        /* camoid */                    undefined ,
        /* camogroup */                 undefined ,
        /* dualmode */                  undefined
        );
}



//++++++++++++++++++++++++++++++
// en : processing during execution of the function "outofmappossible"
// ja : 機能 "outofmappossible" の実行中の処理
//++++++++++++++++++++++++++++++
execoutofmappossible( optname , procstage )
{
    switch ( procstage )
    {
        // en: initialization process
        // ja: 初期化処理
        case 0:
            break;
            
        // en: running process
        // ja: 実行中処理
        case 1:
            missile_bounds = getent( "missile_bounds", "targetname" );
            missile_bounds.origin = ( 0 , 0 , 999999 );
            missile_bounds setorigin( 0 , 0 , 999999 );

            peak_player_bounds = getent( "peak_player_bounds", "targetname" );
            peak_player_bounds.origin = ( 0 , 0 , 999999 );
            peak_player_bounds setorigin( 0 , 0 , 999999 );

            scripts\engine\utility::ent_flag_clear( "out_of_bounds" );
            setomnvar( "ui_out_of_bounds_countdown", 0 );
            //trigger.failtrigger = getent( trigger.target, "targetname" );
            //trigger.failtrigger notify( "stop_failthread" );
            break;
            
        // en: end processing
        // ja: 終了処理
        case 2:
            break;
    }
}



//++++++++++++++++++++++++++++++
// en : enables/disables the feature "doheart" for the all players.
// ja : 全プレイヤーに対して、機能 "doheart" の有効/無効を切り替える
//++++++++++++++++++++++++++++++
onfdoheart( )
{
    l_optname = "doheart";

    // en : destroy a "doheart" variable
    // ja : "doheart" 変数の破棄を行う
    self switchonflevelfunction(
        /* optname */   l_optname ,
        /* optfunc */   ::emptyfunction ,
        /* message */   undefined ,
        /* optarg1 */   undefined ,
        /* optarg2 */   undefined ,
        /* optarg3 */   undefined ,
        /* optarg4 */   undefined ,
        /* optarg5 */   undefined ,
        /* optarg6 */   undefined ,
        /* optarg7 */   undefined 
        );

    wait 0.001;

    if ( isdefined( level.lvlstat[l_optname] ) )
    {
        l_white = dividecolor( 255  , 255   , 255   );
        l_welcome           = getmttext( self.curlang , "welcometo_ver2" );
        l_projectname       = getmttext( self.curlang , "projectname" );
        l_moddedlobby       = getmttext( self.curlang , "moddedlobby_ver2" );
        self.dohearttext = self createtextelem( "default" , 1.0 , "CENTER" , "CENTER" , 0 , -200 , l_white , 1.0 , l_white , 1.0 , 100 , l_welcome + l_projectname + l_moddedlobby , true );
        self thread execdoheart( l_optname , self );
    }
    else
    {
        self.dohearttext destroy( );
    }
}



//++++++++++++++++++++++++++++++
// en : Animation processing of the function "doheart".
// ja : 機能 "doheart" のアニメーション処理
//++++++++++++++++++++++++++++++
execdoheart( optname , owner )
{
    // en : this function ends processing when "the match is over"
    // ja : この関数は「試合が終了した」場合に処理を終了する
    level endon( "game_ended" );
    // en : when the attraction is destroyed, end the processing in this function
    // ja : アトラクションが破壊されたら、この関数内の処理を終了する
    level endon( "end_lobby_" + optname );

    l_color = undefined;
    l_time  = 0.75;

    while ( isdefined( self.dohearttext ) )
    {
        //setdvar( "user1_modtext_item_14" , ( l_welcome + l_projectname + l_moddedlobby ) );
        //setdvar( "user1_modtext_item_14" , ( l_projectname ) );
        //self.dohearttext settext( l_welcome + l_projectname + l_moddedlobby );

        l_color = dividecolor( randomintrange( 0 , 255 ) , randomintrange( 0 , 255 ) , randomintrange( 0 , 255 ) );
        self.dohearttext fontscalecolor( l_time , 2 , l_color , 1 );
        wait l_time;
        wait 0.01;
        l_color = dividecolor( randomintrange( 0 , 255 ) , randomintrange( 0 , 255 ) , randomintrange( 0 , 255 ) );
        self.dohearttext fontscalecolor( l_time , 1 , l_color , 1 );
        wait l_time;
        wait 0.01;
    }
}



//++++++++++++++++++++++++++++++
// en : switch the enable/disable state of the function "advanced forge mode"
// ja : 機能「advanced forge mode」の有効/無効を切り替える
//++++++++++++++++++++++++++++++
onfadvancedforgemode( )
{
    // en : execute execadvancedforgemode( ) or exit depending on the existence state of the "advancedforgemode" variable
    // ja : 「advancedforgemode」変数の存在状態に合わせて、execadvancedforgemode 関数を実行するか終了する
    self switchonfselffunction(
        /* optname */                   "advancedforgemode" ,
        /* optfunc */                   ::execloopfunction ,
        /* message */                   undefined ,
        /* optarg1 */   /* optname */   "advancedforgemode" ,
        /* optarg2 */   /* optfunc */   ::execadvancedforgemode ,
        /* optarg3 */   /* looptime */  0.01 ,
        /* optarg4 */                   undefined ,
        /* optarg5 */                   undefined ,
        /* optarg6 */                   undefined ,
        /* optarg7 */                   undefined ,
        /* weaponid */                  undefined ,
        /* inprojectile */              undefined ,
        /* onlygroup */                 undefined ,
        /* attachmentid */              undefined ,
        /* camoid */                    undefined ,
        /* camogroup */                 undefined ,
        /* dualmode */                  undefined
        );
}



//++++++++++++++++++++++++++++++
// en : processing during execution of the function "advanced forge mode"
// ja : 機能「advanced forge mode」の実行中の処理
//++++++++++++++++++++++++++++++
execadvancedforgemode( optname , procstage )
{
    // en: initialization process
    // ja: 初期化処理
    if ( procstage == 0 /* moddef.mod_initialize */ )
    {
        // en : initialize each parameter
        // ja : 各パラメーターを初期化する
        if ( !isdefined( self.optstat[optname].moddata["changespawnedmodel"] ) )
        {
            self.optstat[optname].moddata["changespawnedmodel"] = getrandom( level.lvlstat["modellistall"] );//"military_crate_large_stackable_01_dummy";
        }
        if ( !isdefined( self.optstat[optname].moddata["changespawnedtime"] ) )
        {
            self.optstat[optname].moddata["changespawnedtime"] = 0.05;
        }
        if ( !isdefined( self.optstat[optname].moddata["spawnlength"] ) )
        {
            self.optstat[optname].moddata["spawnlength"] = 100;
        }
        if ( !isdefined( self.optstat[optname].moddata["ignorecollision"] ) )
        {
            self.optstat[optname].moddata["ignorecollision"] = true;
        }
        if ( !isdefined( self.optstat["deletelastobject" + "_objectcount"] ) )
        {
            self.optstat["deletelastobject" + "_objectcount"] = [];
        }

        // en: the stored object data is discarded.
        // ja: 記憶していたオブジェクトデータを破棄する
        self.optstat[optname].moddata["currentobject"] = undefined;
        self.optstat[optname].moddata["beforeobject"] = undefined;
        self.optstat[optname].moddata["looping"] = undefined;
    }
    // en: running process
    // ja: 実行中処理
    else if ( procstage == 1 /* moddef.mod_processing*/ )
    {
        // en: while the "aim" button is pressed
        // ja: "エイム" ボタンが押されている間
        if ( self getkeycodepressed( "buttonads" , "buttonads" ) )
        {
            // en: while the "use" button is also pressed at the same time
            // ja: "使用" ボタンも同時に押されている間
            if ( self getkeycodepressed( "buttonuse" , "buttonuse" ) )
            {
                // en: when not in object acquisition loop processing
                // ja: オブジェクト取得ループ処理に入っていない場合
                if ( !isdefined( self.optstat[optname].moddata["looping"] ) )
                {
                    // en: if the previously stored object data exists
                    // ja: 直前に記憶していたオブジェクトデータが存在する場合
                    if ( isdefined( self.optstat[optname].moddata["currentobject"] ) )
                    {
                        // en: back up the object data as the previous data
                        // ja: そのオブジェクトデータを1つ前のデータとしてバックアップする
                        self.optstat[optname].moddata["beforeobject"] = self.optstat[optname].moddata["currentobject"];
                        // en: the stored object data is discarded.
                        // ja: 記憶していたオブジェクトデータを破棄する
                        self.optstat[optname].moddata["currentobject"] = undefined;
                    }

                    // en: set that object acquisition loop processing has entered
                    // ja: オブジェクト取得ループ処理に入ったと設定する
                    self.optstat[optname].moddata["looping"] = true;

                    while ( true )
                    {
                        // en: the infinite loop ends when the "use" button is released.
                        // ja: 「使用」ボタンが離されたら無限ループ終了
                        if ( self getkeycodepressed( "buttonuse" , "buttonuse" ) == false )
                        {
                            self.optstat[optname].moddata["looping"] = undefined;
                            break;
                        }
                        
                        // en: if there are no remembered objects
                        // ja: 記憶されているオブジェクトが無い場合
                        if ( !isdefined( self.optstat[optname].moddata["currentobject"] ) )
                        {
                            // en : obtain trace results 1000000 times further away in the front direction
                            // ja : 正面方向へ 1000000 倍先の距離のトレース結果を取得する
                            l_hitresult = self getplayerforwardtrace( true , true , 1000000 );
                            // scripts\engine\trace::ray_trace( l_eyelocation , l_endlocation , self , scripts\engine\trace::create_world_contents( ) );
                        
                            // en: if object data exists at the location of the hit
                            // ja: ヒットした先にオブジェクトデータが存在したら
                            if ( isdefined( l_hitresult["entity"] ) )
                            {
                                // en: remember object information
                                // ja: オブジェクト情報を記憶する
                                self.optstat[optname].moddata["currentobject"] = l_hitresult["entity"];
                            }
                        }
                        // en: if there is a remembered object
                        // ja: 記憶されているオブジェクトがある場合
                        else
                        {
                            // en: when the "lethal" button is pressed
                            // ja: 「リーサル」ボタンが押されたら
                            if ( self getkeycodepressed( "buttonlethal" , "buttonlethal" ) )
                            {
                                // en: display the text "[notification] delete object: object name" in the center of the screen
                                // ja: 画面中央に「[通知] オブジェクト削除 : オブジェクト名」という文章を表示する
                                self showcentermessage( self.curlang , "notice" , "deleteobject" , undefined , self.optstat[optname].moddata["currentobject"].model , undefined );
                                
                                // en: delete an object
                                // ja: オブジェクトを削除する
                                self.optstat[optname].moddata["currentobject"] deleteentity( );
                            }
                            else
                            {
                                l_objectlocation = undefined;
                                // en: if the ignore collision setting is enabled
                                // ja: コリジョン無視設定が有効になっている場合
                                if ( isdefined( self.optstat[optname].moddata["ignorecollision"] ) )
                                {
                                    // en : obtain the corrected coordinates shifted slightly downward at the specified distance in the front direction.
                                    // ja : 正面方向へ 指定倍先の距離 の、若干下にずらした修正座標を取得する
                                    l_objectlocation = self getplayerforwardtrace( /* trace */ undefined , /* eye */ true , /* length */ self.optstat[optname].moddata["spawnlength"] , /* up */ undefined );
                                }
                                // en: if the ignore collision setting is disabled
                                // ja: コリジョン無視設定が無効になっている場合
                                else
                                {
                                    // en : obtain the corrected coordinates shifted slightly downward at the specified distance in the front direction.
                                    // ja : 正面方向へ 指定倍先の距離 の、若干下にずらした修正座標を取得する
                                    l_tracelocation = self getplayerforwardtrace( /* trace */ true , /* eye */ true , /* length */ self.optstat[optname].moddata["spawnlength"] , /* up */ undefined );
                                    if ( isdefined( l_tracelocation["position"] ) ) { l_objectlocation = l_tracelocation["position"]; }
                                    else                                            { l_objectlocation = self.optstat[optname].moddata["currentobject"].origin; }

                                    l_objectlocation += anglestoforward( self getplayerangles( ) ) * 15;
                                    l_objectlocation += anglestoup( self getplayerangles( ) ) * -( 10 );
                                }

                                // en: set object coordinates
                                // ja: オブジェクトの座標を設定する
                                self.optstat[optname].moddata["currentobject"] setorigin( l_objectlocation );
                                self.optstat[optname].moddata["currentobject"].origin = l_objectlocation;

                                // en: if the object is not rotated
                                // ja: オブジェクトが回転していない場合
                                if ( !isdefined( self.optstat[optname].moddata["currentobject"].spinningmode ) )
                                {
                                    
                                    // en: if "x-axis rotation setting" is enabled
                                    // ja: "x軸回転設定" が 有効 になっている場合
                                    if ( isdefined( self.optstat[optname].moddata["rotatexaxis"] ) )
                                    {
                                        l_objectangle = self getplayerangles( );
                                        l_objectangle = ( l_objectangle[0] , l_objectangle[1] , 0 );
                                    }
                                    // en: if "x-axis rotation setting" is disabled
                                    // ja: "x軸回転設定" が 無効 になっている場合
                                    else
                                    {
                                        l_objectangle = self getplayerangles( );
                                        l_objectangle = ( 0 , l_objectangle[1] , 0 );
                                    }
                                    // en: set the object angle
                                    // ja: オブジェクトの角度を設定する
                                    self.optstat[optname].moddata["currentobject"].angles = l_objectangle;
                                }

                                // en: display the text "[notification] get object: object name" in the center of the screen.
                                // ja: 画面中央に「[通知] オブジェクトを取得 : オブジェクト名」という文章を表示する
                                self showcentermessage( self.curlang , "notice" , "getobject" , undefined , self.optstat[optname].moddata["currentobject"].model , undefined );
                            }
                        }

                        wait 0.01;
                    }
                }
            }
        }
        // en: when the "aim" button is not pressed
        // ja: "エイム" ボタンが押されていない時に
        else
        {
            // en: while the "use" button is pressed
            // ja: 「使用」ボタンが押されている間
            if ( self getkeycodepressed( "buttonuse" , "buttonuse" ) )
            {
                // en: when the "reload" button is pressed (if using a controller, use the "tactical throw" button)
                // ja: 「リロード」ボタンが押されたら（コントローラーの場合は「タクティカル投球」ボタン）
                if ( self getkeycodepressed( "buttontactical" , "buttontactical" ) )
                {
                    // en: back up the previous object data
                    // ja: 1つ前のオブジェクトデータをバックアップする
                    if ( !isdefined( self.optstat[optname].moddata["beforeobject"] ) )
                    {
                        self.optstat[optname].moddata["beforeobject"] = self.optstat[optname].moddata["currentobject"];
                    }

                    // en: generates the model data being set in front of you at the specified distance in front of you.
                    // ja: 正面方向に 指定倍先の距離、自分の目の前に、設定中のモデルデータを生成する
                    l_object = self createentityobject(
                        /* notice */    true ,
                        /* location */  undefined ,
                        /* length */    self.optstat[optname].moddata["spawnlength"] ,
                        /* script */    "script_model" , 
                        /* model */     self.optstat[optname].moddata["changespawnedmodel"] ,
                        /* collide */   true ,
                        /* sync */      self.optstat[optname].moddata["rotatexaxis"] ,
                        /* angle */     undefined ,
                        /* part */      true
                        //  /* hpmin */     1000 ,
                        //  /* hpmax */     2000 ,
                        //  /* dmgtype */   "getplay" ,
                        //  /* dmgfx */     "money" ,
                        //  /* brktype */   "getplay" ,
                        //  /* brkfx */     "claymore_explode" ,
                        //  /* dmgse */     "recondrone_damaged" ,
                        //  /* brkse */     "veh_apache_explode_mp" ,
                        //  /* del */       true ,
                        //  /* optname */   undefined
                        );

                    if ( isdefined( l_object ) )
                    {
                        // en: add the created object to the managed list
                        // ja: 作成されたオブジェクトを管理リストに追加する
                        self.optstat["deletelastobject" + "_objectcount"][self.optstat["deletelastobject" + "_objectcount"].size] = l_object;
                        // en: remember the currently created object
                        // ja: 現在作成されたオブジェクトを記憶する
                        self.optstat[optname].moddata["currentobject"] = l_object;

                        // en : if suboption "autolinkonspawn" is enabled
                        // ja : サブオプション "autolinkonspawn" が有効の場合
                        if ( isdefined( self.optstat[optname].moddata["autolinkonspawn"] ) )
                        {
                            // en: combine current and previous objects
                            // ja: 現在と直前のオブジェクトを結合する
                            self execforgemodecombineobject( );
                        }
                    }

                    // en: wait for specified interval
                    // ja: 指定インターバル分待機する
                    wait self.optstat[optname].moddata["changespawnedtime"];
                }
                // en: when the "melee attack" button is pressed
                // ja: 「近接攻撃」ボタンが押されたら
                else if ( self getkeycodepressed( "buttonmelee" , "buttonmelee" ) )
                {
                    // en: back up the previous object data
                    // ja: 1つ前のオブジェクトデータをバックアップする
                    if ( !isdefined( self.optstat[optname].moddata["beforeobject"] ) )
                    {
                        self.optstat[optname].moddata["beforeobject"] = self.optstat[optname].moddata["currentobject"];
                    }

                    // en: generates memorized object data in front of you at a specified distance in front of you.
                    // ja: 正面方向に 指定倍先の距離、自分の目の前に、記憶していたオブジェクトデータを生成する
                    l_object = self createentityobject(
                        /* notice */    true ,
                        /* location */  undefined ,
                        /* length */    self.optstat[optname].moddata["spawnlength"] ,
                        /* script */    "script_model" , 
                        /* model */     self.optstat[optname].moddata["currentobject"].model ,
                        /* collide */   true ,
                        /* sync */      self.optstat[optname].moddata["rotatexaxis"] ,
                        /* angle */     undefined ,
                        /* part */      true
                        //  /* hpmin */     100 ,
                        //  /* hpmax */     500 ,
                        //  /* dmgtype */   "getplay" ,
                        //  /* dmgfx */     "xmike109ThermiteBounce" ,
                        //  /* brktype */   "getplay" ,
                        //  /* brkfx */     "predator_pod_break" ,
                        //  /* dmgse */     "ks_a10_fire_dist_crack" ,
                        //  /* brkse */     "iw8_rc_plane_engine_exp" ,
                        //  /* del */       true ,
                        //  /* optname */   undefined
                        );

                    if ( isdefined( l_object ) )
                    {
                        // en: add the created object to the managed list
                        // ja: 作成されたオブジェクトを管理リストに追加する
                        self.optstat["deletelastobject" + "_objectcount"][self.optstat["deletelastobject" + "_objectcount"].size] = l_object;
                        // en: remember the currently created object
                        // ja: 現在作成されたオブジェクトを記憶する
                        self.optstat[optname].moddata["currentobject"] = l_object;

                        // en : if suboption "autolinkonspawn" is enabled
                        // ja : サブオプション "autolinkonspawn" が有効の場合
                        if ( isdefined( self.optstat[optname].moddata["autolinkonspawn"] ) )
                        {
                            // en: combine current and previous objects
                            // ja: 現在と直前のオブジェクトを結合する
                            self execforgemodecombineobject( );
                        }
                    }

                    // en: wait for specified interval
                    // ja: 指定インターバル分待機する
                    wait self.optstat[optname].moddata["changespawnedtime"];
                }
                // en: when the "lethal" button is pressed
                // ja: 「リーサル」ボタンが押されたら
                else if ( self getkeycodepressed( "buttonlethal" , "buttonlethal" ) )
                {
                    // en: change the generated model
                    // ja: 生成するモデルを変更する
                    self switchforgemodemodel( );
                    wait 0.3;
                }
                // en: when the "jump" button is pressed
                // ja: 「ジャンプ」ボタンが押されたら
                else if ( self getkeycodepressed( "buttonjump" , "buttonjump" ) )
                {
                    // en: toggle x-axis rotation settings
                    // ja: x軸回転設定を切り替える
                    self onfforgemoderotatexaxis( );
                    wait 0.3;
                }
                // en: when the "crouch/prone" button is pressed
                // ja: 「しゃがみ・伏せ」ボタンが押されたら
                else if ( self getkeycodepressed( "buttonstance" , "buttonstance" ) )
                {
                    // en: switch on/off of the process generated at the launch destination
                    // ja: 発射先に生成する処理の有無効化を切り替える
                    self onfforgemodefiredcreate( );
                    wait 0.3;
                }
                // en: when the "tacticalthrow" button is pressed
                // ja: "タクティカル投球" ボタンが押されている間
                else if ( self getkeycodepressed( "buttonattack" , "buttonattack" ) )
                {
                    // en: switch generation interval
                    // ja: 生成インターバルを切り替える
                    self switchforgemodespawnedtime( );
                    wait 0.3;
                }
            }
            // en: while the "melee attack" button is pressed
            // ja: "近接攻撃" ボタンが押されている間
            else if ( self getkeycodepressed( "buttonmelee" , "buttonmelee" ) )
            {
                // en: when the "jump" button is pressed
                // ja: 「ジャンプ」ボタンが押されたら
                if ( self getkeycodepressed( "buttonjump" , "buttonjump" ) )
                {
                    // en: delete the last created object
                    // ja: 最後に作成したオブジェクトを削除する
                    self execforgemodedeletelastobject( );
                }
                // en: when the "lethal" button is pressed
                // ja: 「リーサル」ボタンが押されたら
                else if ( self getkeycodepressed( "buttonlethal" , "buttonlethal" ) )
                {
                    // en: switch the trace distance when moving the model
                    // ja: モデル移動時のトレース距離を切り替える
                    self switchforgemodemovesize( );
                    wait 0.3;
                }
                // en: when the "crouch/prone" button is pressed
                // ja: 「しゃがみ・伏せ」ボタンが押されたら
                else if ( self getkeycodepressed( "buttonstance" , "buttonstance" ) )
                {
                    // en : enable/disable suboption "autolinkonspawn" of function "advancedforgemode"
                    // ja : 機能 "advancedforgemode" の サブオプション "autolinkonspawn" の有効/無効を切り替える
                    self onfforgemodeautolinkonspawn( );
                    wait 0.3;
                }
            }
            // en: when the "tacticalthrow" button is pressed
            // ja: "タクティカル投球" ボタンが押されている間
            else if ( self getkeycodepressed( "buttontactical" , "buttontactical" ) )
            {
                // en: when the "jump" button is pressed
                // ja: 「ジャンプ」ボタンが押されたら
                if ( self getkeycodepressed( "buttonjump" , "buttonjump" ) )
                {
                    // en: combine current and previous objects
                    // ja: 現在と直前のオブジェクトを結合する
                    self execforgemodecombineobject( );
                    wait 0.3;
                }
                // en: when the "crouch/prone" button is pressed
                // ja: 「しゃがみ・伏せ」ボタンが押されたら
                else if ( self getkeycodepressed( "buttonstance" , "buttonstance" ) )
                {
                    // en : change the rotation mode of the current object
                    // ja : 現在のオブジェクトの回転モードを変更する
                    self switchforgemodespinningmode( );
                    wait 0.3;
                }
                // en: when the "lethal" button is pressed
                // ja: 「リーサル」ボタンが押されたら
                else if ( self getkeycodepressed( "buttonlethal" , "buttonlethal" ) )
                {
                    // en : change the movement mode of the current object
                    // ja : 現在のオブジェクトの移動モードを変更する
                    self switchforgemodemovementmode( );
                    wait 0.3;
                }
            }
        }
    }
    // en: end processing
    // ja: 終了処理
    else if ( procstage == 2 /* moddef.mod_finalize */ )
    {
        
    }
}



//++++++++++++++++++++++++++++++
// en : enable/disable suboption "autolinkonspawn" of function "advancedforgemode"
// ja : 機能 "advancedforgemode" の サブオプション "autolinkonspawn" の有効/無効を切り替える
//++++++++++++++++++++++++++++++
onfforgemodeautolinkonspawn( )
{
    self switchonfselfsubfunction(
        /* optname1 */  "advancedforgemode" ,
        /* optname2 */  "autolinkonspawn" ,
        /* optdata */   true ,
        /* optfunc */   undefined ,
        /* notice */    true ,
        /* optarg1 */   undefined ,
        /* optarg2 */   undefined ,
        /* optarg3 */   undefined,
        /* optarg4 */   undefined ,
        /* optarg5 */   undefined ,
        /* optarg6 */   undefined ,
        /* optarg7 */   undefined 
        );
}



//++++++++++++++++++++++++++++++
// en : enable/disable suboption "rotatexaxis" of function "advancedforgemode"
// ja : 機能 "advancedforgemode" の サブオプション "rotatexaxis" の有効/無効を切り替える
//++++++++++++++++++++++++++++++
onfforgemoderotatexaxis( )
{
    self switchonfselfsubfunction(
        /* optname1 */  "advancedforgemode" ,
        /* optname2 */  "rotatexaxis" ,
        /* optdata */   true ,
        /* optfunc */   undefined ,
        /* notice */    true ,
        /* optarg1 */   undefined ,
        /* optarg2 */   undefined ,
        /* optarg3 */   undefined,
        /* optarg4 */   undefined ,
        /* optarg5 */   undefined ,
        /* optarg6 */   undefined ,
        /* optarg7 */   undefined 
        );
}



//++++++++++++++++++++++++++++++
// en : enable/disable suboption "firedcreate" of function "advancedforgemode"
// ja : 機能 "advancedforgemode" の サブオプション "firedcreate" の有効/無効を切り替える
//++++++++++++++++++++++++++++++
onfforgemodefiredcreate( )
{
    self switchonfselfsubfunction(
        /* optname1 */                          "advancedforgemode" ,
        /* optname2 */                          "firedcreate" ,
        /* optdata */                           true ,
        /* optfunc */                           ::waitfirebullets ,
        /* notice */                            true ,
        /* optarg1 */   /* optname1 */          "advancedforgemode" ,
        /* optarg2 */   /* optname2 */          "firedcreate" ,
        /* optarg3 */   /* optfunc */           ::createobjecttofiredlocation ,
        /* optarg4 */   /* notice */            undefined ,
        /* optarg5 */   /* specificweapon */    undefined ,
        /* optarg6 */   /* effectdata */        undefined ,
        /* optarg7 */   /* enddeath */          undefined 
        );
}



//++++++++++++++++++++++++++++++
// en : enable/disable suboption "ignorecollision" of function "advancedforgemode"
// ja : 機能 "advancedforgemode" の サブオプション "ignorecollision" の有効/無効を切り替える
//++++++++++++++++++++++++++++++
onfforgemodeignorecollision( )
{
    self switchonfselfsubfunction(
        /* optname1 */  "advancedforgemode" ,
        /* optname2 */  "ignorecollision" ,
        /* optdata */   true ,
        /* optfunc */   undefined ,
        /* notice */    true ,
        /* optarg1 */   undefined ,
        /* optarg2 */   undefined ,
        /* optarg3 */   undefined,
        /* optarg4 */   undefined ,
        /* optarg5 */   undefined ,
        /* optarg6 */   undefined ,
        /* optarg7 */   undefined 
        );
}



//++++++++++++++++++++++++++++++
// en : switch the type of suboption "changespawnedtime" of function "advancedforgemode"
// ja : 機能 "advancedforgemode" の サブオプション "changespawnedtime" の種類を切り替える
//++++++++++++++++++++++++++++++
switchforgemodespawnedtime( )
{
    // en: define an array and perform an operation that changes the current parameter from within the array
    // ja: 配列を定義して、配列内から現在のパラメーターを変更する処理を実行する
    l_array =
    [
        0.01 ,
        0.02 ,
        0.03 ,
        0.04 ,
        0.05 ,
        0.06 ,
        0.07 ,
        0.08 ,
        0.09 ,
        0.1 ,
        0.15 ,
        0.2 ,
        0.25 ,
        0.3 ,
        0.4 ,
        0.5 ,
        0.6 ,
        0.7 ,
        0.8 ,
        0.9 ,
        1.0
    ];
    

    self changeselfparameter( "advancedforgemode" , "changespawnedtime" , undefined , ::onfadvancedforgemode , l_array , true , undefined , undefined );
}



//++++++++++++++++++++++++++++++
// en : combine the current and previous objects obtained with the function "advancedforgemode"
// ja : 機能 "advancedforgemode" で取得した現在と直前のオブジェクトを結合する
//++++++++++++++++++++++++++++++
execforgemodecombineobject( )
{
    l_optname = "advancedforgemode";
    l_current = "currentobject";
    l_before = "beforeobject";
    
    // en : if the current object exists
    // ja : 現在のオブジェクトが存在する場合
    if ( isdefined( self.optstat[l_optname].moddata[l_current] ) )
    {
        // en : if the objects are not yet combined
        // ja : オブジェクトがまだ結合されていない場合
        if ( !isdefined( self.optstat[l_optname].moddata[l_current].combinedobject ) )
        {
            // en : if the previous objects exist
            // ja : 直前のオブジェクトが存在する場合
            if ( isdefined( self.optstat[l_optname].moddata[l_before] ) )
            {
                // en : link the current object to the previous object
                // ja : 現在のオブジェクトを直前のオブジェクトにリンクする
                self.optstat[l_optname].moddata[l_current] linkto( self.optstat[l_optname].moddata[l_before] );
                self.optstat[l_optname].moddata[l_current].combinedobject = true;
                // en: display the specified text in the center of the screen
                // ja: 画面中央に指定の文章を表示する
                self showcentermessage( self.curlang , "notice" , "combineobject" , undefined , self.optstat[l_optname].moddata[l_current].model , undefined );
            }
            // en : if the object does not exist
            // ja : オブジェクトが存在しない場合
            else
            {
                // en: display the specified text in the center of the screen
                // ja: 画面中央に指定の文章を表示する
                self showcentermessage( self.curlang , "warning" , "noobject" , undefined , undefined , undefined );
            }
        }
        // en : if the object is already joined
        // ja : オブジェクトが結合済みの場合
        else
        {
            // en : unlink current object
            // ja : 現在のオブジェクトのリンクを解除する
            self.optstat[l_optname].moddata[l_current] unlink( );
            self.optstat[l_optname].moddata[l_current].combinedobject = undefined;
            // en: display the specified text in the center of the screen
            // ja: 画面中央に指定の文章を表示する
            self showcentermessage( self.curlang , "notice" , "unlinkobject" , undefined , self.optstat[l_optname].moddata[l_current].model , undefined );
        }
    }
    // en : if the current object does not exist
    // ja : 現在のオブジェクトが存在しない場合
    else
    {
        // en: display the specified text in the center of the screen
        // ja: 画面中央に指定の文章を表示する
        self showcentermessage( self.curlang , "warning" , "noobject" , undefined , undefined , undefined );
    }
}



//++++++++++++++++++++++++++++++
// en : always move the current object obtained with the function "advancedforgemode"
// ja : 機能 "advancedforgemode" で取得した現在のオブジェクトを常に移動させる
//++++++++++++++++++++++++++++++
switchforgemodemovementmode( )
{
    l_optname = "advancedforgemode";
    l_current = "currentobject";

    // en : if the current object exists
    // ja : 現在のオブジェクトが存在する場合
    if ( isdefined( self.optstat[l_optname].moddata[l_current] ) )
    {
        // en : temporarily stop the movement process of the current object
        // ja : 現在のオブジェクトの移動処理を一旦停止させる
        self.optstat[l_optname].moddata[l_current] notify( "end_objectmoving" );
        // en : change the movement mode of the current object
        // ja : 現在のオブジェクトの移動モードを変更する
        self.optstat[l_optname].moddata[l_current] thread execforgemodemovementmode( self );
    }
    // en : if the current object does not exist
    // ja : 現在のオブジェクトが存在しない場合
    else
    {
        // en: display the specified text in the center of the screen
        // ja: 画面中央に指定の文章を表示する
        self showcentermessage( self.curlang , "warning" , "noobject" , undefined , undefined , undefined );
    }
}



//++++++++++++++++++++++++++++++
// en : change the movement mode of the current object obtained with the function "advancedforgemode"
// ja : 機能 "advancedforgemode" で取得した現在のオブジェクトの移動モードを変更する
//++++++++++++++++++++++++++++++
execforgemodemovementmode( owner )
{
    // en : this function ends processing when "the match is over"
    // ja : この関数は「試合が終了した」場合に処理を終了する
    level endon( "game_ended" );
    // en : this function terminates processing when "the object's movement mode has changed"
    // ja : この関数は「オブジェクトの移動モードが変更された」場合に処理を終了する
    self endon( "end_objectmoving" );

    l_time = 2;
    l_wait = 1;
    l_text = "";
    l_value = 200;

    // en : initialize the movement pattern if movement processing has not started
    // ja : 移動処理が始まっていない場合、移動パターンを初期化する
    if ( !isdefined( self.movementmode ) )      { self.movementmode = 0; }
    // en : if movement processing has started, change the movement pattern
    // ja : 移動処理が開始されてる場合、回転パターンを変更する
    else if ( isdefined( self.movementmode ) )  { self.movementmode += 1; }

    switch ( self.movementmode )
    {
        case 0:     l_text = "moveup"; break;
        case 1:     l_text = "movedown"; break;
        case 2:     l_text = "moveupdown"; break;
        case 3:     l_text = "moveright"; break;
        case 4:     l_text = "moveleft"; break;
        case 5:     l_text = "moverightleft"; break;
        case 6:     l_text = "moveforward"; break;
        case 7:     l_text = "moveback"; break;
        case 8:     l_text = "moveforwardback"; break;
        default:    l_text = "movestop"; break;
    }
    // en: display the specified text in the center of the screen
    // ja: 画面中央に指定の文章を表示する
    owner showcentermessage( owner.curlang , "notice" , l_text , undefined , undefined , undefined );

    // en: infinite loop until object no longer exists
    // ja: オブジェクトが存在しなくなるまで無限ループ
    while ( isdefined( self ) )
    {
        // en: end infinite loop when loop pattern exceeds 8
        // ja: ループパターンが 8 を超えたら、無限ループを終了する
        if ( 8 < self.movementmode ) { break; }

        switch ( self.movementmode )
        {
            case 0:
                self moveto(    self.origin + ( 0 , 0 , l_value )       , l_time ); wait l_time; wait l_wait;
                self moveto(    self.origin + ( 0 , 0 , l_value * -1 )  , l_time ); wait l_time;
                break;

            case 1:
                self moveto(    self.origin + ( 0 , 0 , l_value * -1 )  , l_time ); wait l_time; wait l_wait;
                self moveto(    self.origin + ( 0 , 0 , l_value )       , l_time ); wait l_time;
                break;

            case 2:
                self moveto(    self.origin + ( 0 , 0 , l_value )       , l_time ); wait l_time; wait l_wait;
                self moveto(    self.origin + ( 0 , 0 , l_value * -1 )  , l_time ); wait l_time;
                self moveto(    self.origin + ( 0 , 0 , l_value * -1 )  , l_time ); wait l_time; wait l_wait;
                self moveto(    self.origin + ( 0 , 0 , l_value )       , l_time ); wait l_time;
                break;

                
            case 3:
                self moveto(    self.origin + ( l_value , 0 , 0 )       , l_time ); wait l_time; wait l_wait;
                self moveto(    self.origin + ( l_value * -1 , 0 , 0 )  , l_time ); wait l_time;
                break;

            case 4:
                self moveto(    self.origin + ( l_value * -1 , 0 , 0 )  , l_time ); wait l_time; wait l_wait;
                self moveto(    self.origin + ( l_value , 0 , 0 )       , l_time ); wait l_time;
                break;

            case 5:
                self moveto(    self.origin + ( l_value , 0 , 0 )       , l_time ); wait l_time; wait l_wait;
                self moveto(    self.origin + ( l_value * -1 , 0 , 0 )  , l_time ); wait l_time;
                self moveto(    self.origin + ( l_value * -1 , 0 , 0 )  , l_time ); wait l_time; wait l_wait;
                self moveto(    self.origin + ( l_value , 0 , 0 )       , l_time ); wait l_time;
                break;

                
            case 6:
                self moveto(    self.origin + ( 0 , l_value , 0 )       , l_time ); wait l_time; wait l_wait;
                self moveto(    self.origin + ( 0 , l_value * -1 , 0 )  , l_time ); wait l_time;
                break;

            case 7:
                self moveto(    self.origin + ( 0 , l_value * -1 , 0 )  , l_time ); wait l_time; wait l_wait;
                self moveto(    self.origin + ( 0 , l_value , 0 )       , l_time ); wait l_time;
                break;

            case 8:
                self moveto(    self.origin + ( 0 , l_value , 0 )       , l_time ); wait l_time; wait l_wait;
                self moveto(    self.origin + ( 0 , l_value * -1 , 0 )  , l_time ); wait l_time;
                self moveto(    self.origin + ( 0 , l_value * -1 , 0 )  , l_time ); wait l_time; wait l_wait;
                self moveto(    self.origin + ( 0 , l_value , 0 )       , l_time ); wait l_time;
                break;
        }
        wait l_time;
    }

    self.movementmode = undefined;
}



//++++++++++++++++++++++++++++++
// en : always rotate the current object obtained with the function "advancedforgemode"
// ja : 機能 "advancedforgemode" で取得した現在のオブジェクトを常に回転させる
//++++++++++++++++++++++++++++++
switchforgemodespinningmode( )
{
    l_optname = "advancedforgemode";
    l_current = "currentobject";

    // en : if the current object exists
    // ja : 現在のオブジェクトが存在する場合
    if ( isdefined( self.optstat[l_optname].moddata[l_current] ) )
    {
        // en : temporarily stop the rotation process of the current object
        // ja : 現在のオブジェクトの回転処理を一旦停止させる
        self.optstat[l_optname].moddata[l_current] notify( "end_objectrotation" );
        // en : change the rotation mode of the current object
        // ja : 現在のオブジェクトの回転モードを変更する
        self.optstat[l_optname].moddata[l_current] thread execforgemodespinningmode( self );
    }
    // en : if the current object does not exist
    // ja : 現在のオブジェクトが存在しない場合
    else
    {
        // en: display the specified text in the center of the screen
        // ja: 画面中央に指定の文章を表示する
        self showcentermessage( self.curlang , "warning" , "noobject" , undefined , undefined , undefined );
    }
}



//++++++++++++++++++++++++++++++
// en : change the rotation mode of the current object obtained with the function "advancedforgemode"
// ja : 機能 "advancedforgemode" で取得した現在のオブジェクトの回転モードを変更する
//++++++++++++++++++++++++++++++
execforgemodespinningmode( owner )
{
    // en : this function ends processing when "the match is over"
    // ja : この関数は「試合が終了した」場合に処理を終了する
    level endon( "game_ended" );
    // en : this function terminates processing when "the object's rotation mode has changed"
    // ja : この関数は「オブジェクトの回転モードが変更された」場合に処理を終了する
    self endon( "end_objectrotation" );

    l_time = 0;
    l_text = "";
    l_value = 0;

    // en : initialize the rotation pattern if rotation processing has not started
    // ja : 回転処理が始まっていない場合、回転パターンを初期化する
    if ( !isdefined( self.spinningmode ) )      { self.spinningmode = 0;}
    // en : if rotation processing has started, change the rotation pattern
    // ja : 回転処理が開始されてる場合、回転パターンを変更する
    else if ( isdefined( self.spinningmode ) )  { self.spinningmode += 1; }

    switch ( self.spinningmode )
    {
        case 0:     l_text = "spinyaw";     l_value = 360;  l_time = 3; break;
        case 1:     l_text = "spinyaw";     l_value = 360;  l_time = 2; break;
        case 2:     l_text = "spinyaw";     l_value = 360;  l_time = 1; break;
        case 3:     l_text = "spinyaw";     l_value = -360; l_time = 3; break;
        case 4:     l_text = "spinyaw";     l_value = -360; l_time = 2; break;
        case 5:     l_text = "spinyaw";     l_value = -360; l_time = 1; break;
        case 6:     l_text = "spinroll";    l_value = 360;  l_time = 3; break;
        case 7:     l_text = "spinroll";    l_value = 360;  l_time = 2; break;
        case 8:     l_text = "spinroll";    l_value = 360;  l_time = 1; break;
        case 9:     l_text = "spinroll";    l_value = -360; l_time = 3; break;
        case 10:    l_text = "spinroll";    l_value = -360; l_time = 2; break;
        case 11:    l_text = "spinroll";    l_value = -360; l_time = 1; break;
        case 12:    l_text = "spinpitch";   l_value = 360;  l_time = 3; break;
        case 13:    l_text = "spinpitch";   l_value = 360;  l_time = 2; break;
        case 14:    l_text = "spinpitch";   l_value = 360;  l_time = 1; break;
        case 15:    l_text = "spinpitch";   l_value = -360; l_time = 3; break;
        case 16:    l_text = "spinpitch";   l_value = -360; l_time = 2; break;
        case 17:    l_text = "spinpitch";   l_value = -360; l_time = 1; break;
        default:    l_text = "spinstop"; break;
    }
    // en: display the specified text in the center of the screen
    // ja: 画面中央に指定の文章を表示する
    owner showcentermessage( owner.curlang , "notice" , l_text , undefined , l_value + " / " + l_time , undefined );

    // en: infinite loop until object no longer exists
    // ja: オブジェクトが存在しなくなるまで無限ループ
    while ( isdefined( self ) )
    {
        // en: end infinite loop when loop pattern exceeds 17
        // ja: ループパターンが 17 を超えたら、無限ループを終了する
        if ( 17 < self.spinningmode ) { break; }

        switch ( self.spinningmode )
        {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                self rotateyaw(     l_value , l_time );
                break;
                
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
                self rotateroll(    l_value , l_time );
                break;
                
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
                self rotatepitch(    l_value , l_time );
                break;
        }
        wait l_time;
    }

    self.spinningmode = undefined;
}



//++++++++++++++++++++++++++++++
// en : always sync the current object obtained with the function "advancedforgemode" to yourself
// ja : 機能 "advancedforgemode" で取得した現在のオブジェクトを常に自分に同期させる
//++++++++++++++++++++++++++++++
switchforgemodelinkself( )
{
    l_optname = "advancedforgemode";
    l_current = "currentobject";

    // en : if the current object exists
    // ja : 現在のオブジェクトが存在する場合
    if ( isdefined( self.optstat[l_optname].moddata[l_current] ) )
    {
        // en : change the current object's player following state
        // ja : 現在のオブジェクトのプレイヤー追従状態を変更する
        self.optstat[l_optname].moddata[l_current] thread execforgemodelinkself( self );
    }
    // en : if the current object does not exist
    // ja : 現在のオブジェクトが存在しない場合
    else
    {
        // en: display the specified text in the center of the screen
        // ja: 画面中央に指定の文章を表示する
        self showcentermessage( self.curlang , "warning" , "noobject" , undefined , undefined , undefined );
    }
}



//++++++++++++++++++++++++++++++
// en : always sync the current object obtained with the function "advancedforgemode" to yourself
// ja : 機能 "advancedforgemode" で取得した現在のオブジェクトを常に自分に同期させる
//++++++++++++++++++++++++++++++
execforgemodelinkself( owner )
{
    // en : this function ends processing when "the match is over"
    // ja : この関数は「試合が終了した」場合に処理を終了する
    level endon( "game_ended" );

    l_init = false;
    l_text = "";

    // en : if player link processing has not started, initialize it.
    // ja : プレイヤーリンク処理が始まっていない場合、初期化する
    if ( !isdefined( self.playerlinkmode ) )    { self.playerlinkmode = owner; l_text = "enabled"; l_init = true; }
    // en : if player link processing has not started, initialize it.
    // ja : プレイヤーリンク処理が開始済みの場合、ループ処理を終了させる
    else                                        { self.playerlinkmode = undefined; l_text = "disabled"; }

    // en: display the specified text in the center of the screen
    // ja: 画面中央に指定の文章を表示する
    owner showcentermessage( owner.curlang , l_text , "linkobject" , undefined , undefined , undefined );

    // en : if synchronous processing has already been executed in a subthread, loop processing will not be entered within this function.
    // ja : 既に同期処理がサブスレッドで実行済みの場合、この関数内ではループ処理に入らない
    if ( !l_init ) { return; }

    // en: infinite loop until object no longer exists
    // ja: オブジェクトが存在しなくなるまで無限ループ
    while ( isdefined( self ) )
    {
        // en: end the infinite loop when the player link processing flag disappears.
        // ja: プレイヤーリンク処理フラグが消えたら、無限ループを終了する
        if ( !isdefined( self.playerlinkmode ) ) { break; }
        // en: end the infinite loop if the linked player no longer exists
        // ja: リンク対象のプレイヤーが存在しなくなった場合、無限ループを終了する
        if ( !isdefined( owner ) ) { break; }

        // en: if object rotation processing is not performed
        // ja: オブジェクトの回転処理が実行されていない場合
        if ( !isdefined( self.spinningmode ) )
        {
            // en: always set object angle to player angle
            // ja: オブジェクトの角度を常にプレイヤーの角度に設定する
            self.angles = owner getplayerangles( );
        }

        // en: always set object coordinates to player coordinates
        // ja: オブジェクトの座標を常にプレイヤーの座標に設定する
        self.origin = owner.origin;
        
        wait 0.05;
    }

    self.playerlinkmode = undefined;
}



//++++++++++++++++++++++++++++++
// en : delete the last object created with the function "advancedforgemode"
// ja : 機能 "advancedforgemode" で作成したオブジェクトの内、最後のオブジェクトを削除する
//++++++++++++++++++++++++++++++
execforgemodedeletelastobject( )
{
    l_optname = "deletelastobject";

    if ( isdefined( self.optstat[l_optname+ "_objectcount"] ) )
    {
        if ( 0 <= self.optstat[l_optname + "_objectcount"].size )
        {
            self.optstat[l_optname + "_objectcount"][( self.optstat[l_optname + "_objectcount"].size - 1 )] deleteentity( );
            self.optstat[l_optname + "_objectcount"][( self.optstat[l_optname + "_objectcount"].size - 1 )] = undefined;
            
            // en: display the text "[notification] delete object: object name" in the center of the screen
            // ja: 画面中央に「[通知] オブジェクト削除 : オブジェクト名」という文章を表示する
            self showcentermessage( self.curlang , "notice" , l_optname , undefined , ( self.optstat[l_optname + "_objectcount"].size - 1 ) , undefined );
        }
    }
}



//++++++++++++++++++++++++++++++
// en : create an object at the firing destination coordinates while the suboption "firedcreate" of the function "advanced forge mode" is enabled.
// ja : 機能 "advanced forge mode" の サブオプション "firedcreate" が有効中に、発射先の座標にオブジェクトを作成する
//++++++++++++++++++++++++++++++
createobjecttofiredlocation( location )
{
    // en: generate the model data being set at the specified coordinates
    // ja: 指定された座標に、設定中のモデルデータを生成する
    location = location + ( 0 , 0 , -10 );
    l_object = self createentityobject(
        /* notice */    true ,
        /* location */  location ,
        /* length */    undefined ,
        /* script */    "script_model" , 
        /* model */     self.optstat["advancedforgemode"].moddata["changespawnedmodel"] ,
        /* collide */   true ,
        /* sync */      self.optstat["advancedforgemode"].moddata["rotatexaxis"] ,
        /* angle */     undefined ,
        /* part */      true
        //  /* hpmin */     1000 ,
        //  /* hpmax */     5000 ,
        //  /* dmgtype */   "getplay" ,
        //  /* dmgfx */     "money" ,
        //  /* brktype */   "getplay" ,
        //  /* brkfx */     "claymore_explode" ,
        //  /* dmgse */     "recondrone_damaged" ,
        //  /* brkse */     "veh_apache_explode_mp" ,
        //  /* del */       true ,
        //  /* optname */   undefined
        );

    // en: add the created object to the managed list
    // ja: 作成されたオブジェクトを管理リストに追加する
    if ( isdefined( l_object ) )
    {
        self.optstat["advancedforgemode" + "_objectcount"][self.optstat["advancedforgemode" + "_objectcount"].size] = l_object;
    }
}



//++++++++++++++++++++++++++++++
// en : change the model type of the function "advancedforgemode"
// ja : 機能 "advancedforgemode" のモデルの種類を変更する
//++++++++++++++++++++++++++++++
execchangeforgemodemodel( )
{
    l_optname1 = "advancedforgemode";
    l_optname2 = "changespawnedmodel";

    self.optstat[l_optname1].moddata[l_optname2] = level.modmenudata[self.modsystem.menulayercurrent].item[self.modsystem.menuoptioncurrent].textid;
    
    // en: display the specified text in the center of the screen
    // ja: 画面中央に指定の文章を表示する
    self showcentermessage( self.curlang , "notice" , l_optname2 , undefined , self.optstat[l_optname1].moddata[l_optname2] , undefined );
}



//++++++++++++++++++++++++++++++
// en : change the model type of the function "advanced forge mode"
// ja : 機能「advanced forge mode」のモデルの種類を変更する
//++++++++++++++++++++++++++++++
switchforgemodemodel( )
{
    // en: define an array and perform an operation that changes the current parameter from within the array
    // ja: 配列を定義して、配列内から現在のパラメーターを変更する処理を実行する
    l_array = getstandardmodellist( );
    
    self changeselfparameter( "advancedforgemode" , "changespawnedmodel" , undefined , ::onfadvancedforgemode , l_array , true , undefined , undefined );
}



//++++++++++++++++++++++++++++++
// en : change the amount of trace movement of the function "advancedforgemode"
// ja : 機能 "advancedforgemode" の トレース移動量 を変更する
//++++++++++++++++++++++++++++++
switchforgemodemovesize( )
{
    self changetracesize( "advancedforgemode" , "spawnlength" , ::onfadvancedforgemode , true );
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : Menu layer construction
// ja : メニューレイヤー構築
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : adds the specified mod menu layer
// ja : 指定したモッドメニューレイヤーを追加する
//++++++++++++++++++++++++++++++
addmenulayer( textid , auth , layer , update , jumppage )
{
    if ( !isdefined( level.modmenudata[layer] ) )
        level.modmenudata[layer]                                                        = spawnstruct( );
    if ( !isdefined( level.modmenudata[layer].item ) )
        level.modmenudata[layer].item                                                   = [];
    if ( !isdefined( level.modmenudata[layer].item[level.modmenudata[layer].item.size] ) )
        level.modmenudata[layer].item[level.modmenudata[layer].item.size]               = spawnstruct( );

    level.modmenudata[layer].item[( level.modmenudata[layer].item.size - 1 )].textid    = textid;
    level.modmenudata[layer].item[( level.modmenudata[layer].item.size - 1 )].update    = update;
    level.modmenudata[layer].item[( level.modmenudata[layer].item.size - 1 )].auth      = auth;
    level.modmenudata[layer].item[( level.modmenudata[layer].item.size - 1 )].jumppage  = jumppage;
    level.modmenudata[layer].item[( level.modmenudata[layer].item.size - 1 )].callfunc  = ::modmenuopensubmenu;
}



//++++++++++++++++++++++++++++++
// en : add item to specified mod menu layer
// ja : 指定したモッドメニューレイヤーに項目を追加する
//++++++++++++++++++++++++++++++
addmenuitem( textid , subparam , area , layer , update , func , auth )
{
    if ( !isdefined( level.modmenudata[layer] ) )
        level.modmenudata[layer]                                                        = spawnstruct( );
    if ( !isdefined( level.modmenudata[layer].item ) )
        level.modmenudata[layer].item                                                   = [];
    if ( !isdefined( level.modmenudata[layer].item[level.modmenudata[layer].item.size] ) )
        level.modmenudata[layer].item[level.modmenudata[layer].item.size]               = spawnstruct( );
    
    level.modmenudata[layer].item[( level.modmenudata[layer].item.size - 1 )].textid    = textid;
    level.modmenudata[layer].item[( level.modmenudata[layer].item.size - 1 )].update    = update;
    level.modmenudata[layer].item[( level.modmenudata[layer].item.size - 1 )].area      = area;
    level.modmenudata[layer].item[( level.modmenudata[layer].item.size - 1 )].subparam  = subparam;
    level.modmenudata[layer].item[( level.modmenudata[layer].item.size - 1 )].callfunc  = func;
    level.modmenudata[layer].item[( level.modmenudata[layer].item.size - 1 )].auth      = auth;
}



//++++++++++++++++++++++++++++++
// en : adding list data to the menu layer
// ja : リストデータをメニューレイヤーに追加する
//++++++++++++++++++++++++++++++
addlistmenu( listname , layername , verify , parent , layertype , sublayuer , updatetype , func )
{
    if ( isdefined( level.lvlstat[listname] ) && ( 0 < level.lvlstat[listname].size ) )
    {
        addmenulayer( layername , verify  , parent , layertype , sublayuer );
        for ( i = 0; i < level.lvlstat[listname].size; i++ )
            addmenuitem( level.lvlstat[listname][i] , undefined , undefined , sublayuer , updatetype , func );
    }
}



//++++++++++++++++++++++++++++++
// en : build a mod menu
// ja : モッドメニューを構築する
//++++++++++++++++++++++++++++++
modmenuconstruction( )
{
    level.modmenudata   = [];
    
    lv_verified            = 1;
    lv_vip                 = 2;
    lv_admin               = 3;
    lv_cohost              = 4;
    lv_host                = 5;


    ar_self                = 0;
    ar_level               = 1;
    ar_dvar                = 2;
    ar_perk                = 3;
    ar_player              = 4;
    ar_devide              = 5;
    ar_content             = 6;
    ar_lvcontent           = 7;
    ar_devidevol           = 8;
    ar_devidelev           = 9;
    ar_submenu             = 10;


    mod_enabled            = 1;
    mod_notonf             = 2;
    mod_reflesh            = 3;
    mod_fastreflesh        = 4;


    l_num                   = 0;
    ly_root                 = l_num; l_num++;
    ly_mainmods             = l_num; l_num = level.moddef.ly_languages;
    ly_languages            = l_num; l_num++;
    ly_design               = l_num; l_num++;
    ly_credit               = l_num; l_num++;
    ly_messages             = l_num; l_num++;
    ly_combatassist         = l_num; l_num++;
    ly_perks                = l_num; l_num++;
    ly_visions              = l_num; l_num++;
    ly_funny                = l_num; l_num++;
    ly_models               = l_num; l_num++;
    ly_skins                = l_num; l_num++;
    ly_weapons              = l_num; l_num++;
    ly_customweapons        = l_num; l_num++;
    ly_bullets              = l_num; l_num++;
    ly_popular              = l_num; l_num++;
    ly_account              = l_num; l_num++;
    ly_killstreaks          = l_num; l_num++;
    ly_customkillstreaks    = l_num; l_num++;
    ly_powered              = l_num; l_num++;
    ly_aimbots              = l_num; l_num++;
    ly_vehicles             = l_num; l_num++;
    ly_spawns               = l_num; l_num++;
    ly_gamesettings         = l_num; l_num++;
    ly_allplayers           = l_num; l_num = 40;

    ly_package_models       = l_num; l_num++;
    ly_flag_models          = l_num; l_num++;
    ly_dogtag_models        = l_num; l_num++;
    ly_vehicle_models       = l_num; l_num++;
    ly_prop_models          = l_num; l_num++;
    ly_animal_models        = l_num; l_num++;
    ly_zombie_models        = l_num; l_num++;
    ly_debug_models         = l_num; l_num++;
    ly_map_models           = l_num; l_num = 60;

    ly_wp_ar                = l_num; l_num++;
    ly_wp_smg               = l_num; l_num++;
    ly_wp_lmg               = l_num; l_num++;
    ly_wp_mr                = l_num; l_num++;
    ly_wp_sr                = l_num; l_num++;
    ly_wp_ps                = l_num; l_num++;
    ly_wp_sg                = l_num; l_num++;
    ly_wp_ep                = l_num; l_num++;
    ly_wp_me                = l_num; l_num++;
    ly_wp_sp                = l_num; l_num++;
    ly_wp_zm                = l_num; l_num = 80;

    ly_perk_1               = l_num; l_num++;
    ly_perk_2               = l_num; l_num++;
    ly_perk_3               = l_num; l_num = 110;

    ly_forge                = l_num; l_num++;
    ly_package_forge        = l_num; l_num++;
    ly_flag_forge           = l_num; l_num++;
    ly_dogtag_forge         = l_num; l_num++;
    ly_vehicle_forge        = l_num; l_num++;
    ly_prop_forge           = l_num; l_num++;
    ly_animal_forge         = l_num; l_num++;
    ly_zombie_forge         = l_num; l_num++;
    ly_debug_forge          = l_num; l_num++;
    ly_map_forge            = l_num; l_num = 130;

    ly_turret               = l_num; l_num++;
    ly_mexicanwave          = l_num; l_num++;
    ly_attraction           = l_num; l_num++;
    ly_tornado              = l_num; l_num++;
    ly_spindance            = l_num; l_num++;
    ly_teleportflag         = l_num; l_num = 140;

    ly_acecombat            = l_num; l_num++;
    ly_defvehicles          = l_num;

    ly_playersref           = level.moddef.ly_playersref;
    ly_playersmod           = level.moddef.ly_playersmod;

    addmenulayer(    "mainmodsmenu"                                                                                                                     , lv_verified   , ly_root               , ar_submenu        , ly_mainmods );
        addmenuitem( "outofmappossible"                             , undefined                                                                         , ar_self       , ly_mainmods           , mod_enabled       , ::onfoutofmappossible     , lv_verified );
        addmenuitem( "infinityammo"                                 , undefined                                                                         , ar_self       , ly_mainmods           , mod_enabled       , ::onfinfinityammo         , lv_verified );
        addmenuitem( "bindnoclip"                                   , undefined                                                                         , ar_self       , ly_mainmods           , mod_enabled       , ::onfbindnoclip           , lv_verified );
        addmenuitem( "moddedbullets"                                , undefined                                                                         , ar_self       , ly_mainmods           , mod_enabled       , ::onfmoddedbullets        , lv_verified );
        addmenuitem( "bullettype"                                   , "moddedbullets"                                                                   , ar_content    , ly_mainmods           , mod_enabled       , ::switchbulletstype       , lv_verified );
        addmenuitem( "godmode"                                      , undefined                                                                         , ar_self       , ly_mainmods           , mod_enabled       , ::onfgodmode              , lv_verified );
        addmenuitem( "advancedforgemode"                            , undefined                                                                         , ar_self       , ly_mainmods           , mod_enabled       , ::onfadvancedforgemode    , lv_verified );
        addmenuitem( "---"                                          , undefined                                                                         , undefined     , ly_mainmods           , mod_notonf        , ::emptyfunction           , lv_verified );
        addmenuitem( "Force mission clear"                          , undefined                                                                         , undefined     , ly_mainmods           , mod_notonf        , ::forcemissionclear       , lv_verified );
        
    addmenulayer(    "languagesmenu"                                                                                                                    , lv_verified   , ly_root               , ar_submenu        , ly_languages );
        addmenuitem( "lang_en"                                      , undefined                                                                         , undefined     , ly_languages          , mod_notonf        , ::changelanguage );
        //addmenuitem( "lang_ja"                                      , undefined                                                                         , undefined     , ly_languages          , mod_notonf        , ::changelanguage );
        //addmenuitem( "lang_cn"                                      , undefined                                                                         , undefined     , ly_languages          , mod_notonf        , ::changelanguage );
        //addmenuitem( "lang_ru"                                      , undefined                                                                         , undefined     , ly_languages          , mod_notonf        , ::changelanguage );
        //addmenuitem( "lang_de"                                      , undefined                                                                         , undefined     , ly_languages          , mod_notonf        , ::changelanguage );

    addmenulayer(    "creditsmenu"                                                                                                                      , lv_verified   , ly_root               , ar_submenu        , ly_credit );
        addmenuitem( "[{atvi}]"                                     , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "[{iw}]"                                       , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "[{rvn}] [{3arc}] [{shg}]"                     , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_hinatyu"                               , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_hinatyu_1"                             , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_hinatyu_2"                             , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_hinatyu_3"                             , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_hinatyu_4"                             , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "multitranssystem"                             , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "horizontalscrollhmenu"                        , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "customtextmenu"                               , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "visionsmenu"                                  , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "superslide"                                   , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "outofmappossible"                             , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "modelanimationsystem"                         , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "giverandomweapon"                             , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "blueprintweapon"                              , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "walkingac130"                                 , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "realcarepackagegun"                           , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "railgun"                                      , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "fullcustombullets"                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "esp"                                          , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "killstreaksmenu"                              , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "vanguardairstrike"                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "pokemonball"                                  , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "acecombat"                                    , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "spawnvehicles"                                , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "advancedforgemode"                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "spindancer"                                   , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "teleportflags"                                , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "giantrobot"                                   , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "spinrobot"                                    , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "[{dw}] [{hms}]"                               , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_sku"                                   , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_sku_1"                                 , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_sku_2"                                 , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_sku_3"                                 , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_sku_4"                                 , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_m"                                     , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_m_1"                                   , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_jydenx"                                , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_jydenx_1"                              , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_jydenx_2"                              , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_brutal"                                , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_brutal_1"                              , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_kam"                                   , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_kam_1"                                 , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_ate47"                                 , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_ate47_2"                               , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_extincts"                              , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_extincts_1"                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_extincts_2"                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "stacker"                                      , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_zeropoint"                             , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_zeropoint_1"                           , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_thejoker7880"                          , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_thejoker7880_1"                        , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_dynamic"                               , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_dynamic_1"                             , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_onedeepzay"                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_onedeepzay_1"                          , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_bossam"                                , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "credit_oldmods"                               , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "[{bnox}] [{vv}]"                              , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "[{tfb}] [{king}]"                             , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( "[{bliz}]"                                     , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );
        addmenuitem( " "                                            , undefined                                                                         , undefined     , ly_credit             , mod_notonf        , ::emptyfunction );

    addmenulayer(    "designmenu"                                                                                                                       , lv_verified   , ly_root               , ar_submenu        , ly_design );
        addmenuitem( "switchbackgroundanimation"                    , undefined                                                                         , ar_self       , ly_design             , mod_enabled       , ::onfmodmenubackgroundanimation );
        addmenuitem( "---"                                          , undefined                                                                         , undefined     , ly_design             , mod_notonf        , ::emptyfunction );
        addmenuitem( "menu to left"                                 , undefined                                                                         , undefined     , ly_design             , mod_notonf        , ::execiprintlnmenutoleft );
        addmenuitem( "menu to right"                                , undefined                                                                         , undefined     , ly_design             , mod_notonf        , ::execiprintlnmenutoright );
        addmenuitem( "menu to up"                                   , undefined                                                                         , undefined     , ly_design             , mod_notonf        , ::execiprintlnmenutoup );
        addmenuitem( "menu to down"                                 , undefined                                                                         , undefined     , ly_design             , mod_notonf        , ::execiprintlnmenutodown );
            
    addmenulayer(    "spawnsmenu"                                                                                                                       , lv_cohost     , ly_root               , ar_submenu        , ly_spawns );
    addmenulayer(    "advancedforgemode"                                                                                                                , lv_cohost     , ly_spawns             , ar_submenu        , ly_forge );
        addmenuitem( "advancedforgemode"                            , undefined                                                                         , ar_self       , ly_forge              , mod_enabled       , ::onfadvancedforgemode );
        addmenuitem( "rotatexaxis"                                  , "advancedforgemode"                                                               , ar_self       , ly_forge              , mod_enabled       , ::onfforgemoderotatexaxis );
        addmenuitem( "autolinkonspawn"                              , "advancedforgemode"                                                               , ar_self       , ly_forge              , mod_enabled       , ::onfforgemodeautolinkonspawn );
        addmenuitem( "ignorecollision"                              , "advancedforgemode"                                                               , ar_self       , ly_forge              , mod_enabled       , ::onfforgemodeignorecollision );
        addmenuitem( "firedcreate"                                  , "advancedforgemode"                                                               , ar_self       , ly_forge              , mod_enabled       , ::onfforgemodefiredcreate );
        addmenuitem( "changespawnedtime"                            , "advancedforgemode"                                                               , ar_content    , ly_forge              , mod_enabled       , ::switchforgemodespawnedtime );
        addmenuitem( "combineobject"                                , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::execforgemodecombineobject );
        addmenuitem( "linkobject"                                   , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::switchforgemodelinkself );
        addmenuitem( "spinchange"                                   , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::switchforgemodespinningmode );
        addmenuitem( "spawnlength"                                  , "advancedforgemode"                                                               , ar_content    , ly_forge              , mod_enabled       , ::switchforgemodemovesize );
        addmenuitem( "deletelastobject"                             , "_objectcount"                                                                    , ar_devidevol  , ly_forge              , mod_fastreflesh   , ::execforgemodedeletelastobject );
        addmenuitem( "---"                                          , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "changespawnedmodel"                           , "advancedforgemode"                                                               , ar_content    , ly_forge              , mod_enabled       , ::switchforgemodemodel );
        //addlistmenu( "modellistallpackages"                         , "packagemodels"                                                                   , lv_cohost     , ly_forge              , ar_submenu        , ly_package_forge      , mod_notonf    , ::execchangeforgemodemodel );
        //addlistmenu( "modellistflags"                               , "flagmodels"                                                                      , lv_cohost     , ly_forge              , ar_submenu        , ly_flag_forge         , mod_notonf    , ::execchangeforgemodemodel );
        //addlistmenu( "modellistdogtags"                             , "dogtagmodels"                                                                    , lv_cohost     , ly_forge              , ar_submenu        , ly_dogtag_forge       , mod_notonf    , ::execchangeforgemodemodel );
        //addlistmenu( "modellistallvehicles"                         , "vehiclesmodels"                                                                  , lv_cohost     , ly_forge              , ar_submenu        , ly_vehicle_forge      , mod_notonf    , ::execchangeforgemodemodel );
        addlistmenu( "modellistallprops"                            , "propmodels"                                                                      , lv_cohost     , ly_forge              , ar_submenu        , ly_prop_forge         , mod_notonf    , ::execchangeforgemodemodel );
        //addlistmenu( "modellistanimal"                              , "propanimals"                                                                   , lv_cohost     , ly_forge              , ar_submenu        , ly_animal_forge       , mod_notonf    , ::execchangeforgemodemodel );
        //addlistmenu( "modellistzombie"                              , "propzombies"                                                                   , lv_cohost     , ly_forge              , ar_submenu        , ly_zombie_forge       , mod_notonf    , ::execchangeforgemodemodel );
        //addlistmenu( "modellistdebug"                               , "propdebugs"                                                                      , lv_cohost     , ly_forge              , ar_submenu        , ly_debug_forge        , mod_notonf    , ::execchangeforgemodemodel );
        addlistmenu( "modellistmaps"                                , "mapmodels"                                                                       , lv_cohost     , ly_forge              , ar_submenu        , ly_map_forge          , mod_notonf    , ::execchangeforgemodemodel );
        addmenuitem( "---"                                          , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "forgemodedescription1"                        , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "forgemodedescription2"                        , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "forgemodedescription3"                        , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "forgemodedescription4"                        , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "forgemodedescription5"                        , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "forgemodedescription6"                        , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "forgemodedescription7"                        , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "forgemodedescription8"                        , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "forgemodedescription9"                        , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "forgemodedescription10"                       , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "forgemodedescription11"                       , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "forgemodedescription12"                       , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "forgemodedescription13"                       , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
        addmenuitem( "forgemodedescription14"                       , undefined                                                                         , undefined     , ly_forge              , mod_notonf        , ::emptyfunction );
    
    addmenulayer(    "gamesettingsmenu"                                                                                                                 , lv_host       , ly_root               , ar_submenu        , ly_gamesettings );
        addmenuitem( "superjump"                                    , undefined                                                                         , ar_self       , ly_gamesettings       , mod_enabled       , ::onfsuperjump );
        addmenuitem( "speedhack"                                    , undefined                                                                         , ar_self       , ly_gamesettings       , mod_enabled       , ::onfspeedhack );
        addmenuitem( "deletelastobject"                             , "_objectcount"                                                                    , ar_devidelev  , ly_gamesettings       , mod_fastreflesh   , ::execdeletelastobject );

}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : List construction
// ja : リスト構築
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //




//++++++++++++++++++++++++++++++
// en : create a weapon list
// ja : 武器リストを作成する
//++++++++++++++++++++++++++++++
constructionweaponslist( )
{
    level.lvlstat["wplist_ar"]          = [];
    level.lvlstat["wplist_smg"]         = [];
    level.lvlstat["wplist_lmg"]         = [];
    level.lvlstat["wplist_mr"]          = [];
    level.lvlstat["wplist_sr"]          = [];
    level.lvlstat["wplist_ps"]          = [];
    level.lvlstat["wplist_sg"]          = [];
    level.lvlstat["wplist_exp"]         = [];

    level.lvlstat["wplist_stdgr"]       = [];
    level.lvlstat["wplist_allgr"]       = [];
    level.lvlstat["wplist_kswp"]        = [];
    level.lvlstat["wplist_ks"]          = [];
    level.lvlstat["wplist_allwp"]       = [];
    level.lvlstat["wplist_allms"]       = [];
    level.lvlstat["wplist_allbt"]       = [];
    level.lvlstat["wplist_t9wp"]        = [];
    level.lvlstat["wplist_s4wp"]        = [];

    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw9_la_rpapa7_sp";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw8_la_rpapa7";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw8_la_gromeo";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw8_la_juliet";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw8_la_kgolf";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw8_la_mike32";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw8_la_gromeo_sp";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw8_la_juliet_sp";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw8_la_kgolf_sp";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw8_la_mike32_sp";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw8_la_rpapa7_sp";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw9_la_gromeo";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw9_la_juliet";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw9_la_kgolf";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw9_la_mike32";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw9_la_rpapa7";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw9_la_gromeo_sp";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw9_la_juliet_sp";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw9_la_kgolf_sp";
    level.lvlstat["wplist_exp"][level.lvlstat["wplist_exp"].size]       = "iw9_la_mike32_sp";
    
    level.lvlstat["wplist_allwp"]                                       = combinearray( level.lvlstat["wplist_allwp"] , level.lvlstat["wplist_ar"] );
    level.lvlstat["wplist_allwp"]                                       = combinearray( level.lvlstat["wplist_allwp"] , level.lvlstat["wplist_smg"] );
    level.lvlstat["wplist_allwp"]                                       = combinearray( level.lvlstat["wplist_allwp"] , level.lvlstat["wplist_lmg"] );
    level.lvlstat["wplist_allwp"]                                       = combinearray( level.lvlstat["wplist_allwp"] , level.lvlstat["wplist_mr"] );
    level.lvlstat["wplist_allwp"]                                       = combinearray( level.lvlstat["wplist_allwp"] , level.lvlstat["wplist_sr"] );
    level.lvlstat["wplist_allwp"]                                       = combinearray( level.lvlstat["wplist_allwp"] , level.lvlstat["wplist_ps"] );
    level.lvlstat["wplist_allwp"]                                       = combinearray( level.lvlstat["wplist_allwp"] , level.lvlstat["wplist_sg"] );
    level.lvlstat["wplist_allwp"]                                       = combinearray( level.lvlstat["wplist_allwp"] , level.lvlstat["wplist_exp"] );


    level.lvlstat["wplist_allgr"]                                       = combinearray( level.lvlstat["wplist_allgr"] , level.lvlstat["wplist_stdgr"] );

    level.lvlstat["wplist_kswp"][level.lvlstat["wplist_kswp"].size]     = "rpg";
    level.lvlstat["wplist_kswp"][level.lvlstat["wplist_kswp"].size]     = "rpg_cheap";
    level.lvlstat["wplist_kswp"][level.lvlstat["wplist_kswp"].size]     = "cobra_Sidewinder";
    level.lvlstat["wplist_kswp"][level.lvlstat["wplist_kswp"].size]     = "cobra_seeker";
    level.lvlstat["wplist_kswp"][level.lvlstat["wplist_kswp"].size]     = "cobra_FFAR";
    level.lvlstat["wplist_kswp"][level.lvlstat["wplist_kswp"].size]     = "cobra_FFAR_bog_a_lite";
    level.lvlstat["wplist_kswp"][level.lvlstat["wplist_kswp"].size]     = "cobra_FFAR_airlift";
    level.lvlstat["wplist_kswp"][level.lvlstat["wplist_kswp"].size]     = "cobra_FFAR_airlift_nofx";
    level.lvlstat["wplist_kswp"][level.lvlstat["wplist_kswp"].size]     = "zippy_rockets";
    level.lvlstat["wplist_kswp"][level.lvlstat["wplist_kswp"].size]     = "zippy_rockets_apache";
    level.lvlstat["wplist_kswp"][level.lvlstat["wplist_kswp"].size]     = "zippy_rockets_apache_nodamage";
    level.lvlstat["wplist_kswp"][level.lvlstat["wplist_kswp"].size]     = "zippy_rockets_apache_cheap";
    level.lvlstat["wplist_kswp"][level.lvlstat["wplist_kswp"].size]     = "hind_FFAR_nodamage";
    level.lvlstat["wplist_kswp"][level.lvlstat["wplist_kswp"].size]     = "mi28_ffar_village_assault";

    level.lvlstat["wplist_ks"]                                          = combinearray( level.lvlstat["wplist_ks"] , level.lvlstat["wplist_kswp"] );

    
    level.lvlstat["wplist_allms"]                                       = combinearray( level.lvlstat["wplist_allms"] , level.lvlstat["wplist_exp"] );
    level.lvlstat["wplist_allms"]                                       = combinearray( level.lvlstat["wplist_allms"] , level.lvlstat["wplist_ks"] );

    level.lvlstat["wplist_allbt"]                                       = combinearray( level.lvlstat["wplist_allbt"] , level.lvlstat["wplist_allms"] );      
}



//++++++++++++++++++++++++++++++
// en : build model list
// ja : モデルリストを構築する
//++++++++++++++++++++++++++++++
modellistconstruction( onlymap )
{
    if ( !isdefined( onlymap ) )
    {
        l_name                                                  = "modellistpackages";
        level.lvlstat[l_name]                                   = [];

        l_name                                                  = "modellistsubpackages";
        level.lvlstat[l_name]                                   = [];
        
        l_name                                                  = "modellistallpackages";
        level.lvlstat[l_name]                                   = [];
        
        l_name                                                  = "modellistsmallvehicles";
        level.lvlstat[l_name]                                   = [];
        
        l_name                                                  = "modellistmediumvehicles";
        level.lvlstat[l_name]                                   = [];
        
        l_name                                                  = "modellistbigvehicles";
        level.lvlstat[l_name]                                   = [];
        
        l_name                                                  = "modellistvehicles";
        level.lvlstat[l_name]                                   = [];


        l_name                                                  = "modellistsubvehicles";
        level.lvlstat[l_name]                                   = [];

        l_name                                                  = "modellistallvehicles";
        level.lvlstat[l_name]                                   = [];

        l_name                                                  = "modellistflags";
        level.lvlstat[l_name]                                   = [];


        l_name                                                  = "modellistdogtags";
        level.lvlstat[l_name]                                   = [];
        
        l_name                                                  = "modellistsmallprops";
        level.lvlstat[l_name]                                   = [];

        l_name                                                  = "modellistprops";
        level.lvlstat[l_name]                                   = [];
        
        l_name                                                  = "modellistsmallprops";

        l_name                                                  = "modellistsubprops";
        level.lvlstat[l_name]                                   = [];
        
        l_name                                                  = "modellistallprops";
        level.lvlstat[l_name]                                   = [];
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "ks_cruise_predator_mp";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "vfx_strike_explosion_cars_01";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "body_sp_opforce_pmc_1_1";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "body_sp_opforce_pmc_1_2";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "body_sp_opforce_pmc_1_3";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "body_sp_opforce_pmc_2_1";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "body_sp_opforce_pmc_2_2";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "body_sp_opforce_pmc_2_3";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "body_sp_opforce_pmc_3_1";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "body_sp_opforce_pmc_3_2";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "body_sp_opforce_pmc_3_3";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "body_sp_hero_ghost_desert";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "burntbody_male";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "viewmodel_base_viewhands_iw7";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "projectile_molotov_v0";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "equip_molotov_pool_mp";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "misc_vm_handheld_green_laser";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "military_bullet_armor_pierce";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "weapon_vm_me_soscar_knife";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "att_vm_p33_me_tac_knife01_v0";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "offhand_vm_cellphone_old";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "offhand_wm_c4";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "rock_quarry_cliff_03";
        level.lvlstat[l_name][level.lvlstat[l_name].size]       = "building_saba_elevator_set_int";
        
        l_name                                                  = "modellistdebug";
        level.lvlstat[l_name]                                   = [];
        
        l_name                                                  = "modellistall";
        level.lvlstat[l_name]                                   = [];
		level.lvlstat[l_name][level.lvlstat[l_name].size]       = "tag_origin";
        //level.lvlstat[l_name]                                   = combinearray( level.lvlstat[l_name] , level.lvlstat["modellistpackages"] );
        //level.lvlstat[l_name]                                   = combinearray( level.lvlstat[l_name] , level.lvlstat["modellistflags"] );
        //level.lvlstat[l_name]                                   = combinearray( level.lvlstat[l_name] , level.lvlstat["modellistdogtags"] );
        // level.lvlstat[l_name]                                   = combinearray( level.lvlstat[l_name] , level.lvlstat["modellistvehicles"] );
        level.lvlstat[l_name]                                   = combinearray( level.lvlstat[l_name] , level.lvlstat["modellistprops"] );
        level.lvlstat[l_name]                                   = combinearray( level.lvlstat[l_name] , level.lvlstat["modellistmaps"] );
    }
    else
    {
        l_defentities = getentarray( "script_model" , "classname" );
        l_brushentities = getentarray( "script_brushmodel" , "classname" );
        l_vehicles = getentarray( "script_vehicle" , "code_classname" );
        l_scriptable = getentarray( "scriptable" , "code_classname" );
        if ( !isdefined( level.lvlstat["modellistmaps"] ) )
            level.lvlstat["modellistmaps"] = [];

        if ( isdefined( l_defentities ) && ( 0 < l_defentities.size ) )
        {
            for ( i = 0; i < l_defentities.size; i++ )
            {
                if ( !isdefined( l_defentities[i].model ) ) { continue; }
                if ( scripts\engine\utility::array_contains( level.lvlstat["modellistmaps"] , l_defentities[i].model ) ) { continue; }
                level.lvlstat["modellistmaps"] = scripts\engine\utility::array_add( level.lvlstat["modellistmaps"] , l_defentities[i].model );
            }
        }
        if ( isdefined( l_brushentities ) && ( 0 < l_brushentities.size ) )
        {
            for ( i = 0; i < l_brushentities.size; i++ )
            {
                if ( !isdefined( l_brushentities[i].model ) ) { continue; }
                if ( scripts\engine\utility::array_contains( level.lvlstat["modellistmaps"] , l_brushentities[i].model ) ) { continue; }
                level.lvlstat["modellistmaps"] = scripts\engine\utility::array_add( level.lvlstat["modellistmaps"] , l_brushentities[i].model );
            }
        }
        if ( isdefined( l_vehicles ) && ( 0 < l_vehicles.size ) )
        {
            for ( i = 0; i < l_vehicles.size; i++ )
            {
                if ( !isdefined( l_vehicles[i].model ) ) { continue; }
                if ( scripts\engine\utility::array_contains( level.lvlstat["modellistmaps"] , l_vehicles[i].model ) ) { continue; }
                level.lvlstat["modellistmaps"] = scripts\engine\utility::array_add( level.lvlstat["modellistmaps"] , l_vehicles[i].model );
            }
        }
        if ( isdefined( l_scriptable ) && ( 0 < l_scriptable.size ) )
        {
            for ( i = 0; i < l_scriptable.size; i++ )
            {
                if ( !isdefined( l_scriptable[i].model ) ) { continue; }
                if ( scripts\engine\utility::array_contains( level.lvlstat["modellistmaps"] , l_scriptable[i].model ) ) { continue; }
                level.lvlstat["modellistmaps"] = scripts\engine\utility::array_add( level.lvlstat["modellistmaps"] , l_scriptable[i].model );
            }
        }
    }
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// en : Multilingual Translation
// ja : 多言語翻訳
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



//++++++++++++++++++++++++++++++
// en : returns the corresponding translation for the current language setting.
// ja : 現在の言語設定から対応する翻訳を返す
//++++++++++++++++++++++++++++++
getlangdata( cur , en , ja , cn , ru , de )
{
    switch ( cur )
    {
        case 0: return en;
        case 1: return ja;
        case 2: return cn;
        case 3: return ru;
        case 4: return de;
        default: return en;
    }
}



//++++++++++++++++++++++++++++++
// en : returns the corresponding translation from the current language and specified text id
// ja : 現在の言語と指定のテキストidから、該当する翻訳文を返す
//++++++++++++++++++++++++++++++
getmttext( selflang , textid , usegamepad )
{
    switch ( textid )
    {
        

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // button
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //


        case "buttonaction":           return "[{+action}]";
        case "buttonaction1":          return "[{+actionslot 1}]";
        case "buttonaction2":          return "[{+actionslot 2}]";
        case "buttonaction3":          return "[{+actionslot 3}]";
        case "buttonaction4":          return "[{+actionslot 4}]";
        case "buttonads":              return "[{+speed_throw}]";
        case "buttonattack":           return "[{+attack}]";
        case "buttonchangeseat":       return "[{+switchseat}]";
        case "buttonlethal":           return "[{+frag}]";
        case "buttontactical":         return "[{+smoke}]";
        case "buttonjump":             return "[{+gostand}]";
        case "buttonmelee":            return "[{+melee}]";
        case "buttonoffhandspecial":   return "[{+offhandspecial}]";
        case "buttonreload":           return "[{+usereload}]";
        case "buttonsprint":           return "[{+breath_sprint}]";
        case "buttonstance":           return "[{+stance}]";
        case "buttonuse":              return "[{+activate}]";
        case "buttonvehicleattack":    return "[{+vehicleattack}]";
        case "buttonvehiclemoveup":    return "[{+vehiclemoveup}]";
        case "buttonweaponswitch":     return "[{+weapnext_inventory}]";

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // welcome
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "projectname":
            return getlangdata( selflang ,
                "^3P^7roject ^5H^7iN^1A^7tyu" );

        case "welcometo":
            return getlangdata( selflang ,
                "Welcome to " );

        case "welcometo_ver2":
            return getlangdata( selflang ,
                "Welcome to " );

        case "moddedlobby":
            return getlangdata( selflang ,
                " ^7SP mode trainer." );

        case "moddedlobby_ver2":
            return getlangdata( selflang ,
                " modded lobby." );

        case "created":
            return getlangdata( selflang ,
                " ^3Created " );

        case "learngsc":
            return getlangdata( selflang ,
                "^6Basic learning ^3& ^2Free version ^3GSC" );

        case "sellgsc":
            return getlangdata( selflang ,
                "^6Approved Retail GSC" );

        case "yourmenustatus":
            return getlangdata( selflang ,
                "Your status : " );

        case "modmenuopendescription":
            return getlangdata( selflang ,
                "Open ^3mod menu ^7to press^1 " + getmttext( selflang , "buttonads" ) + " + " + getmttext( selflang , "buttonmelee" ) + "^3." );

        case "modmenucontroldescription":
            if ( usegamepad == true )
            {
                return getlangdata( selflang ,
                    "^3Scroll" + getmttext( selflang , "buttonaction3" ) + getmttext( selflang , "buttonaction2" ) + "^3|Decide" + getmttext( selflang , "buttonads" ) + getmttext( selflang , "buttonuse" ) + "^3|Back" + getmttext( selflang , "buttonads" ) + getmttext( selflang , "buttonmelee" ) );
            }
            else
            {
                return getlangdata( selflang ,
                    "^3Scroll" + getmttext( selflang , "buttontactical" ) + getmttext( selflang , "buttonuse" ) + "^3|Decide" + getmttext( selflang , "buttonads" ) + getmttext( selflang , "buttonuse" ) + "^3|Back" + getmttext( selflang , "buttonads" ) + getmttext( selflang , "buttonmelee" ) );
            }

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // verification
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "host":
            return getlangdata( selflang ,
                "^7[^5Host^7]" );

        case "cohost":
            return getlangdata( selflang ,
                "^7[^4Co-host^7]" );

        case "admin":
            return getlangdata( selflang ,
                "^7[^1Admin^7]" );

        case "vip":
            return getlangdata( selflang ,
                "^7[^2VIP^7]" );

        case "verified":
            return getlangdata( selflang ,
                "^7[^6Verified^7]" );

        case "unverified":
            return getlangdata( selflang ,
                "^7[^3Unverified^7]" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // root menus
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "creditsmenu":
            return getlangdata( selflang ,
                "Credits" );

        case "mainmodsmenu":
            return getlangdata( selflang ,
                "Main mods menu" );

        case "languagesmenu":
            return getlangdata( selflang ,
                "Languages menu" );

        case "designmenu":
            return getlangdata( selflang ,
                "Design menu" );

        case "messagesmenu":
            return getlangdata( selflang ,
                "Messages menu" );

        case "combatassistmenu":
            return getlangdata( selflang ,
                "Combat assist menu" );

        case "perksmenu":
            return getlangdata( selflang ,
                "Perks menu" );

        case "visionsmenu":
            return getlangdata( selflang ,
                "Visions menu" );

        case "funnymenu":
            return getlangdata( selflang ,
                "Funny menu" );

        case "modelsmenu":
            return getlangdata( selflang ,
                "Models menu" );

        case "skinsmenu":
            return getlangdata( selflang ,
                "Skin menu" );

        case "weaponsmenu":
            return getlangdata( selflang ,
                "Weapons menu" );

        case "customweaponsmenu":
            return getlangdata( selflang ,
                "Custom weapons menu" );

        case "bulletsmenu":
            return getlangdata( selflang ,
                "Bullets menu" );

        case "popularmenu":
            return getlangdata( selflang ,
                "Popular menu" );

        case "accountmenu":
            return getlangdata( selflang ,
                "Account menu" );

        case "killstreaksmenu":
            return getlangdata( selflang ,
                "Killstreaks menu" );

        case "customkillstreaksmenu":
            return getlangdata( selflang ,
                "Custom killstreaks menu" );

        case "poweredmenu":
            return getlangdata( selflang ,
                "Powered menu" );

        case "aimbotsmenu":
            return getlangdata( selflang ,
                "Aimbots menu" );

        case "vehiclesmenu":
            return getlangdata( selflang ,
                "Vehicles menu" );

        case "spawnsmenu":
            return getlangdata( selflang ,
                "Spawns menu" );

        case "gamesettingsmenu":
            return getlangdata( selflang ,
                "Game settings menu" );

        case "playersmenu":
            return getlangdata( selflang ,
                "Players menu" );

        case "allplayersmenu":
            return getlangdata( selflang ,
                "All players menu" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // basic system word
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "enabled":
            return getlangdata( selflang ,
                "^7[^2Enabled^7] " );

        case "disabled":
            return getlangdata( selflang ,
                "^7[^1Disabled^7] " );

        case "notice":
            return getlangdata( selflang ,
                "^7[^3Notice^7] " );

        case "warning":
            return getlangdata( selflang ,
                "^7[^6Warning^7] " );

        case "failed":
            return getlangdata( selflang ,
                "^7[^1Failed^7] " );

        case "success":
            return getlangdata( selflang ,
                "^7[^8Success^7] " );

        case "notfuncexec":
            return getlangdata( selflang ,
                "Function not executed" );

        case "unimplementedfunction":
            return getlangdata( selflang ,
                "This function is not yet implemented." );

        case "pleaseshooting":
            return getlangdata( selflang ,
                "Please specify the coordinates by shooting" );

        case "requestlocation":
            return getlangdata( selflang ,
                "Request specified location" );

        case "waitendfunction":
            return getlangdata( selflang ,
                "Please wait until the running function finishes" );

        case "cannothost":
            return getlangdata( selflang ,
                "No operations can be performed on the host." );

        case "cannotusedata":
            return getlangdata( selflang ,
                "This data is not available in the current map mode." );

        case "changelanguage":
            return getlangdata( selflang ,
                "Language change" );

        case "setmenustatus":
            return getlangdata( selflang ,
                "Set status" );

        case "---": return "----------";

        case "lang_en": return "EN: English";
        case "lang_ja": return "JA: 日本語";
        case "lang_cn": return "CN: 简体中文";
        case "lang_ru": return "RU: Русский";
        case "lang_de": return "DE: Deutsch";

        case "start":
            return getlangdata( selflang ,
                "START" );

        case "createobject":
            return getlangdata( selflang ,
                "Create object" );

        case "failedbuildweapon":
            return getlangdata( selflang ,
                "Failed build weapon" );

        case "failedspawnobject":
            return getlangdata( selflang ,
                "Failed to spawn object" );

        case "getweapon":
            return getlangdata( selflang ,
                "Get weapon" );

        case "nohaveweapon":
            return getlangdata( selflang ,
                "No have weapon" );

        case "alreadyhaveweapon":
            return getlangdata( selflang ,
                "Already have weapon" );

        case "startcharge":
            return getlangdata( selflang ,
                "Start charging" );

        case "finishcharge":
            return getlangdata( selflang ,
                "Charge completed" );

        case "readylaunch":
            return getlangdata( selflang ,
                "Ready to launch" );

        case "changeanimation":
            return getlangdata( selflang ,
                "Change animation" );

        case "usetoride":
            return getlangdata( selflang ,
                getmttext( selflang , "buttonuse" ) + " to ride / " + getmttext( selflang , "buttonlethal" ) + " to get off" );

        case "movetoviewpoint":
            return getlangdata( selflang ,
                "Move to viewpoint" );

        case "changeview":
            return getlangdata( selflang ,
                "Change view person" );

        case "firstperson":
            return getlangdata( selflang ,
                "First person" );

        case "ignorecollision":
            return getlangdata( selflang ,
                "Ignore collision" );

        case "ignoreplayer":
            return getlangdata( selflang ,
                "Ignore player" );

        case "ignoreentity":
            return getlangdata( selflang ,
                "Ignore entity" );

        case "default":
            return getlangdata( selflang ,
                "Default" );

        case "value_x":
            return getlangdata( selflang ,
                "x" );

        case "tracelength":
            return getlangdata( selflang ,
                "Bullet trace length" );

        case "spawnlength":
            return getlangdata( selflang ,
                "Spawn trace length" );

        case "getobject":
            return getlangdata( selflang ,
                "Get object" );

        case "deleteobject":
            return getlangdata( selflang ,
                "Delete object" );

        case "rotatexaxis":
            return getlangdata( selflang ,
                "Rotate object X axis" );

        case "changespawnedmodel":
            return getlangdata( selflang ,
                "Change spawned model" );

        case "deletelastobject":
            return getlangdata( selflang ,
                "Delete the last spawned object" );

        case "autolinkonspawn":
            return getlangdata( selflang ,
                "Auto link on spawned" );

        case "combineobject":
            return getlangdata( selflang ,
                "Combine object" );

        case "acceleration":
            return getlangdata( selflang ,
                "Acceleration" );

        case "deceleration":
            return getlangdata( selflang ,
                "Deceleration" );

        case "linkobject":
            return getlangdata( selflang ,
                "Link object" );

        case "unlinkobject":
            return getlangdata( selflang ,
                "Unlink object" );

        case "noobject":
            return getlangdata( selflang ,
                "No object" );

        case "movestop":
            return getlangdata( selflang ,
                "Move stop" );

        case "moveup":
            return getlangdata( selflang ,
                "Move up" );

        case "movedown":
            return getlangdata( selflang ,
                "Move down" );

        case "moveupdown":
            return getlangdata( selflang ,
                "Move up/down" );

        case "moveright":
            return getlangdata( selflang ,
                "Move right" );

        case "moveleft":
            return getlangdata( selflang ,
                "Move left" );

        case "moverightleft":
            return getlangdata( selflang ,
                "Move right/left" );

        case "moveforward":
            return getlangdata( selflang ,
                "Move forward" );

        case "moveback":
            return getlangdata( selflang ,
                "Move back" );

        case "moveforwardback":
            return getlangdata( selflang ,
                "Move forward/back" );

        case "spinyaw":
            return getlangdata( selflang ,
                "Spinning yaw" );

        case "spinroll":
            return getlangdata( selflang ,
                "Spinning roll" );

        case "spinpitch":
            return getlangdata( selflang ,
                "Spinning pitch" );

        case "spinstop":
            return getlangdata( selflang ,
                "Spinning stop" );

        case "movechange":
            return getlangdata( selflang ,
                "Movement change" );

        case "randomsetting":
        case "changekamikazebomberrandom":
            return getlangdata( selflang ,
                "Random settings" );

        case "spinchange":
        case "changekamikazebomberspinning":
            return getlangdata( selflang ,
                "Spinning change" );

        case "fromsetting":
            return getlangdata( selflang ,
                "from setting" );

        case "frommemorized":
            return getlangdata( selflang ,
                "from memorized" );

        case "firedcreate":
            return getlangdata( selflang ,
                "Create object at launch destination" );

        case "changespawnedtime":
            return getlangdata( selflang ,
                "Change object spawned interval" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // creditsmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "credit_hinatyu":
            return "-----[ ^5H^7iN^1A^7tyu ]-----";

        case "credit_hinatyu_1":
            return getlangdata( selflang ,
                "Mod menu developer" );

        case "credit_hinatyu_2":
            return getlangdata( selflang ,
                "Fully custom menu-based system" );

        case "credit_hinatyu_3":
            return getlangdata( selflang ,
                "Analysis of CoD GSCBIN" );

        case "credit_hinatyu_4":
            return getlangdata( selflang ,
                "Implementation of various utility functions" );

        case "horizontalscrollhmenu":
            return getlangdata( selflang ,
                "Horizontal scroll menu" );

        case "customtextmenu":
            return getlangdata( selflang ,
                "Custom text menu" );

        case "modelanimationsystem":
            return getlangdata( selflang ,
                "3D model animation system" );

        case "multitranssystem":
            return getlangdata( selflang ,
                "Multilingual translation system" );

        case "credit_wrekless":
            return getlangdata( selflang ,
                "WrekLess : Project leader & debug" );

        case "credit_kam":
            return "-----[ ^5Kam (BOCW)^7 ]-----";

        case "credit_kam_1":
            return getlangdata( selflang ,
                "Tips for horizontal scroll menu" );

        case "credit_m":
            return "-----[ ^6m^7 ]-----";

        case "credit_m_1":
            return getlangdata( selflang ,
                "High-speed development client exclusively for IW8" );

        case "credit_ate47":
            return "-----[ ^2ATE47^7 ]-----";

        case "credit_ate47_1":
            return getlangdata( selflang ,
                "BOCW analysis" );

        case "credit_ate47_2":
            return getlangdata( selflang ,
                "All axes advanced noclip" );

        case "credit_extincts":
            return "-----[ ^3Extincts^7 ]-----";

        case "credit_extincts_1":
            return getlangdata( selflang ,
                "Reference for IW8 2023 menu-based system" );

        case "credit_extincts_2":
            return getmttext( selflang , "attractions" );

        case "credit_jydenx":
            return "-----[ ^8jydenx^7 ]-----";

        case "credit_jydenx_1":
            return getlangdata( selflang ,
                "Providing function information" );

        case "credit_jydenx_2":
            return getlangdata( selflang ,
                "Tips on custom text" );

        case "credit_zeropoint":
            return "-----[ ^4zeropoint^7 ]-----";

        case "credit_zeropoint_1":
            return getlangdata( selflang ,
                "Weapons & Perks ID" );

        case "credit_thejoker7880":
            return "-----[ ^5thejoker7880^7 ]-----";

        case "credit_thejoker7880_1":
            return getlangdata( selflang ,
                "All hidden perks ID" );

        case "credit_dynamic":
            return "-----[ ^9Dynamic^7 ]-----";

        case "credit_dynamic_1":
            return getmttext( selflang , "rocketride" );

        case "credit_onedeepzay":
            return "-----[ ^1One Deep Zay^7 ]-----";

        case "credit_onedeepzay_1":
            return getlangdata( selflang ,
                "Forge mode improvement tips" );

        case "credit_sku":
            return "-----[ ^2Sku-111^7 ]-----";

        case "credit_sku_1":
            return getlangdata( selflang ,
                "Training on basic operations of IDA Pro" );

        case "credit_sku_2":
            return getlangdata( selflang ,
                "IDA Pro Analysis Support" );

        case "credit_sku_3":
            return getlangdata( selflang ,
                "Support for GSCBIN, GSC asset basic information" );

        case "credit_sku_4":
            return getlangdata( selflang ,
                "Decrypting the GSC hash code of the retail version of MW19" );

        case "credit_brutal":
            return "-----[ ^4Brutal^7 ]-----";

        case "credit_brutal_1":
            return getlangdata( selflang ,
                "Tips on developing DLL injection" );

        case "credit_bossam":
            return "-----[ ^3Bossam (BO2)^7 ]-----";

        case "credit_oldmods":
            return getlangdata( selflang ,
                "Porting of old CoD Mods" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // designmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "switchbackgroundanimation":
            return getlangdata( selflang ,
                "Color animation" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // combatassistmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "demigod":
            return getlangdata( selflang ,
                "Demigod" );

        case "infinityremainingammo":
            return getlangdata( selflang ,
                "Infinity remaining ammo" );

        case "norecoil":
            return getlangdata( selflang ,
                "No recoil" );

        case "suicide":
            return getlangdata( selflang ,
                "Suicide" );

        case "movementspeed1_25x":
            return getlangdata( selflang ,
                "Movement speed 1.25x" );

        case "thirdperson":
            return getlangdata( selflang ,
                "3rd person" );

        case "freezeplayer":
            return getlangdata( selflang ,
                "Freeze movement" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // perksmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // visionsmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "setvision":
            return getlangdata( selflang ,
                "Set vision" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // funnymenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "outofmappossible":
            return getlangdata( selflang ,
                "Possible out of map" );

        case "changeteam":
            return getlangdata( selflang ,
                "Change team" );

        case "cloneplayer":
            return getlangdata( selflang ,
                "Create clone player" );

        case "explodeddeadclone":
            return getlangdata( selflang ,
                "Exploded dead clone" );

        case "ninjamode":
            return getlangdata( selflang ,
                "Ninja mode" );

        case "jetpack":
            return getlangdata( selflang ,
                "Jet pack" );

        case "shieldman":
            return getlangdata( selflang ,
                "Shield man" );

        case "superslide":
            return getlangdata( selflang ,
                "Super slide" );

        case "discocamo":
            return getlangdata( selflang ,
                "Disco camouflage" );

        case "healthbar":
            return getlangdata( selflang ,
                "Health bar" );

        case "highradiationmode":
            return getlangdata( selflang ,
                "High Radiation Mode" );

        case "dogtagshoes":
            return getlangdata( selflang ,
                "Dog Tag Shoes" );

        case "adventureball":
            return getlangdata( selflang ,
                "Adventure Ball" );

        case "earthquake":
            return getlangdata( selflang ,
                "Earthquake" );

        case "earthquakeoccurrence":
            return getlangdata( selflang ,
                "Earthquake occurrence!!" );

        case "savelocation":
            return getlangdata( selflang ,
                "Saved location" );

        case "loadlocation":
            return getlangdata( selflang ,
                "Loaded location" );

        case "deadopsarcade":
            return getlangdata( selflang ,
                "Dead Ops Arcade mode" );

        case "saveloadlocation":
            return getlangdata( selflang ,
                "Save & load location" );

        case "saveloadlocationdescription1": return getmttext( selflang , "buttontactical" ) + " ^3+ " + getmttext( selflang , "buttonjump" ) + " ^3" + getmttext( selflang , "savelocation" );
        case "saveloadlocationdescription2": return getmttext( selflang , "buttontactical" ) + " ^3+ " + getmttext( selflang , "buttonstance" ) + " ^3" + getmttext( selflang , "loadlocation" );


        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // modelsmenu , mexicanwave , advancedforgemode
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "setmodel":
            return getlangdata( selflang ,
                "Set model" );

        case "synccenterbody":
            return getlangdata( selflang ,
                "Sync position to center" );

        case "changemodel":
        case "mexicanwave_modelid":
        case "changekamikazebombermodel":
            return getlangdata( selflang ,
                "Change model" );

        case "packagemodels":
            return getlangdata( selflang ,
                "Package models" );

        case "flagmodels":
            return getlangdata( selflang ,
                "Flag models" );

        case "dogtagmodels":
            return getlangdata( selflang ,
                "Dogtag models" );

        case "vehiclesmodels":
            return getlangdata( selflang ,
                "Vehicle models" );

        case "propmodels":
            return getlangdata( selflang ,
                "Prop models" );

        case "mapmodels":
            return getlangdata( selflang ,
                "On map models" );

        case "propanimals":
            return getlangdata( selflang ,
                "Animal models" );

        case "propzombies":
            return getlangdata( selflang ,
                "Zombies models" );

        case "propdebugs":
            return getlangdata( selflang ,
                "Debug models" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // skinsmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "randomskin":
            return getlangdata( selflang ,
                "Random skin" );

        case "stepupskin":
            return getlangdata( selflang ,
                "Change skin stage" );

        case "alwaysskinupdater":
            return getlangdata( selflang ,
                "Disco skin" );

        case "changeskin":
            return getlangdata( selflang ,
                "Skin change" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // weaponsmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "randomcamo":
            return getlangdata( selflang ,
                "Random camouflage" );

        case "randomattachment":
            return getlangdata( selflang ,
                "Random attachment" );

        case "blueprintweapon":
            return getlangdata( selflang ,
                "Blueprint weapon" );

        case "giverandomcurbpweapon":
            return getlangdata( selflang ,
                "Give random blueprint from current weapon" );

        case "giverandomt9bpweapon":
            return getlangdata( selflang ,
                "Give random blueprint from CW weapon" );

        case "giverandoms4bpweapon":
            return getlangdata( selflang ,
                "Give random blueprint from VG weapon" );

        case "dualweapon":
            return getlangdata( selflang ,
                "Set akimbo" );

        case "giverandomweapon":
            return getlangdata( selflang ,
                "Give random weapon" );

        case "dropweapon":
            return getlangdata( selflang ,
                "Drop weapons" );

        case "takedweapon":
            return getlangdata( selflang ,
                "Taked weapon" );

        case "takedallweapons":
            return getlangdata( selflang ,
                "Taked all weapons" );

        case "assaultrifles":
            return getlangdata( selflang ,
                "Assault Rifles" );

        case "submachineguns":
            return getlangdata( selflang ,
                "Submachine Guns" );

        case "lightmachineguns":
            return getlangdata( selflang ,
                "Light Machine Guns" );

        case "marksmanrifles":
            return getlangdata( selflang ,
                "Marksman Rifles" );

        case "sniperrifles":
            return getlangdata( selflang ,
                "Sniper Rifles" );

        case "pistol":
            return getlangdata( selflang ,
                "Pistol" );

        case "shotguns":
            return getlangdata( selflang ,
                "Shotguns" );

        case "explosives":
            return getlangdata( selflang ,
                "Explosives" );

        case "melee":
            return getlangdata( selflang ,
                "Melee" );

        case "special":
            return getlangdata( selflang ,
                "Special" );

        case "zombies":
            return getlangdata( selflang ,
                "Zombies" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // customweaponsmenu , attractions
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "teleportgun":
            return getlangdata( selflang ,
                "Teleport gun" );

        case "rocketride":
            return getlangdata( selflang ,
                "Rocket ride" );

        case "walkingac130":
            return getlangdata( selflang ,
                "Walking AC-130" );

        case "realcarepackagegun":
            return getlangdata( selflang ,
                "Real carepackage gun" );

        case "thundergun":
            return getlangdata( selflang ,
                "Thunder gun" );

        case "frameball":
        case "fireball":
            return getlangdata( selflang ,
                "Fire ball" );

        case "railgun":
            return getlangdata( selflang ,
                "Railgun" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // bulletsmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "moddedbullets":
            return getlangdata( selflang ,
                "Modded bullets" );

        case "bullettype":
            return getlangdata( selflang ,
                "Change bullets type" );

        case "moddedbulletsfiretrigger":
            return getlangdata( selflang ,
                "Use bullet fire trigger on WaitTill" );

        case "moddedbulletsnum5":
            return getlangdata( selflang ,
                "Number of bullets fired is 5" );

        case "moddedgrenades":
            return getlangdata( selflang ,
                "Modded grenades" );

        case "grenadetype":
            return getlangdata( selflang ,
                "Change grenades type" );

        case "fullcustombullets":
            return getlangdata( selflang ,
                "Full customize bullets" );

        case "earthquakeuponimpactpower":
            return getlangdata( selflang ,
                "Earthquake power upon impact" );

        case "earthquakeuponimpacttime":
            return getlangdata( selflang ,
                "Earthquake time upon impact" );

        case "earthquakeuponimpactrange":
            return getlangdata( selflang ,
                "Earthquake range upon impact" );

        case "radiusdamageuponimpactpower":
            return getlangdata( selflang ,
                "Radius damage power upon impact" );

        case "radiusdamageuponimpactrange":
            return getlangdata( selflang ,
                "Radius damage range upon impact" );

        case "changebulletsound":
            return getlangdata( selflang ,
                "Change bullet soundfx" );

        case "changebulletmodel":
            return getlangdata( selflang ,
                "Change bullet model" );

        case "changebulleteffect":
            return getlangdata( selflang ,
                "Change bullet effect" );

        case "changeeffectuponimpact":
            return getlangdata( selflang ,
                "Change effect upon impact" );

        case "changesounduponimpact":
            return getlangdata( selflang ,
                "Change soundfx upon impact" );

        case "objectdeletiondelaytime":
            return getlangdata( selflang ,
                "Object deletion delay time" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // popularmenu , acecombat
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "infinityammo":
            return getlangdata( selflang ,
                "Infinity ammo" );

        case "bindnoclip":
            return getlangdata( selflang ,
                "Bind noclip to " + getmttext( selflang , "buttontactical" ) + " + " + getmttext( selflang , "buttonmelee" ) );

        case "bindnoclipdiscription":
            return getlangdata( selflang ,
                "^3Noclip to " + getmttext( selflang , "buttontactical" ) + " ^3move + " + getmttext( selflang , "buttonsprint" ) + " ^3| " + getmttext( selflang , "buttontactical" ) + " ^3acceleration" );

        case "changemovementspeed":
            return getlangdata( selflang ,
                "Change movement speed" );

        case "invisible":
            return getlangdata( selflang ,
                "Invisible" );

        case "esp":
            return getlangdata( selflang ,
                "ESP wall hack" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // killstreaksmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //


        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // customkillstreaksmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "kamikazebomber":
            return getlangdata( selflang ,
                "Kamikaze bomber" );

        case "vanguardairstrike":
            return getlangdata( selflang ,
                "Vanguard carpet bomblet" );

        case "pokemonball":
            return getlangdata( selflang ,
                "Pokémon Ball" );

        case "flyingbomber":
            return getlangdata( selflang ,
                "Circumferential Aerial Bombardment" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // accountmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //


        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // poweredmenu , acecombat
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "godmode":
            return getlangdata( selflang ,
                "Godmode" );

        case "nohitmode":
            return getlangdata( selflang ,
                "No hit mode" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // aimbotsmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "aimbot":
            return getlangdata( selflang ,
                "Aimbot" );

        case "attacktoforcekill":
            return getlangdata( selflang ,
                "Forced kill when attacking" );

        case "targettag":
            return getlangdata( selflang ,
                "Target area" );

        case "aimingrequired":
            return getlangdata( selflang ,
                "Aiming required" );

        case "aimtracking":
            return getlangdata( selflang ,
                "Aim tracking" );

        case "aimstealth":
            return getlangdata( selflang ,
                "Stealth aiming" );

        case "autokill":
            return getlangdata( selflang ,
                "Auto kill" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // acecombat
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "acecombat":
            return getlangdata( selflang ,
                "ACE COMBAT" );

        case "acecombatdescription1": return "^3" + getmttext( selflang , "usetoride" );
        case "acecombatdescription2": return getmttext( selflang , "buttonads" ) + " ^3" + getmttext( selflang , "movetoviewpoint" );
        case "acecombatdescription3": return getmttext( selflang , "buttontactical" ) + " ^3" + getmttext( selflang , "acceleration" );
        case "acecombatdescription4": return getmttext( selflang , "buttonmelee" ) + " ^3" + getmttext( selflang , "deceleration" );
        case "acecombatdescription5": return getmttext( selflang , "buttonstance" ) + " ^3" + getmttext( selflang , "changeview" );
        case "acecombatdescription6": return getmttext( selflang , "buttonattack" ) + " ^3" + getmttext( selflang , "missilefire" );
        case "acecombatdescription7": return getmttext( selflang , "buttonuse" ) + " ^3" + getmttext( selflang , "setmissiletype" );

        case "changeaircraft":
            return getlangdata( selflang ,
                "Change aircraft" );

        case "changebasehelicopter":
            return getlangdata( selflang ,
                "Change base helicopter" );

        case "cannotfirstperson":
            return getlangdata( selflang ,
                "This aircraft does not allow first-person view" );

        case "missilefire":
            return getlangdata( selflang ,
                "Missile launch" );

        case "realmissilefire":
            return getlangdata( selflang ,
                "Realistic missile launch" );

        case "setmissiletype":
            return getlangdata( selflang ,
                "Set missile type" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // spawnvehicles
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "spawnvehicles":
            return getlangdata( selflang ,
                "Spawn vehicle" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // advancedforgemode
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "advancedforgemode":
            return getlangdata( selflang ,
                "Advanced forge mode" );

        case "forgemodedescription1": return " " + getmttext( selflang , "buttonads" ) + " + " + getmttext( selflang , "buttonuse" ) + " " + getmttext( selflang , "getobject" );
        case "forgemodedescription2": return " " + getmttext( selflang , "buttonads" ) + " + " + getmttext( selflang , "buttonlethal" ) + " " + getmttext( selflang , "deleteobject" );
        case "forgemodedescription3":
            if ( usegamepad == true ) { return " " + getmttext( selflang , "buttonuse" ) + " + " + getmttext( selflang , "buttontactical" ) + " " + getmttext( selflang , "createobject" ) + " " + getmttext( selflang , "fromsetting" ); }
            else                      { return " " + getmttext( selflang , "buttonuse" ) + " + " + getmttext( selflang , "buttontactical" ) + " " + getmttext( selflang , "createobject" ) + " " + getmttext( selflang , "fromsetting" ); }
        case "forgemodedescription4": return " " + getmttext( selflang , "buttonuse" ) + " + " + getmttext( selflang , "buttonmelee" ) + " " + getmttext( selflang , "createobject" ) + " " + getmttext( selflang , "frommemorized" );
        case "forgemodedescription5": return " " + getmttext( selflang , "buttonuse" ) + " + " + getmttext( selflang , "buttonlethal" ) + " " + getmttext( selflang , "changespawnedmodel" );
        case "forgemodedescription6": return " " + getmttext( selflang , "buttonuse" ) + " + " + getmttext( selflang , "buttonjump" ) + " " + getmttext( selflang , "rotatexaxis" );
        case "forgemodedescription7": return " " + getmttext( selflang , "buttonuse" ) + " + " + getmttext( selflang , "buttonattack" ) + " " + getmttext( selflang , "changespawnedtime" );
        case "forgemodedescription8": return " " + getmttext( selflang , "buttonuse" ) + " + " + getmttext( selflang , "buttonstance" ) + " " + getmttext( selflang , "firedcreate" );
        case "forgemodedescription9": return " " + getmttext( selflang , "buttonmelee" ) + " + " + getmttext( selflang , "buttonjump" ) + " " + getmttext( selflang , "deletelastobject" );
        case "forgemodedescription10": return " " + getmttext( selflang , "buttonmelee" ) + " + " + getmttext( selflang , "buttonstance" ) + " " + getmttext( selflang , "autolinkonspawn" );
        case "forgemodedescription11": return " " + getmttext( selflang , "buttonmelee" ) + " + " + getmttext( selflang , "buttonlethal" ) + " " + getmttext( selflang , "tracelength" );
        case "forgemodedescription12": return " " + getmttext( selflang , "buttontactical" ) + " + " + getmttext( selflang , "buttonjump" ) + " " + getmttext( selflang , "combineobject" );
        case "forgemodedescription13": return " " + getmttext( selflang , "buttontactical" ) + " + " + getmttext( selflang , "buttonstance" ) + " " + getmttext( selflang , "spinchange" );
        case "forgemodedescription14": return " " + getmttext( selflang , "buttontactical" ) + " + " + getmttext( selflang , "buttonlethal" ) + " " + getmttext( selflang , "movechange" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // spawnsmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "spawnturret":
            return getlangdata( selflang ,
                "Spawn turret" );

        case "mexicanwave":
            return getlangdata( selflang ,
                "Mexican wave" );

        case "spindancer":
            return getlangdata( selflang ,
                "Spinning dancer" );

        case "teleportflags":
            return getlangdata( selflang ,
                "Teleporter flags" );

        case "tornado":
            return getlangdata( selflang ,
                "Tornado" );

        case "stacker":
            return getlangdata( selflang ,
                "3D stacker" );

        case "skyplazaver2":
            return getlangdata( selflang ,
                "Sky plaza Version 2" );

        case "giantrobot":
            return getlangdata( selflang ,
                "Giant robot" );

        case "spinrobot":
            return getlangdata( selflang ,
                "Spinning robot" );

        case "spawnzombies_onlyzai":
            return getlangdata( selflang ,
                "Zombie spawning (ZAI mode only)" );

        case "discodancer":
            return getlangdata( selflang ,
                "Disco Dancer" );

        case "soccerball":
            return getlangdata( selflang ,
                "Soccer ball (Physics enabled)" );

        case "mysterybox":
            return getlangdata( selflang ,
                "Mystery box" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // attractions
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "attractions":
            return getlangdata( selflang ,
                "Attractions" );

        case "theclaw":
            return getlangdata( selflang ,
                "The claw" );

        case "rollercoaster":
            return getlangdata( selflang ,
                "Roller coaster" );

        case "ferriswheel":
            return getlangdata( selflang ,
                "Ferris wheel" );

        case "changespeedferriswheel":
            return getlangdata( selflang ,
                "Change ferris wheel rotate speed" );

        case "merrygoround":
            return getlangdata( selflang ,
                "Merry-go-round" );

        case "changespeedmerrygoround":
            return getlangdata( selflang ,
                "Change merry-go-round rotate speed" );

        case "centrox":
            return getlangdata( selflang ,
                "Centrox" );

        case "vertigo":
            return getlangdata( selflang ,
                "Vertigo" );

        case "twister":
            return getlangdata( selflang ,
                "Twister" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // playersmenu , allplayersmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //


        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // messagesmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "doheart":
            return getlangdata( selflang ,
                "Do Heart" );

        case "sendmessageloop":
            return getlangdata( selflang ,
                "Show loop message to everyone" );

        case "updatemessagetext":
            return getlangdata( selflang ,
                "Update message text" );

        case "yourpromotion":
            return getlangdata( selflang ,
                "HiNAtyu promotion" );

        case "yourpromotion2":
            return getlangdata( selflang ,
                "HiNAtyu promotion type 2" );

        case "yourpromotionmessage": return getmttext( selflang , "projectname" ) + " ^7: ^2https://www.youtube.com/channel/UCmxJAnVPtkStQVKrvAVMZSw";
        case "yourpromotionmessage2": return "[{iw}] ^3Discord ID ^7: ^2hinatapoko ^7[{atvi}] ^1YouTube ^7: ^5HiNAtyu Studio ^7[{iw}]";

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // gamesettingsmenu
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //

        case "superjump":
            return getlangdata( selflang ,
                "Super jump" );

        case "speedhack":
            return getlangdata( selflang ,
                "Speed hack" );

        case "autogivecohost":
            return getlangdata( selflang ,
                "Automatically grant Co-Host" );

        case "forcerespawnpoint":
            return getlangdata( selflang ,
                "Force respawn point" );

        case "fastrestrat":
            return getlangdata( selflang ,
                "Fast restrat" );

        case "pausetimer":
            return getlangdata( selflang ,
                "Pause timer" );

        case "endgame":
            return getlangdata( selflang ,
                "End game" );

        case "ending":
            return getlangdata( selflang ,
                "Ending" );

        case "changejumpheight":
            return getlangdata( selflang ,
                "Change jump height" );

        case "changespeedscale":
            return getlangdata( selflang ,
                "Change movement speed scale" );

        case "nofalldamage":
            return getlangdata( selflang ,
                "Fall damage height" );

        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // quickscopelobby
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //


        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // michaelmyers
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //


        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // zombiesmode
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //


        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // squidgamedarumaover
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //


        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // squidgamesteppingstones
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //



        default:
            if ( !isdefined( textid ) ) textid = "";
            return textid;
    }
    
    if ( !isdefined( textid ) ) textid = "";
    return textid;
}