// IW9 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

init()
{
    level.player notifyonplayercommand( "melee_pressed", "+melee" );
    level.player notifyonplayercommand( "melee_pressed", "+melee_zoom" );
    level.player notifyonplayercommand( "melee_pressed", "+melee_breath" );
    level.interactive_doors = spawnstruct();
    level.interactive_doors.ents = [];
    level.interactive_doors.got_hint = 0;
    level.interactive_doors.close_prompt = 0;
    level.interactive_doors._id_14D787A28FBF2062 = 0;
    level.interactive_doors.fndoorinit = scripts\sp\door_internal::init_door_internal;
    level.interactive_doors.fnshoulddogesture = scripts\sp\door_internal::should_do_gesture;
    level.interactive_doors.gesture_door = "ges_door_push_directional";
    level.interactive_doors.gesture_door_hard = "ges_door_push_directional_hard";
    level.interactive_doors.gesture_window = "ges_zg_wallbreach_mantle_left";
    level.interactive_doors.count = 0;
    level.interactive_doors.hint_dist_scale = 1;

    if ( isdefined( level.door_hint_dist_scale ) )
        level.interactive_doors.hint_dist_scale = level.door_hint_dist_scale;

    setdvarifuninitialized( "dvar_0FB93587642C681F", 0 );
    setdvarifuninitialized( "dvar_E76702AF051FCB2B", 0 );
    setdvarifuninitialized( "dvar_6109644D57E1122E", 0 );
    scripts\engine\utility::flag_init( "door_first_interact" );
    scripts\engine\utility::flag_init( "door_second_interact" );
    scripts\engine\utility::flag_init( "door_bashed" );
    scripts\engine\utility::flag_init( "did_door_hint" );
    scripts\engine\utility::flag_init( "interactive_doors_ready_internal" );
    scripts\engine\utility::flag_init( "interactive_doors_ready" );
    scripts\engine\utility::flag_init( "door_exceed_hint_dist" );
    scripts\engine\sp\utility::add_hint_string( "door_hint_2", &"SCRIPT/DOOR_HINT_BASH" );
    scripts\engine\sp\utility::add_hint_string( "door_hint_obstructed", &"SCRIPT/DOOR_HINT_OBSTRUCTED" );
    level thread scripts\engine\scriptable_door::system_init();
    level.player thread scripts\sp\door_internal::door_watch_unresolved_collision_count();
    scripts\game\sp\door::init();
    thread scripts\sp\door_internal::door_post_load();
    _id_57669CF147DF1AC5 = scripts\engine\utility::getstructarray( "interactive_window", "targetname" );
    scripts\engine\utility::array_thread( _id_57669CF147DF1AC5, scripts\sp\door_internal::init_window );
}

get_interactive_door( targetname )
{
    scripts\engine\utility::flag_wait( "interactive_doors_ready" );
    doors = [];

    foreach ( door in level.interactive_doors.ents )
    {
        if ( isdefined( door.targetname ) && door.targetname == targetname )
            doors[doors.size] = door;
    }

    if ( !doors.size )
        return undefined;

    if ( doors.size == 1 )
        return doors[0];
}

get_interactive_door_array( targetname )
{
    scripts\engine\utility::flag_wait( "interactive_doors_ready" );
    doors = [];

    foreach ( door in level.interactive_doors.ents )
    {
        if ( !isdefined( door.targetname ) )
            continue;

        if ( door.targetname != targetname )
            continue;

        doors[doors.size] = door;
    }

    if ( !doors.size )
        return [];

    return doors;
}

unlock_all_doors( _id_9F704873A9F92E7A )
{
    scripts\engine\utility::flag_wait( "interactive_doors_ready" );

    foreach ( door in level.interactive_doors.ents )
    {
        if ( door.locked )
            door unlock_door( _id_9F704873A9F92E7A );
    }
}

unlock_door( _id_9F704873A9F92E7A )
{
    if ( isdefined( _id_9F704873A9F92E7A ) && !_id_9F704873A9F92E7A )
        return;

    self notify( "stop_open_interact" );
    self notify( "door_unlock" );
    self.locked = 0;

    if ( _id_BB083055639ABCF3() )
        return;

    if ( !isdefined( self.doubledoors ) || self == self.doubledoors[0] )
    {
        self.open_struct remove_open_interact_hint();
        self.open_struct.no_open_interact = undefined;
        self.open_struct scripts\engine\utility::delaythread( 0.05, scripts\sp\door_internal::open_struct_logic );
        self.open_struct scripts\engine\utility::delaythread( 0.05, scripts\sp\door_internal::refresh_open_struct );
    }

    clear_navobstacle();

    if ( isdefined( self.doubledoorother ) && self.doubledoorother.locked )
        self.doubledoorother unlock_door( _id_9F704873A9F92E7A );
}

lock_door()
{
    self notify( "stop_open_interact" );
    self notify( "door_lock" );
    self.locked = 1;

    if ( isdefined( self.unlock_volume ) && !istrue( self.unlock_volume.active ) )
        self.unlock_volume thread scripts\sp\door_internal::unlock_volume_logic();

    if ( !isdefined( self.doubledoors ) || self == self.doubledoors[0] )
        self.open_struct scripts\engine\utility::delaythread( 0.05, scripts\sp\door_internal::open_struct_logic );

    if ( isdefined( self.navobstacle ) )
    {
        destroynavobstacle( self.navobstacle );
        self.navobstacle = undefined;
    }

    create_navobstacle();

    if ( isdefined( self.doubledoorother ) && !self.doubledoorother.locked )
        self.doubledoorother lock_door();
}

init_max_yaws()
{
    scripts\sp\door_internal::get_max_yaw( 1 );
    scripts\sp\door_internal::get_max_yaw( 0 );
    scripts\engine\utility::ent_flag_set( "initialized" );
}

remove_open_ability()
{
    self notify( "stop_bash_monitor" );
    self notify( "stop_open_ability" );
    remove_open_prompts();
}

should_open_left( angles, opener )
{
    if ( !isdefined( opener ) )
        opener = scripts\engine\utility::ter_op( isdefined( self.opener ), self.opener, level.player );

    open_left = undefined;
    origin = self.origin;

    if ( !isdefined( angles ) )
        angles = vectortoangles( self.forward );

    if ( isdefined( self.pivot_ent ) )
    {
        origin = self.pivot_ent.origin;
        angles = self.pivot_ent.angles;
    }

    right = anglestoright( angles );
    normal = vectornormalize( opener.origin - origin );
    dot = vectordot( right, normal );

    if ( dot > 0 )
        return 1;
    else
        return 0;
}

create_open_interact_hint( custom_hint_text )
{
    _id_6891BD136297DBC2 = custom_hint_text;

    if ( !isdefined( _id_6891BD136297DBC2 ) )
    {
        _id_6891BD136297DBC2 = self.custom_hint_text;

        if ( !isdefined( _id_6891BD136297DBC2 ) )
        {
            if ( self.door scripts\sp\door_internal::door_bashable_by_player( 1 ) )
                _id_6891BD136297DBC2 = &"SCRIPT/DOOR_HINT_USE";
            else
                _id_6891BD136297DBC2 = &"SCRIPT/DOOR_HINT_USE_NO_BASH";
        }
    }

    if ( !istrue( self.openinteract ) || !isdefined( self.cursor_hint_ent ) )
    {
        if ( !istrue( self.no_open_interact ) )
        {
            scripts\sp\player\cursor_hint::create_cursor_hint( undefined, ( 0, 0, 0 ), _id_6891BD136297DBC2, 45, 200 * level.interactive_doors.hint_dist_scale, 55 * level.interactive_doors.hint_dist_scale, 0 );
            self.cursor_hint_ent setusewhenhandsoccupied( 1 );
            self.cursor_hint_ent.door = self.door;
            self.openinteract = 1;
        }
    }
    else if ( !scripts\engine\sp\utility::in_realism_mode() )
        self.cursor_hint_ent sethintstring( _id_6891BD136297DBC2 );

    if ( isdefined( level.interactive_doors._id_416A1BE63376E00C ) )
        [[ level.interactive_doors._id_416A1BE63376E00C ]]( self, custom_hint_text );

    if ( isdefined( custom_hint_text ) )
        self.custom_hint_text = custom_hint_text;
}

remove_open_interact_hint()
{
    if ( istrue( self.openinteract ) )
    {
        scripts\sp\player\cursor_hint::remove_cursor_hint();
        self.openinteract = 0;
    }

    self.no_open_interact = 1;
}

door_ajar( opener )
{
    if ( isdefined( self.door_ajar_custom_func ) )
        [[ self.door_ajar_custom_func ]]();

    self.ajar = 1;

    if ( isdefined( self.ajar_opener ) )
        opener = self.ajar_opener;
    else if ( !isdefined( opener ) )
        opener = level.player;

    if ( isplayer( opener ) )
        scripts\sp\door_internal::stealth_broadcast( "window_open", opener, 40 );

    self notify( "opening" );
    self.opener = opener;
    self.open_left = should_open_left();
    scripts\sp\door_internal::set_pivot_point( self.open_left );

    if ( isdefined( self.ajar_opener ) )
        self.opener = undefined;

    if ( isdefined( self.script_spawn_open_yaw ) )
    {
        self.pivot_ent.angles = self.pivot_ent.angles + ( 0, self.script_spawn_open_yaw, 0 );
        self notify( "ajar" );

        if ( self.script_spawn_open_yaw > 0 )
        {
            self.hinge_side = "open_left";
            self.open_left = 1;
        }
        else
        {
            self.hinge_side = "open_right";
            self.open_left = 0;
        }
    }
    else
    {
        time = 1.5;
        _id_96CC1618573AD3CC = 9;

        if ( !self.open_left )
            _id_96CC1618573AD3CC = _id_96CC1618573AD3CC * -1;

        _id_20510600314FE827 = scripts\sp\door_internal::get_door_bottom_center();

        if ( distancesquared( level.player.origin, _id_20510600314FE827 ) < 10000 )
            level.player playrumbleonentity( "damage_heavy" );

        _id_07DA6017ED0AEE8E = scripts\sp\door_internal::get_door_audio_material();
        alias = "scrpt_door_" + _id_07DA6017ED0AEE8E + "_open_soft";

        if ( soundexists( alias ) )
            self playsound( alias );

        self.pivoting = 1;
        self.pivot_ent rotateyaw( _id_96CC1618573AD3CC, time, time * 0.25, time * 0.75 );
        thread scripts\engine\sp\utility::notify_delay( "ajar", time );
        wait( time );
        self.pivoting = undefined;
    }
}

get_door_angles()
{
    if ( isdefined( self.pivot_ent ) )
        return self.pivot_ent.angles;
    else
        return self.true_start_angles;
}

angle_diff( _id_456C3AB4CCDC8D5D, _id_456C37B4CCDC86C4 )
{
    _id_4573A8725DD3748E = angleclamp180( _id_456C3AB4CCDC8D5D - _id_456C37B4CCDC86C4 );
    return _id_4573A8725DD3748E;
}

door_bash_open( opener, bashtime )
{
    self endon( "entitydeleted" );

    if ( istrue( self.bashed_full ) )
        return;

    if ( !isdefined( opener ) )
        opener = level.player;

    self.opener = opener;

    if ( opener == level.player && scripts\sp\door_internal::_id_E0B0300FBF1B645B( self ) )
    {
        scripts\sp\door_internal::bashed_locked_door( level.player getvelocity() );
        return;
    }

    if ( !scripts\engine\utility::flag( "door_bashed" ) )
        scripts\engine\utility::flag_set( "door_bashed" );

    self notify( "opening" );
    thread remove_open_prompts();
    self.open_left = should_open_left();
    scripts\sp\door_internal::set_pivot_point( self.open_left );

    if ( opener == level.player )
    {
        thread scripts\sp\door_internal::door_bash_presentation();
        level.player notify( "door_bashed", self );

        if ( !self.bashed && !self.was_opened_halfway )
            thread scripts\sp\door_internal::suspicious_door_stealth_check( 1 );
    }
    else
        self notify( "ai_opened" );

    _id_49C3FDDE93FE3889 = 1;

    if ( isdefined( self.bashscale ) && self.bashscale < 1 )
        _id_49C3FDDE93FE3889 = self.bashscale;

    self.bashed = 1;
    self notify( "bashed", opener );
    _id_62ED0570F5E80A07 = scripts\sp\door_internal::get_bash_yaw( _id_49C3FDDE93FE3889 );

    if ( _id_49C3FDDE93FE3889 == 1 && !istrue( self.bashblocked ) )
    {
        self notify( "bashed_full" );
        self.bashed_full = 1;
    }

    _id_077B9E4B599269EB = _id_62ED0570F5E80A07 - self.true_start_angles[1];

    if ( !isdefined( bashtime ) )
    {
        if ( _id_49C3FDDE93FE3889 == 1 )
        {
            _id_11B200101076BC6C = 0.25;
            _id_5E7A100369FAFE1E = 0.5;
        }
        else
        {
            _id_11B200101076BC6C = 0.4;
            _id_5E7A100369FAFE1E = 0.75;
        }

        _id_805136F88545A0DB = scripts\engine\math::normalize_value( 0, 170, abs( _id_077B9E4B599269EB ) );
        bashtime = scripts\engine\math::factor_value( _id_11B200101076BC6C, _id_5E7A100369FAFE1E, _id_805136F88545A0DB );
    }

    self.bashtime = bashtime;
    _id_73D0C62EE90EF3C3 = get_door_angles();
    open_angles = ( _id_73D0C62EE90EF3C3[0], _id_62ED0570F5E80A07, _id_73D0C62EE90EF3C3[2] );
    _id_07DA6017ED0AEE8E = scripts\sp\door_internal::get_door_audio_material();
    alias = "scrpt_door_" + _id_07DA6017ED0AEE8E + "_bash";

    if ( soundexists( alias ) )
        playworldsound( alias, self.origin + ( 0, 0, 30 ) );

    self.bash_opening = 1;
    self.pivoting = 1;

    if ( _id_49C3FDDE93FE3889 == 1 )
        self.pivot_ent rotateto( open_angles, bashtime );
    else
        self.pivot_ent rotateto( open_angles, bashtime, 0, bashtime );

    thread scripts\engine\sp\utility::notify_delay( "open", bashtime );
    wait( bashtime );
    self.opener notify( "opened_door" );
    thread updatenavobstacle();
    scripts\sp\door_internal::updatenodelookpeek();

    if ( opener == level.player )
    {
        _id_9836DF1FB7E76589 = 450;

        if ( isdefined( level._id_7D3D0935E9DE042A ) )
            _id_9836DF1FB7E76589 = level._id_7D3D0935E9DE042A;

        if ( isdefined( level.stealth ) )
            thread scripts\sp\door_internal::stealth_broadcast( "door_bash", level.player, _id_9836DF1FB7E76589 );
        else
            thread scripts\sp\door_internal::combat_getinfoinradius( _id_9836DF1FB7E76589 );
    }

    if ( _id_49C3FDDE93FE3889 == 1 && abs( _id_077B9E4B599269EB ) > 100 && !istrue( self.disable_bounceback ) )
    {
        self playsound( "door_hit_wall" );
        self.active = 0;
        _id_B492B99EB62E16F2 = randomfloatrange( 3, 5 );
        _id_6E09CABEB82B5356 = scripts\engine\utility::ter_op( self.open_left, -3, 3 );
        alias = "scrpt_door_" + _id_07DA6017ED0AEE8E + "_creak_lp";

        if ( soundexists( alias ) )
            self playloopsound( alias );

        self _meth_F4604329F388A96F( 0, _id_B492B99EB62E16F2 );
        self.pivot_ent rotateto( open_angles + ( 0, _id_6E09CABEB82B5356, 0 ), _id_B492B99EB62E16F2, 0.5, _id_B492B99EB62E16F2 - 0.5 );
        wait( _id_B492B99EB62E16F2 );
        self stoploopsound();
        thread updatenavobstacle();
    }
    else
        wait 0.05;

    self.pivoting = undefined;
    thread scripts\sp\door_internal::close_prompt();
    self.bash_opening = undefined;
    self.bashblocked = undefined;
}

remove_open_prompts()
{
    self.open_struct remove_open_interact_hint();
}

_id_741259A03199B7F5( opener, _id_96CC1618573AD3CC, time )
{
    if ( istrue( self.open_complete ) )
        return;

    if ( !isdefined( self.pivot_ent ) )
    {
        if ( isdefined( opener ) )
        {
            self.opener = opener;
            self.ajar_opener = opener;
        }

        self notify( "first_interact" );
        remove_open_prompts();

        while ( !isdefined( self.pivot_ent ) )
            wait 0.05;
    }

    if ( !self.open_left )
        _id_96CC1618573AD3CC = _id_96CC1618573AD3CC * -1;

    self.pivot_ent rotateyaw( _id_96CC1618573AD3CC, time, time * 0.25, time * 0.75 );
    remove_open_prompts();
}

door_open_completely( opener, time )
{
    scripts\engine\utility::flag_wait( "interactive_doors_ready" );
    self notify( "stop_push_open" );
    self notify( "stop_bash_monitor" );
    self notify( "close_prompt" );
    self notify( "stop_open_interact" );
    self notify( "opening" );
    self endon( "stop_monitoring_open_completely" );
    self endon( "entitydeleted" );
    remove_open_prompts();
    self.open_completely = 1;

    if ( !scripts\engine\utility::flag( "door_second_interact" ) && isdefined( opener ) && opener == level.player )
        scripts\engine\utility::flag_set( "door_second_interact" );

    if ( isdefined( opener ) )
        self.opener = opener;

    self notify( "opened_completely", opener );
    _id_EE65ACC756212405 = scripts\engine\utility::ter_op( isplayer( opener ), 1, 0 );

    if ( isai( self.opener ) )
        self notify( "ai_opened" );

    if ( isdefined( opener ) || !isdefined( self.open_left ) )
        self.open_left = should_open_left();

    scripts\sp\door_internal::set_pivot_point( self.open_left );
    _id_1CAFFBB3C5BC7BC1 = undefined;

    if ( self.open_left )
        _id_1CAFFBB3C5BC7BC1 = self.true_start_angles[1] + self.max_yaw_left;
    else
        _id_1CAFFBB3C5BC7BC1 = self.true_start_angles[1] - self.max_yaw_right;

    _id_07DA6017ED0AEE8E = scripts\sp\door_internal::get_door_audio_material();
    alias = scripts\engine\utility::ter_op( isplayer( opener ), "scrpt_door_" + _id_07DA6017ED0AEE8E + "_open_wide", "scrpt_door_" + _id_07DA6017ED0AEE8E + "_open_wide_npc" );

    if ( soundexists( alias ) )
        self playsound( alias );

    self.pivoting = 1;
    time = scripts\engine\utility::_id_53C4C53197386572( time, 1.5 );

    if ( time < 0.05 )
        self.pivot_ent.angles = ( self.angles[0], _id_1CAFFBB3C5BC7BC1, self.angles[2] );
    else
    {
        if ( time > 0.05 )
        {
            accel = time * 0.25;
            decel = time * 0.75;

            if ( !_id_EE65ACC756212405 )
                accel = 0;
        }
        else
        {
            accel = 0;
            decel = 0;
        }

        self.pivot_ent rotateto( ( self.angles[0], _id_1CAFFBB3C5BC7BC1, self.angles[2] ), time, accel, decel );
    }

    self notify( "stop_door_creak" );
    thread scripts\engine\sp\utility::notify_delay( "open", time );

    if ( isdefined( self.opener ) )
        self.opener notify( "opened_door" );

    if ( time >= 0.05 )
        wait( time );

    self.pivoting = undefined;
    thread scripts\sp\door_internal::suspicious_door_stealth_check( _id_EE65ACC756212405 );
    thread updatenavobstacle();
    scripts\sp\door_internal::updatenodelookpeek();
    self.active = 0;

    if ( _id_EE65ACC756212405 )
        scripts\sp\door_internal::stealth_broadcast( "window_open", level.player, 128 );

    thread scripts\sp\door_internal::close_prompt();
}

door_close( _id_EEE718E33217DC9E, time, accel, decel )
{
    self notify( "door_close" );

    if ( !isdefined( self.pivot_ent ) )
        return;

    if ( !isdefined( time ) )
        time = 1.5;

    if ( !isdefined( accel ) )
        accel = time * 0.25;

    if ( !isdefined( decel ) )
        decel = time * 0.25;

    self.pivoting = 1;
    self.pivot_ent rotateto( ( self.angles[0], self.true_start_angles[1], self.angles[2] ), time, accel, decel );
    wait( time );
    self.pivoting = undefined;
    thread updatenavobstacle();
    scripts\sp\door_internal::updatenodelookpeek();
    scripts\sp\door_internal::suspicious_door_stealth_check( 0 );
}

reset_door()
{
    self notify( "stop_door_creak" );
    self notify( "reset_door" );

    if ( isdefined( self.pivot_ent ) )
        self.pivot_ent.angles = ( self.pivot_ent.angles[0], self.true_start_angles[1], self.pivot_ent.angles[2] );

    thread updatenavobstacle();
    scripts\sp\door_internal::suspicious_door_stealth_check( 0 );
    scripts\engine\utility::flag_clear( "door_bashed" );
    scripts\engine\utility::flag_clear( "did_door_hint" );
    scripts\engine\utility::flag_clear( "door_second_interact" );
    self thread [[ level.interactive_doors.fndoorinit ]]( 1 );
}

updatenavobstacle( _id_E300BCFA70C7B408 )
{
    if ( isdefined( self.updatingnavobstacle ) )
        return;

    waitframe();
    self.updatingnavobstacle = 1;

    if ( isdefined( self.navobstacle ) )
        destroynavobstacle( self.navobstacle );

    if ( istrue( self.locked ) && isdefined( self.clip ) )
    {
        clear_navobstacle();
        create_navobstacle();
    }
    else if ( istrue( self.bashed_full ) || istrue( self.open_completely ) || istrue( _id_E300BCFA70C7B408 ) )
    {
        if ( isdefined( self.clip ) )
            self.navobstacle = createnavbadplacebyent( self.clip, 14 );

        if ( isdefined( self.navobstacle ) )
        {

        }
        else
        {

        }

        _id_306D8B5B030998E9 = get_door_angles();
        self.nav_lastupdatetime = gettime();
        self.nav_lastupdateangle = _id_306D8B5B030998E9[1];
    }

    self.updatingnavobstacle = undefined;
}

clear_navobstacle()
{
    if ( !isdefined( self.navobstacleid ) )
        return;

    destroynavobstacle( self.navobstacleid );
    self.navobstacleid = undefined;

    if ( isdefined( level.stealth ) && isdefined( self.opener ) && self.opener == level.player )
        scripts\sp\door_internal::suspicious_door_stealth_check( 1 );
}

create_navobstacle()
{
    if ( isdefined( self.navobstacleid ) )
        return;

    switch ( self.team )
    {
        case "allies":
            self.navobstacleid = createnavbadplacebyent( self.clip, "axis", "team3", "neutral" );
            break;
        case "axis":
            self.navobstacleid = createnavbadplacebyent( self.clip, "allies", "team3", "neutral" );
            break;
        case "neutral":
            self.navobstacleid = createnavbadplacebyent( self.clip, "axis", "team3", "allies" );
            break;
        case "team3":
            self.navobstacleid = createnavbadplacebyent( self.clip, "axis", "allies", "neutral" );
            break;
        case "neutral axis":
        case "axis neutral":
            self.navobstacleid = createnavbadplacebyent( self.clip, "allies", "team3" );
            break;
        default:
            self.navobstacleid = createnavobstaclebyent( self.clip );
            break;
    }
}

delete_door()
{
    self notify( "unusable" );
    remove_open_ability();

    if ( isdefined( self.clip_nosight ) )
        self.clip_nosight delete();

    if ( self.classname == "script_model" )
        self.clip delete();

    if ( isdefined( self.pivot_ent ) )
        self.pivot_ent delete();

    if ( isdefined( self.navmodifier ) )
    {
        destroynavobstacle( self.navmodifier );
        self.navmodifer = undefined;
    }

    if ( isdefined( self.linked_ents ) )
    {
        foreach ( ent in self.linked_ents )
            ent delete();

        self.linked_ents = [];
    }

    level.interactive_doors.ents = scripts\engine\utility::array_remove( level.interactive_doors.ents, self );
    self delete();
}

get_all_bashable_doors()
{
    a = [];

    foreach ( door in level.interactive_doors.ents )
    {
        if ( !door scripts\engine\utility::ent_flag( "initialized" ) )
            continue;

        if ( door.bashed || door.open_completely || door.breached || door scripts\sp\door_internal::door_is_half_open() )
            continue;

        a[a.size] = door;
    }

    return a;
}

get_all_doors_ai_should_open()
{
    a = [];

    foreach ( door in level.interactive_doors.ents )
    {
        if ( !door scripts\engine\utility::ent_flag( "initialized" ) )
            continue;

        if ( door.bashed || door.open_completely || door.breached || door scripts\sp\door_internal::door_is_open_at_least( 60 ) )
            continue;

        a[a.size] = door;
    }

    return a;
}

get_all_closed_doors()
{
    a = [];

    foreach ( door in level.interactive_doors.ents )
    {
        if ( door.bashed || door.ajar || door.open_completely || door.breached )
            continue;

        a[a.size] = door;
    }

    return a;
}

get_all_interactive_doors()
{
    return level.interactive_doors.ents;
}

get_all_interactive_doors_blocking_paths( team )
{
    a = [];

    foreach ( door in level.interactive_doors.ents )
    {
        if ( isdefined( door.navobstacleid ) && !issubstr( door.team, team ) )
            a[a.size] = door;
    }

    return a;
}

bash_monitor()
{
    self notify( "bash_monitor" );
    self endon( "bash_monitor" );
    self endon( "reset_door" );
    self endon( "entitydeleted" );
    self endon( "stop_bash_monitor" );

    for (;;)
    {
        if ( bash_door_isplayerclose() && scripts\sp\door_internal::should_bash_open() )
        {
            self notify( "attempt_bash", level.player );
            thread door_bash_open();

            if ( !self.locked )
                return;
        }

        wait 0.05;
    }
}

interact_door_ispushentclose()
{
    _id_1B7AE3FFB4D76416 = scripts\sp\door_internal::get_pushent();
    z = abs( _id_1B7AE3FFB4D76416.origin[2] - self.origin[2] );

    if ( z < 20 )
    {
        endpoint = scripts\sp\door_internal::interact_door_get_endpoint();
        _id_AC0E564AC96A9D0F = distancesquared( _id_1B7AE3FFB4D76416.origin, endpoint );

        if ( _id_AC0E564AC96A9D0F < 1296 )
            return 1;
    }

    return 0;
}

interact_door_dopusheffects()
{
    z = abs( level.player.origin[2] - self.origin[2] );

    if ( z < 20 )
    {
        endpoint = scripts\sp\door_internal::interact_door_get_endpoint();
        _id_AC0E564AC96A9D0F = distancesquared( level.player.origin, endpoint );

        if ( _id_AC0E564AC96A9D0F < 14400 )
            return 1;
    }

    return 0;
}

interact_door_isplayerfacing()
{
    endpoint = scripts\sp\door_internal::interact_door_get_endpoint();
    _id_FAE2F8846758E0E9 = pointonsegmentnearesttopoint( endpoint, self.origin, level.player.origin );
    _id_77A717FB21082E1D = vectornormalize( _id_FAE2F8846758E0E9 - level.player.origin );
    _id_9C265C88DBE9AB48 = anglestoforward( level.player.angles );

    if ( vectordot( _id_77A717FB21082E1D, _id_9C265C88DBE9AB48 ) > 0.7 )
        return 1;

    return 0;
}

bash_door_isplayerclose()
{
    z = abs( level.player.origin[2] - self.origin[2] );

    if ( z < 20 )
    {
        endpoint = self.doorbottomcenter;

        if ( !isdefined( endpoint ) )
            endpoint = self.origin;

        _id_AC0E564AC96A9D0F = distancesquared( level.player.origin, endpoint );
        range = scripts\engine\utility::ter_op( self.locked == 1, 60, 60 );

        if ( _id_AC0E564AC96A9D0F < range * range )
            return 1;
    }

    return 0;
}

_id_89BE9FAC0C81F3AA()
{
    scripts\engine\utility::flag_wait( "interactive_doors_ready_internal" );
    _id_351596AE890D5CA6 = sortbydistance( scripts\engine\utility::array_remove( level.interactive_doors.ents, self ), self.origin )[0];
    thread double_doors_init( self, _id_351596AE890D5CA6 );
}

double_doors_init_targetname( targetname )
{
    _id_462D1D167186A54F = get_interactive_door( targetname );
    _id_5C56F786A64D1294 = get_interactive_door( targetname + "_right" );
    return double_doors_init( _id_462D1D167186A54F, _id_5C56F786A64D1294 );
}

double_doors_init( _id_462D1D167186A54F, _id_5C56F786A64D1294 )
{
    doors[0] = _id_462D1D167186A54F;
    doors[1] = _id_5C56F786A64D1294;
    _id_462D1D167186A54F.doubledoorother = _id_5C56F786A64D1294;
    _id_462D1D167186A54F.doubledoors = doors;
    _id_462D1D167186A54F thread scripts\sp\door_internal::double_doors_waittill_interact();
    _id_462D1D167186A54F thread scripts\sp\door_internal::double_doors_waittill_bashed();
    _id_462D1D167186A54F thread scripts\sp\door_internal::double_doors_hint_pos( _id_5C56F786A64D1294 );
    _id_462D1D167186A54F thread scripts\sp\door_internal::double_doors_waittill_open_completely();
    _id_5C56F786A64D1294 remove_open_prompts();
    _id_5C56F786A64D1294.doubledoorother = _id_462D1D167186A54F;
    _id_5C56F786A64D1294.doubledoors = doors;
    _id_5C56F786A64D1294 thread scripts\sp\door_internal::double_doors_waittill_bashed();
    _id_5C56F786A64D1294 thread scripts\sp\door_internal::double_doors_waittill_open_completely();

    if ( _id_5C56F786A64D1294.locked && isdefined( _id_5C56F786A64D1294.unlock_volume ) )
    {
        _id_5C56F786A64D1294 notify( "unlock_volume_logic" );
        _id_5C56F786A64D1294.unlock_volume thread scripts\sp\door_internal::unlock_volume_logic();
    }

    return _id_462D1D167186A54F.doubledoors;
}

_id_BB083055639ABCF3()
{
    angle_diff = angle_diff( get_door_angles()[1], self.true_start_angles[1] );

    if ( abs( angle_diff ) > 0 )
        return 1;

    return 0;
}

ai_monitor_doors()
{
    self endon( "death" );

    for (;;)
    {
        result = scripts\engine\utility::waittill_any_return( "path_has_door", "opened_door", "opening_door_done", "reset_door_check" );
        scripts\engine\utility::flag_wait( "interactive_doors_ready" );
        self notify( "stop_current_door" );

        if ( istrue( self.isopeningdoor ) )
            continue;

        if ( isdefined( self.waitingfordoor ) )
        {
            if ( isdefined( result ) && result == "path_set" && isdefined( self.doornode ) && isdefined( self.pathgoalpos ) && distance2dsquared( self.pathgoalpos, self.doornode.origin ) < 4 )
                continue;

            scripts\sp\door_ai::stop_waiting_for_door();
        }

        scripts\sp\door_ai::remove_as_opener();
        _id_2E400C7EB43F6073 = 0;
        _id_67118F25059BDB25 = undefined;
        _id_9C801EB4FD980582 = undefined;

        for (;;)
        {
            _id_67118F25059BDB25 = self getmodifierlocationonpath( "door" );

            if ( isdefined( _id_67118F25059BDB25 ) )
            {
                _id_9C801EB4FD980582 = scripts\sp\door_ai::get_closed_door_closest_to_nav_modifier( _id_67118F25059BDB25 );

                if ( isdefined( _id_9C801EB4FD980582 ) )
                {
                    _id_20510600314FE827 = _id_9C801EB4FD980582 scripts\sp\door_internal::get_door_bottom_center();

                    if ( distancesquared( self.origin, _id_20510600314FE827 ) < 400 )
                    {
                        _id_5C6AFC1001475042 = vectornormalize( _id_20510600314FE827 - self.origin );

                        if ( vectordot( self.lookaheaddir, _id_5C6AFC1001475042 ) < -0.707 )
                        {
                            wait 2;
                            continue;
                        }
                    }

                    _id_2E400C7EB43F6073 = 1;
                    break;
                }
                else
                {
                    wait 0.2;
                    continue;
                }
            }
            else
                break;

            if ( _id_2E400C7EB43F6073 )
                break;

            wait 0.05;
        }

        if ( !_id_2E400C7EB43F6073 )
            continue;

        scripts\sp\door_ai::door_add_opener( _id_9C801EB4FD980582 );
        _id_9C801EB4FD980582 thread scripts\sp\door_ai::door_manage_openers();
    }
}

add_pushent( ent )
{
    if ( !isdefined( self.pushents ) )
        self.pushents = [];

    self.pushents[self.pushents.size] = ent;
}
