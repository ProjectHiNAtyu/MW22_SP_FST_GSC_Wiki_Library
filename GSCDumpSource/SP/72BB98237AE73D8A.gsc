// IW9 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

init_mgturretsettings()
{
    level.mgturretsettings["easy"]["convergenceTime"] = 2.5;
    level.mgturretsettings["easy"]["suppressionTime"] = 3.0;
    level.mgturretsettings["easy"]["accuracy"] = 0.38;
    level.mgturretsettings["easy"]["aiSpread"] = 2;
    level.mgturretsettings["easy"]["playerSpread"] = 0.5;
    level.mgturretsettings["medium"]["convergenceTime"] = 1.5;
    level.mgturretsettings["medium"]["suppressionTime"] = 3.0;
    level.mgturretsettings["medium"]["accuracy"] = 0.38;
    level.mgturretsettings["medium"]["aiSpread"] = 2;
    level.mgturretsettings["medium"]["playerSpread"] = 0.5;
    level.mgturretsettings["hard"]["convergenceTime"] = 0.8;
    level.mgturretsettings["hard"]["suppressionTime"] = 3.0;
    level.mgturretsettings["hard"]["accuracy"] = 0.38;
    level.mgturretsettings["hard"]["aiSpread"] = 2;
    level.mgturretsettings["hard"]["playerSpread"] = 0.5;
    level.mgturretsettings["fu"]["convergenceTime"] = 0.4;
    level.mgturretsettings["fu"]["suppressionTime"] = 3.0;
    level.mgturretsettings["fu"]["accuracy"] = 0.38;
    level.mgturretsettings["fu"]["aiSpread"] = 2;
    level.mgturretsettings["fu"]["playerSpread"] = 0.5;
}

main()
{
    if ( getdvar( "dvar_5788A4B3D780018C" ) == "" )
        setdvar( "dvar_472300A87F74AF60", "off" );

    level.magic_distance = 24;
    scripts\engine\utility::create_func_ref( "turret_disableLinkedTurretAngles", ::mgturret_disablelinkedturretangles );
    scripts\engine\utility::create_func_ref( "turret_enableLinkedTurretAngles", ::mgturret_enablelinkedturretangles );
    _id_9A39CC051BA6158C = getentarray( "turretInfo", "targetname" );

    for ( index = 0; index < _id_9A39CC051BA6158C.size; index++ )
        _id_9A39CC051BA6158C[index] delete();

    scripts\engine\utility::create_lock( "mg42_drones" );
    scripts\engine\utility::create_lock( "mg42_drones_target_trace" );
    thread auto_mgturretlink();
    thread saw_mgturretlink();
    thread turretinits();
}

mgturret_disablelinkedturretangles()
{
    level.player _meth_A3A7EE234C375801();
}

mgturret_enablelinkedturretangles()
{
    level.player _meth_FD77469AE88CF138();
}

turretinits()
{
    _id_9DFB2D4326B2CB1A = getentarray( "misc_turret", "code_classname" );
    _id_ADAFFF1D14CAC7CB = [];

    foreach ( _id_9869BC1AF26D720D in _id_9DFB2D4326B2CB1A )
        _id_ADAFFF1D14CAC7CB = scripts\engine\utility::array_add( _id_ADAFFF1D14CAC7CB, _id_9869BC1AF26D720D );

    foreach ( turret in _id_ADAFFF1D14CAC7CB )
    {
        if ( isdefined( turret.targetname ) && turret.targetname == "zulu23_turret" )
            turret thread zuluinit();
    }
}

portable_mg_behavior()
{
    self detach( "weapon_mg42_carry", "tag_origin" );
    self endon( "death" );
    self.goalradius = level.default_goalradius;

    if ( isdefined( self.target ) )
    {
        node = getnode( self.target, "targetname" );

        if ( isdefined( node ) )
        {
            if ( isdefined( node.radius ) )
                self.goalradius = node.radius;

            self setgoalnode( node );
        }
    }

    while ( !isdefined( self.node ) )
        wait 0.05;

    _id_643B764A9F01A3F0 = undefined;

    if ( isdefined( self.target ) )
    {
        node = getnode( self.target, "targetname" );
        _id_643B764A9F01A3F0 = node;
    }

    if ( !isdefined( _id_643B764A9F01A3F0 ) )
        _id_643B764A9F01A3F0 = self.node;

    if ( !isdefined( _id_643B764A9F01A3F0 ) )
        return;

    if ( _id_643B764A9F01A3F0.type != "Turret" )
        return;

    _id_B64A2C06FA3074BE = gettakennodes();
    _id_B64A2C06FA3074BE[self.node.origin + ""] = undefined;

    if ( isdefined( _id_B64A2C06FA3074BE[_id_643B764A9F01A3F0.origin + ""] ) )
        return;

    turret = _id_643B764A9F01A3F0.turret;

    if ( isdefined( turret.reserved ) )
        return;

    reserve_turret( turret );

    if ( turret.issetup )
        leave_gun_and_run_to_new_spot( turret );
    else
        run_to_new_spot_and_setup_gun( turret );

    scripts\sp\mg_penetration::gunner_think( _id_643B764A9F01A3F0.turret );
}

mg42_trigger()
{
    self waittill( "trigger" );
    level notify( self.targetname );
    level.mg42_trigger[self.targetname] = 1;
    self delete();
}

mgturret_auto( trigger )
{
    trigger waittill( "trigger" );
    ai = getaiarray( "bad_guys" );

    for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < ai.size; _id_AC0E594AC96AA3A8++ )
    {
        if ( isdefined( ai[_id_AC0E594AC96AA3A8].script_mg42auto ) && trigger.script_mg42auto == ai[_id_AC0E594AC96AA3A8].script_mg42auto )
            ai[_id_AC0E594AC96AA3A8] notify( "auto_ai" );
    }

    spawners = _func_91E8F01DD90DE05A();

    for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < spawners.size; _id_AC0E594AC96AA3A8++ )
    {
        if ( isdefined( spawners[_id_AC0E594AC96AA3A8].script_mg42auto ) && trigger.script_mg42auto == spawners[_id_AC0E594AC96AA3A8].script_mg42auto )
            spawners[_id_AC0E594AC96AA3A8].ai_mode = "auto_ai";
    }

    scripts\sp\spawner::kill_trigger( trigger );
}

mg42_suppressionfire( targets )
{
    self endon( "death" );
    self endon( "stop_suppressionFire" );

    if ( !isdefined( self.suppresionfire ) )
        self.suppresionfire = 1;

    for (;;)
    {
        while ( self.suppresionfire )
        {
            self settargetentity( targets[randomint( targets.size )] );
            wait( 2 + randomfloat( 2 ) );
        }

        self cleartargetentity();

        while ( !self.suppresionfire )
            wait 1;
    }
}

manual_think( mg42 )
{
    org = self.origin;
    self waittill( "auto_ai" );
    mg42 notify( "stopfiring" );
    mg42 setmode( "auto_ai" );
    mg42 settargetentity( level.player );
}

burst_fire_settings( _id_8C958BDE9A9F8547 )
{
    if ( _id_8C958BDE9A9F8547 == "delay" )
        return 0.2;
    else if ( _id_8C958BDE9A9F8547 == "delay_range" )
        return 0.5;
    else if ( _id_8C958BDE9A9F8547 == "burst" )
        return 0.5;
    else if ( _id_8C958BDE9A9F8547 == "burst_fire_rate" )
        return 0.1;
    else
        return 1.5;
}

burst_fire_unmanned()
{
    self endon( "death" );
    self endon( "stop_burst_fire_unmanned" );

    if ( isdefined( self.script_delay_min ) )
        _id_3F0FA03E0F609BBF = self.script_delay_min;
    else
        _id_3F0FA03E0F609BBF = burst_fire_settings( "delay" );

    if ( isdefined( self.script_delay_max ) )
        _id_E7C2ECA166FF3355 = self.script_delay_max - _id_3F0FA03E0F609BBF;
    else
        _id_E7C2ECA166FF3355 = burst_fire_settings( "delay_range" );

    if ( isdefined( self.script_burst_min ) )
        _id_4CA5C9052A24E336 = self.script_burst_min;
    else
        _id_4CA5C9052A24E336 = burst_fire_settings( "burst" );

    if ( isdefined( self.script_burst_max ) )
        _id_2B8F70C634712F60 = self.script_burst_max - _id_4CA5C9052A24E336;
    else
        _id_2B8F70C634712F60 = burst_fire_settings( "burst_range" );

    if ( isdefined( self.script_burst_fire_rate ) )
        _id_8651842FB899F562 = self.script_burst_fire_rate;
    else
        _id_8651842FB899F562 = burst_fire_settings( "burst_fire_rate" );

    _id_87EECD5C7B6C593A = gettime();
    _id_B0AE7789423CB4D4 = "start";

    if ( isdefined( self.shell_fx ) )
        thread turret_shell_fx();

    for (;;)
    {
        duration = ( _id_87EECD5C7B6C593A - gettime() ) * 0.001;

        if ( self isfiringturret() && duration <= 0 )
        {
            if ( _id_B0AE7789423CB4D4 != "fire" )
            {
                _id_B0AE7789423CB4D4 = "fire";
                thread doshoot( _id_8651842FB899F562 );
            }

            duration = _id_4CA5C9052A24E336 + randomfloat( _id_2B8F70C634712F60 );
            thread turrettimer( duration );
            self waittill( "turretstatechange" );
            duration = _id_3F0FA03E0F609BBF + randomfloat( _id_E7C2ECA166FF3355 );
            _id_87EECD5C7B6C593A = gettime() + int( duration * 1000 );
            continue;
        }

        if ( _id_B0AE7789423CB4D4 != "aim" )
            _id_B0AE7789423CB4D4 = "aim";

        thread turrettimer( duration );
        self waittill( "turretstatechange" );
    }
}

doshoot( _id_5BA6FA0508A68649 )
{
    self endon( "death" );
    self endon( "turretstatechange" );
    fire_rate = 0.1;

    if ( isdefined( _id_5BA6FA0508A68649 ) )
        fire_rate = _id_5BA6FA0508A68649;

    for (;;)
    {
        self shootturret();
        wait( fire_rate );
    }
}

turret_shell_fx()
{
    self endon( "death" );
    self endon( "stop_burst_fire_unmanned" );

    if ( isdefined( self.shell_sound ) )
        self.shell_sound_enabled = 1;

    for (;;)
    {
        self waittill( "turret_fire" );
        playfxontag( self.shell_fx, self, "tag_origin" );

        if ( isdefined( self.shell_sound_enabled ) && self.shell_sound_enabled )
            thread turret_shell_sound();
    }
}

turret_shell_sound()
{
    self endon( "death" );
    self.shell_sound_enabled = 0;
    tag_origin = self gettagorigin( "tag_origin" );
    origin = scripts\engine\utility::drop_to_ground( tag_origin, -30 );
    dist = tag_origin[2] - origin[2];
    time = dist / 300;
    wait( time );
    playworldsound( self.shell_sound, origin );
    wait 1;
    self.shell_sound_enabled = 1;
}

turrettimer( duration )
{
    if ( duration <= 0 )
        return;

    self endon( "turretstatechange" );
    wait( duration );

    if ( isdefined( self ) )
        self notify( "turretstatechange" );
}

random_spread( ent )
{
    self endon( "death" );
    self notify( "stop random_spread" );
    self endon( "stop random_spread" );
    self endon( "stopfiring" );
    self settargetentity( ent );

    for (;;)
    {
        if ( isplayer( ent ) )
            ent.origin = self.manual_target getorigin();
        else
            ent.origin = self.manual_target.origin;

        ent.origin = ent.origin + ( 20 - randomfloat( 40 ), 20 - randomfloat( 40 ), 20 - randomfloat( 60 ) );
        wait 0.2;
    }
}

mg42_firing( mg42 )
{
    self notify( "stop_using_built_in_burst_fire" );
    self endon( "stop_using_built_in_burst_fire" );
    mg42 stopfiring();

    for (;;)
    {
        mg42 waittill( "startfiring" );
        thread burst_fire( mg42 );
        mg42 startfiring();
        mg42 waittill( "stopfiring" );
        mg42 stopfiring();
    }
}

burst_fire( mg42, manual_target )
{
    mg42 endon( "entitydeleted" );
    mg42 endon( "stopfiring" );
    self endon( "stop_using_built_in_burst_fire" );

    if ( isdefined( mg42.script_delay_min ) )
        _id_3F0FA03E0F609BBF = mg42.script_delay_min;
    else
        _id_3F0FA03E0F609BBF = burst_fire_settings( "delay" );

    if ( isdefined( mg42.script_delay_max ) )
        _id_E7C2ECA166FF3355 = mg42.script_delay_max - _id_3F0FA03E0F609BBF;
    else
        _id_E7C2ECA166FF3355 = burst_fire_settings( "delay_range" );

    if ( isdefined( mg42.script_burst_min ) )
        _id_4CA5C9052A24E336 = mg42.script_burst_min;
    else
        _id_4CA5C9052A24E336 = burst_fire_settings( "burst" );

    if ( isdefined( mg42.script_burst_max ) )
        _id_2B8F70C634712F60 = mg42.script_burst_max - _id_4CA5C9052A24E336;
    else
        _id_2B8F70C634712F60 = burst_fire_settings( "burst_range" );

    for (;;)
    {
        mg42 startfiring();

        if ( isdefined( manual_target ) )
            mg42 thread random_spread( manual_target );

        wait( _id_4CA5C9052A24E336 + randomfloat( _id_2B8F70C634712F60 ) );
        mg42 stopfiring();
        wait( _id_3F0FA03E0F609BBF + randomfloat( _id_E7C2ECA166FF3355 ) );
    }
}

_spawner_mg42_think()
{
    if ( !isdefined( self.flagged_for_use ) )
        self.flagged_for_use = 0;

    if ( !isdefined( self.targetname ) )
        return;

    node = getnode( self.targetname, "target" );

    if ( !isdefined( node ) )
        return;

    if ( !isdefined( node.script_mg42 ) )
        return;

    if ( !isdefined( node.mg42_enabled ) )
        node.mg42_enabled = 1;

    self.script_mg42 = node.script_mg42;
    _id_BD28412336460CA7 = 1;

    for (;;)
    {
        if ( _id_BD28412336460CA7 )
        {
            _id_BD28412336460CA7 = 0;

            if ( isdefined( node.targetname ) || self.flagged_for_use )
                self waittill( "get new user" );
        }

        if ( !node.mg42_enabled )
        {
            node waittill( "enable mg42" );
            node.mg42_enabled = 1;
        }

        _id_6342A5CD84590602 = [];
        ai = getaiarray();

        for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < ai.size; _id_AC0E594AC96AA3A8++ )
        {
            _id_80BF6212193E8983 = 1;

            if ( isdefined( ai[_id_AC0E594AC96AA3A8].script_mg42 ) && ai[_id_AC0E594AC96AA3A8].script_mg42 == self.script_mg42 )
                _id_80BF6212193E8983 = 0;

            if ( isdefined( ai[_id_AC0E594AC96AA3A8].used_an_mg42 ) )
                _id_80BF6212193E8983 = 1;

            if ( _id_80BF6212193E8983 )
                _id_6342A5CD84590602[_id_6342A5CD84590602.size] = ai[_id_AC0E594AC96AA3A8];
        }

        if ( _id_6342A5CD84590602.size )
            ai = scripts\engine\sp\utility::get_closest_ai_exclude( node.origin, undefined, _id_6342A5CD84590602 );
        else
            ai = scripts\engine\sp\utility::get_closest_ai( node.origin, undefined );

        _id_6342A5CD84590602 = undefined;

        if ( isdefined( ai ) )
        {
            ai notify( "stop_going_to_node" );
            ai thread scripts\sp\spawner::go_to_node( node );
            ai waittill( "death" );
            continue;
        }

        self waittill( "get new user" );
    }
}

mg42_think()
{
    if ( !isdefined( self.ai_mode ) )
        self.ai_mode = "manual_ai";

    node = getnode( self.target, "targetname" );

    if ( !isdefined( node ) )
        return;

    mg42 = getent( node.target, "targetname" );
    mg42.org = node.origin;

    if ( isdefined( mg42.target ) )
    {
        if ( !isdefined( level.mg42_trigger ) || !isdefined( level.mg42_trigger[mg42.target] ) )
        {
            level.mg42_trigger[mg42.target] = 0;
            getent( mg42.target, "targetname" ) thread mg42_trigger();
        }

        trigger = 1;
    }
    else
        trigger = 0;

    for (;;)
    {
        if ( self.count == 0 )
            return;

        _id_A7F2A05A01110BFB = undefined;

        while ( !isdefined( _id_A7F2A05A01110BFB ) )
        {
            _id_A7F2A05A01110BFB = scripts\engine\sp\utility::spawn_ai();
            wait 1;
        }

        _id_A7F2A05A01110BFB thread mg42_gunner_think( mg42, trigger, self.ai_mode );
        _id_A7F2A05A01110BFB thread mg42_firing( mg42 );
        _id_A7F2A05A01110BFB waittill( "death" );

        if ( isdefined( self.script_delay ) )
        {
            wait( self.script_delay );
            continue;
        }

        if ( isdefined( self.script_delay_min ) && isdefined( self.script_delay_max ) )
        {
            wait( self.script_delay_min + randomfloat( self.script_delay_max - self.script_delay_min ) );
            continue;
        }

        wait 1;
    }
}

kill_objects( owner, msg, _id_1FE57B1640868A8E, _id_1FE57A164086885B )
{
    owner waittill( msg );

    if ( isdefined( _id_1FE57B1640868A8E ) )
        _id_1FE57B1640868A8E delete();

    if ( isdefined( _id_1FE57A164086885B ) )
        _id_1FE57A164086885B delete();
}

mg42_gunner_think( mg42, trigger, ai_mode )
{
    self endon( "death" );

    if ( ai_mode == "manual_ai" )
    {
        for (;;)
        {
            thread mg42_gunner_manual_think( mg42, trigger );
            self waittill( "auto_ai" );
            move_use_turret( mg42, "auto_ai" );
            self waittill( "manual_ai" );
        }
    }
    else
    {
        for (;;)
        {
            move_use_turret( mg42, "auto_ai", level.player );
            self waittill( "manual_ai" );
            thread mg42_gunner_manual_think( mg42, trigger );
            self waittill( "auto_ai" );
        }
    }
}

player_safe()
{
    if ( !isdefined( level.player_covertrigger ) )
        return 0;

    if ( level.player getstance() == "prone" )
        return 1;

    if ( level.player_covertype == "cow" && level.player getstance() == "crouch" )
        return 1;

    return 0;
}

stance_num()
{
    if ( level.player getstance() == "prone" )
        return ( 0, 0, 5 );
    else if ( level.player getstance() == "crouch" )
        return ( 0, 0, 25 );

    return ( 0, 0, 50 );
}

mg42_gunner_manual_think( mg42, trigger )
{
    self endon( "death" );
    self endon( "auto_ai" );
    self.pacifist = 1;
    self setgoalpos( mg42.org );
    self.goalradius = level.magic_distance;
    self waittill( "goal" );

    if ( trigger )
    {
        if ( !level.mg42_trigger[mg42.target] )
            level waittill( mg42.target );
    }

    self.pacifist = 0;
    mg42 setmode( "auto_ai" );
    mg42 cleartargetentity();
    _id_68474726DFC6DD04 = spawn( "script_origin", ( 0, 0, 0 ) );
    _id_8570EBCE668A8F48 = spawn( "script_model", ( 0, 0, 0 ) );
    _id_8570EBCE668A8F48.scale = 3;

    if ( getdvar( "dvar_5788A4B3D780018C" ) != "off" )
        _id_8570EBCE668A8F48 setmodel( "temp" );

    _id_8570EBCE668A8F48 thread temp_think( mg42, _id_68474726DFC6DD04 );
    level thread kill_objects( self, "death", _id_68474726DFC6DD04, _id_8570EBCE668A8F48 );
    level thread kill_objects( self, "auto_ai", _id_68474726DFC6DD04, _id_8570EBCE668A8F48 );
    mg42.player_target = 0;
    _id_77DD3AF9C9B623C4 = 0;
    targets = getentarray( "mg42_target", "targetname" );

    if ( targets.size > 0 )
    {
        _id_83C9FEE40517457F = 1;
        _id_F30507DD5DCFEEBF = targets[randomint( targets.size )].origin;
        thread shoot_mg42_script_targets( targets );
        move_use_turret( mg42 );
        self.target_entity = _id_68474726DFC6DD04;
        mg42 setmode( "manual_ai" );
        mg42 settargetentity( _id_68474726DFC6DD04 );
        mg42 notify( "startfiring" );
        _id_636C8575D7A7768B = 15;
        wait_time = 0.08;
        _id_D3E80203D73E375C = 0.05;
        _id_68474726DFC6DD04.origin = targets[randomint( targets.size )].origin;
        _id_923214DF11FA9D56 = 0;

        while ( !isdefined( level.player_covertrigger ) )
        {
            _id_F30507DD5DCFEEBF = _id_68474726DFC6DD04.origin;

            if ( distance( _id_F30507DD5DCFEEBF, targets[self.gun_targ].origin ) > _id_636C8575D7A7768B )
            {
                _id_CA11C82F49BE4626 = vectornormalize( targets[self.gun_targ].origin - _id_F30507DD5DCFEEBF );
                _id_CA11C82F49BE4626 = _id_CA11C82F49BE4626 * _id_636C8575D7A7768B;
                _id_F30507DD5DCFEEBF = _id_F30507DD5DCFEEBF + _id_CA11C82F49BE4626;
            }
            else
                self notify( "next_target" );

            _id_68474726DFC6DD04.origin = _id_F30507DD5DCFEEBF;
            wait 0.1;
        }

        for (;;)
        {
            for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < 1; _id_AC0E594AC96AA3A8 = _id_AC0E594AC96AA3A8 + _id_D3E80203D73E375C )
            {
                _id_68474726DFC6DD04.origin = _id_F30507DD5DCFEEBF * ( 1.0 - _id_AC0E594AC96AA3A8 ) + ( level.player getorigin() + stance_num() ) * _id_AC0E594AC96AA3A8;

                if ( player_safe() )
                    _id_AC0E594AC96AA3A8 = 2;

                wait( wait_time );
            }

            _id_A80087C51092ADCB = level.player getorigin();

            while ( !player_safe() )
            {
                _id_68474726DFC6DD04.origin = level.player getorigin();
                _id_97DE56918657CE55 = _id_68474726DFC6DD04.origin - _id_A80087C51092ADCB;
                _id_68474726DFC6DD04.origin = _id_68474726DFC6DD04.origin + _id_97DE56918657CE55 + stance_num();
                _id_A80087C51092ADCB = level.player getorigin();
                wait 0.1;
            }

            if ( player_safe() )
            {
                _id_923214DF11FA9D56 = gettime() + 1500 + randomfloat( 4000 );

                while ( player_safe() && isdefined( level.player_covertrigger.target ) && gettime() < _id_923214DF11FA9D56 )
                {
                    target = getentarray( level.player_covertrigger.target, "targetname" );
                    target = target[randomint( target.size )];
                    _id_68474726DFC6DD04.origin = target.origin + ( randomfloat( 30 ) - 15, randomfloat( 30 ) - 15, randomfloat( 40 ) - 60 );
                    wait 0.1;
                }
            }

            self notify( "next_target" );

            while ( player_safe() )
            {
                _id_F30507DD5DCFEEBF = _id_68474726DFC6DD04.origin;

                if ( distance( _id_F30507DD5DCFEEBF, targets[self.gun_targ].origin ) > _id_636C8575D7A7768B )
                {
                    _id_CA11C82F49BE4626 = vectornormalize( targets[self.gun_targ].origin - _id_F30507DD5DCFEEBF );
                    _id_CA11C82F49BE4626 = _id_CA11C82F49BE4626 * _id_636C8575D7A7768B;
                    _id_F30507DD5DCFEEBF = _id_F30507DD5DCFEEBF + _id_CA11C82F49BE4626;
                }
                else
                    self notify( "next_target" );

                _id_68474726DFC6DD04.origin = _id_F30507DD5DCFEEBF;
                wait 0.1;
            }
        }
    }
    else
    {
        for (;;)
        {
            move_use_turret( mg42 );

            while ( !isdefined( level.player_covertrigger ) )
            {
                if ( !mg42.player_target )
                {
                    mg42 settargetentity( level.player );
                    mg42.player_target = 1;
                    _id_8570EBCE668A8F48.targent = level.player;
                }

                wait 0.2;
            }

            mg42 setmode( "manual_ai" );
            move_use_turret( mg42 );
            mg42 notify( "startfiring" );
            _id_923214DF11FA9D56 = gettime() + 1500 + randomfloat( 4000 );

            while ( _id_923214DF11FA9D56 > gettime() )
            {
                if ( isdefined( level.player_covertrigger ) )
                {
                    target = getentarray( level.player_covertrigger.target, "targetname" );
                    target = target[randomint( target.size )];
                    _id_68474726DFC6DD04.origin = target.origin + ( randomfloat( 30 ) - 15, randomfloat( 30 ) - 15, randomfloat( 40 ) - 60 );
                    mg42 settargetentity( _id_68474726DFC6DD04 );
                    _id_8570EBCE668A8F48.targent = _id_68474726DFC6DD04;
                    wait( randomfloat( 1 ) );
                    continue;
                }

                break;
            }

            mg42 notify( "stopfiring" );
            move_use_turret( mg42 );

            if ( mg42.player_target )
            {
                mg42 setmode( "auto_ai" );
                mg42 cleartargetentity();
                mg42.player_target = 0;
                _id_8570EBCE668A8F48.targent = _id_8570EBCE668A8F48;
                _id_8570EBCE668A8F48.origin = ( 0, 0, 0 );
            }

            while ( isdefined( level.player_covertrigger ) )
                wait 0.2;

            wait( 0.75 + randomfloat( 0.2 ) );
        }
    }
}

shoot_mg42_script_targets( targets )
{
    self endon( "death" );

    for (;;)
    {
        _id_42F4822B2156CE1A = [];

        for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < targets.size; _id_AC0E594AC96AA3A8++ )
            _id_42F4822B2156CE1A[_id_AC0E594AC96AA3A8] = 0;

        for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < targets.size; _id_AC0E594AC96AA3A8++ )
        {
            self.gun_targ = randomint( targets.size );
            self waittill( "next_target" );

            while ( _id_42F4822B2156CE1A[self.gun_targ] )
            {
                self.gun_targ++;

                if ( self.gun_targ >= targets.size )
                    self.gun_targ = 0;
            }

            _id_42F4822B2156CE1A[self.gun_targ] = 1;
        }
    }
}

move_use_turret( mg42, aitype, target )
{
    self setgoalpos( mg42.org );
    self.goalradius = level.magic_distance;
    self waittill( "goal" );

    if ( isdefined( aitype ) && aitype == "auto_ai" )
    {
        mg42 setmode( "auto_ai" );

        if ( isdefined( target ) )
            mg42 settargetentity( target );
        else
            mg42 cleartargetentity();
    }

    self useturret( mg42 );
}

temp_think( mg42, _id_B8E70FF71A02E32D )
{
    if ( getdvar( "dvar_5788A4B3D780018C" ) == "off" )
        return;

    self.targent = self;

    for (;;)
    {
        self.origin = _id_B8E70FF71A02E32D.origin;
        wait 0.1;
    }
}

turret_think( node )
{
    turret = getent( node.auto_mg42_target, "targetname" );
    mintime = 0.5;

    if ( isdefined( turret.script_turret_reuse_min ) )
        mintime = turret.script_turret_reuse_min;

    maxtime = 2;

    if ( isdefined( turret.script_turret_reuse_max ) )
        mintime = turret.script_turret_reuse_max;

    for (;;)
    {
        turret waittill( "turret_deactivate" );
        wait( mintime + randomfloat( maxtime - mintime ) );

        while ( !_func_1C075E7654635DDD( turret ) )
        {
            turret_find_user( node, turret );
            wait 1.0;
        }
    }
}

turret_find_user( node, turret )
{
    ai = getaiarray();

    for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < ai.size; _id_AC0E594AC96AA3A8++ )
    {
        if ( ai[_id_AC0E594AC96AA3A8] _meth_9D6AB3620932D51D( node.origin ) && ai[_id_AC0E594AC96AA3A8] _meth_D0C445996C69FCC2( turret ) )
        {
            _id_9A0D6E3A66997C0E = ai[_id_AC0E594AC96AA3A8].keepclaimednodeifvalid;
            ai[_id_AC0E594AC96AA3A8].keepclaimednodeifvalid = 0;

            if ( !ai[_id_AC0E594AC96AA3A8] usecovernode( node ) )
                ai[_id_AC0E594AC96AA3A8].keepclaimednodeifvalid = _id_9A0D6E3A66997C0E;
        }
    }
}

setdifficulty()
{
    init_mgturretsettings();
    _id_05F0FED4C8A1C014 = getentarray( "misc_turret", "code_classname" );
    difficulty = scripts\common\utility::getdifficulty();

    for ( index = 0; index < _id_05F0FED4C8A1C014.size; index++ )
    {
        if ( isdefined( _id_05F0FED4C8A1C014[index].script_skilloverride ) )
        {
            switch ( _id_05F0FED4C8A1C014[index].script_skilloverride )
            {
                case "easy":
                    difficulty = "easy";
                    break;
                case "medium":
                    difficulty = "medium";
                    break;
                case "hard":
                    difficulty = "hard";
                    break;
                case "fu":
                    difficulty = "fu";
                    break;
                default:
                    continue;
            }
        }

        mg42_setdifficulty( _id_05F0FED4C8A1C014[index], difficulty );
    }
}

mg42_setdifficulty( mg42, difficulty )
{
    mg42.convergencetime = level.mgturretsettings[difficulty]["convergenceTime"];
    mg42.suppressionTime = level.mgturretsettings[difficulty]["suppressionTime"];
    mg42.accuracy = level.mgturretsettings[difficulty]["accuracy"];
    mg42.aiSpread = level.mgturretsettings[difficulty]["aiSpread"];
    mg42.playerSpread = level.mgturretsettings[difficulty]["playerSpread"];
}

mg42_target_drones( _id_B7F546CDC5A1D4D6, team, _id_2FF221C77F3BA801 )
{
    if ( !isdefined( _id_2FF221C77F3BA801 ) )
        _id_2FF221C77F3BA801 = 0.88;

    self endon( "death" );
    self notify( "stop_mg42_target_drones" );
    self endon( "stop_mg42_target_drones" );
    self.dronefailed = 0;

    if ( !isdefined( self.script_fireondrones ) )
        self.script_fireondrones = 0;

    if ( !isdefined( _id_B7F546CDC5A1D4D6 ) )
        _id_B7F546CDC5A1D4D6 = 0;

    self setmode( "manual_ai" );
    difficulty = scripts\common\utility::getdifficulty();

    if ( !isdefined( level.drones ) )
        _id_C54DF9606ECBE73F = 1;
    else
        _id_C54DF9606ECBE73F = 0;

    for (;;)
    {
        if ( _id_C54DF9606ECBE73F )
        {
            if ( isdefined( self.drones_targets_sets_to_default ) )
                self setmode( self.defaultonmode );
            else if ( _id_B7F546CDC5A1D4D6 )
                self setmode( "auto_nonai" );
            else
                self setmode( "auto_ai" );

            level waittill( "new_drone" );
        }

        if ( !isdefined( self.oldconvergencetime ) )
            self.oldconvergencetime = self.convergencetime;

        self.convergencetime = 2;

        if ( !_id_B7F546CDC5A1D4D6 )
        {
            _id_C424C88C44314576 = self getturretowner();

            if ( !isalive( _id_C424C88C44314576 ) || isplayer( _id_C424C88C44314576 ) )
            {
                wait 0.05;
                continue;
            }
            else
                team = _id_C424C88C44314576.team;
        }
        else
            _id_C424C88C44314576 = undefined;

        if ( team == "allies" )
            targetteam = "axis";
        else
            targetteam = "allies";

        while ( level.drones[targetteam].lastindex )
        {
            scripts\engine\utility::lock( "mg42_drones" );

            if ( !level.drones[targetteam].lastindex )
            {
                scripts\engine\utility::unlock( "mg42_drones" );
                break;
            }

            target = get_bestdrone( targetteam, _id_2FF221C77F3BA801 );
            scripts\engine\utility::unlock( "mg42_drones" );

            if ( !isdefined( self.script_fireondrones ) || !self.script_fireondrones )
            {
                wait 0.05;
                break;
            }

            if ( !isdefined( target ) )
            {
                wait 0.05;
                break;
            }

            if ( isdefined( self.anim_wait_func ) )
                [[ self.anim_wait_func ]]();

            if ( _id_B7F546CDC5A1D4D6 )
                self setmode( "manual" );
            else
                self setmode( "manual_ai" );

            self settargetentity( target, ( 0, 0, 32 ) );
            drone_target( target, 1, _id_2FF221C77F3BA801 );
            self cleartargetentity();
            self stopfiring();

            if ( !_id_B7F546CDC5A1D4D6 && !( isdefined( self getturretowner() ) && self getturretowner() == _id_C424C88C44314576 ) )
                break;
        }

        self.convergencetime = self.oldconvergencetime;
        self.oldconvergencetime = undefined;
        self cleartargetentity();
        self stopfiring();

        if ( level.drones[targetteam].lastindex )
        {
            _id_C54DF9606ECBE73F = 0;
            continue;
        }

        _id_C54DF9606ECBE73F = 1;
    }
}

drone_target( drone, time, _id_2FF221C77F3BA801 )
{
    self endon( "death" );
    drone endon( "death" );
    timer = gettime() + time * 1000;
    _id_3F53C2D5D19E37C1 = 0;

    while ( timer > gettime() || _id_3F53C2D5D19E37C1 )
    {
        scripts\engine\utility::lock( "mg42_drones_target_trace" );
        turrettarget = self getturrettarget( 1 );

        if ( !scripts\engine\trace::_bullet_trace_passed( self gettagorigin( "tag_flash" ), drone.origin + ( 0, 0, 40 ), 0, drone ) )
        {
            scripts\engine\utility::unlock( "mg42_drones_target_trace" );
            break;
        }
        else if ( isdefined( turrettarget ) && distance( turrettarget.origin, self.origin ) < distance( self.origin, drone.origin ) )
        {
            scripts\engine\utility::unlock( "mg42_drones_target_trace" );
            break;
        }

        if ( !_id_3F53C2D5D19E37C1 )
        {
            self startfiring();
            _id_3F53C2D5D19E37C1 = 1;
        }

        scripts\engine\utility::unlock_wait( "mg42_drones_target_trace" );
    }

    self stopfiring();
    scripts\engine\sp\utility::structarray_shuffle( level.drones[drone.team], 1 );
}

get_bestdrone( team, _id_2FF221C77F3BA801 )
{
    if ( level.drones[team].lastindex < 1 )
        return;

    ent = undefined;
    _id_172D42D175E16C61 = anglestoforward( self.angles );

    for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < level.drones[team].lastindex; _id_AC0E594AC96AA3A8++ )
    {
        if ( !isdefined( level.drones[team].array[_id_AC0E594AC96AA3A8] ) )
            continue;

        angles = vectortoangles( level.drones[team].array[_id_AC0E594AC96AA3A8].origin - self.origin );
        forward = anglestoforward( angles );

        if ( vectordot( _id_172D42D175E16C61, forward ) < _id_2FF221C77F3BA801 )
            continue;

        ent = level.drones[team].array[_id_AC0E594AC96AA3A8];

        if ( !scripts\engine\trace::_bullet_trace_passed( self gettagorigin( "tag_flash" ), ent _meth_DC69BCA30D639423(), 0, ent ) )
        {
            ent = undefined;
            continue;
        }

        break;
    }

    _id_67E561B83F47FD3E = self getturrettarget( 1 );

    if ( !isdefined( self.prefers_drones ) )
    {
        if ( isdefined( ent ) && isdefined( _id_67E561B83F47FD3E ) && distancesquared( self.origin, _id_67E561B83F47FD3E.origin ) < distancesquared( self.origin, ent.origin ) )
            ent = undefined;
    }

    return ent;
}

saw_mgturretlink()
{
    _id_9DFB2D4326B2CB1A = getentarray( "misc_turret", "code_classname" );
    turrets = [];

    foreach ( _id_9869BC1AF26D720D in _id_9DFB2D4326B2CB1A )
    {
        if ( isdefined( _id_9869BC1AF26D720D.targetname ) )
            continue;

        if ( isdefined( _id_9869BC1AF26D720D.script_turret_autonomous ) && _id_9869BC1AF26D720D.script_turret_autonomous )
            continue;

        if ( isdefined( _id_9869BC1AF26D720D.isvehicleattached ) )
            continue;

        turrets[turrets.size] = _id_9869BC1AF26D720D;
    }

    if ( !turrets.size )
        return;

    _id_AC3FBB4A8E4C719B = turrets;

    foreach ( turret in turrets )
    {
        foreach ( node in getnodesinradius( turret.origin, 50, 0 ) )
        {
            if ( node.type == "Path" )
                continue;

            if ( node.type == "Begin" )
                continue;

            if ( node.type == "End" )
                continue;

            _id_E9CEC583070AF166 = anglestoforward( ( 0, node.angles[1], 0 ) );
            _id_929AD65D451FFC68 = anglestoforward( ( 0, turret.angles[1], 0 ) );
            dot = vectordot( _id_E9CEC583070AF166, _id_929AD65D451FFC68 );

            if ( dot < 0.9 )
                continue;

            _id_AC3FBB4A8E4C719B = scripts\engine\utility::array_remove( _id_AC3FBB4A8E4C719B, turret );
            node.turretinfo = spawn( "script_origin", turret.origin );
            node.turretinfo.angles = turret.angles;
            node.turretinfo.node = node;
            node.turretinfo.leftarc = 45;
            node.turretinfo.rightarc = 45;
            node.turretinfo.toparc = 15;
            node.turretinfo.bottomarc = 15;

            if ( isdefined( turret.leftarc ) )
                node.turretinfo.leftarc = min( turret.leftarc, 45 );

            if ( isdefined( turret.rightarc ) )
                node.turretinfo.rightarc = min( turret.rightarc, 45 );

            if ( isdefined( turret.toparc ) )
                node.turretinfo.toparc = min( turret.toparc, 15 );

            if ( isdefined( turret.bottomarc ) )
                node.turretinfo.bottomarc = min( turret.bottomarc, 15 );

            turret delete();
        }
    }
}

auto_mgturretlink()
{
    _id_9DFB2D4326B2CB1A = getentarray( "misc_turret", "code_classname" );
    turrets = [];

    foreach ( _id_9869BC1AF26D720D in _id_9DFB2D4326B2CB1A )
    {
        if ( !isdefined( _id_9869BC1AF26D720D.targetname ) || tolower( _id_9869BC1AF26D720D.targetname ) != "auto_mgturret" )
            continue;

        if ( !isdefined( _id_9869BC1AF26D720D.export ) )
            continue;

        if ( !isdefined( _id_9869BC1AF26D720D.script_dont_link_turret ) )
            turrets[turrets.size] = _id_9869BC1AF26D720D;
    }

    if ( !turrets.size )
        return;

    _id_AC3FBB4A8E4C719B = turrets;

    foreach ( turret in turrets )
    {
        foreach ( node in getnodesinradius( turret.origin, 70 ) )
        {
            if ( node.type == "Path" )
                continue;

            if ( node.type == "Begin" )
                continue;

            if ( node.type == "End" )
                continue;

            _id_E9CEC583070AF166 = anglestoforward( ( 0, node.angles[1], 0 ) );
            _id_929AD65D451FFC68 = anglestoforward( ( 0, turret.angles[1], 0 ) );
            dot = vectordot( _id_E9CEC583070AF166, _id_929AD65D451FFC68 );

            if ( dot < 0.9 )
                continue;

            _id_AC3FBB4A8E4C719B = scripts\engine\utility::array_remove( _id_AC3FBB4A8E4C719B, turret );
            node.turret = turret;
            turret.node = node;
            turret.issetup = 1;
        }
    }
}

save_turret_sharing_info()
{
    self.shared_turrets = [];
    self.shared_turrets["connected"] = [];
    self.shared_turrets["ambush"] = [];

    if ( !isdefined( self.export ) )
        return;

    if ( !isdefined( level.shared_portable_turrets ) )
        level.shared_portable_turrets = [];

    level.shared_portable_turrets[self.export] = self;

    if ( isdefined( self.script_turret_share ) )
    {
        strings = strtok( self.script_turret_share, " " );

        for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < strings.size; _id_AC0E594AC96AA3A8++ )
            self.shared_turrets["connected"][strings[_id_AC0E594AC96AA3A8]] = 1;
    }

    if ( isdefined( self.script_turret_ambush ) )
    {
        strings = strtok( self.script_turret_ambush, " " );

        for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < strings.size; _id_AC0E594AC96AA3A8++ )
            self.shared_turrets["ambush"][strings[_id_AC0E594AC96AA3A8]] = 1;
    }
}

restoredefaultpitch()
{
    self notify( "gun_placed_again" );
    self endon( "gun_placed_again" );
    self waittill( "restore_default_drop_pitch" );
    wait 1;
    self restoredefaultdroppitch();
}

dropturret()
{
    thread dropturretproc();
}

dropturretproc()
{
    turret = spawn( "script_model", ( 0, 0, 0 ) );
    turret.origin = self gettagorigin( level.portable_mg_gun_tag );
    turret.angles = self gettagangles( level.portable_mg_gun_tag );
    turret setmodel( self.turretmodel );
    forward = anglestoforward( self.angles );
    forward = forward * 100;
    turret movegravity( forward, 0.5 );
    self detach( self.turretmodel, level.portable_mg_gun_tag );
    self.turretmodel = undefined;
    wait 0.7;
    turret delete();
}

turretdeathdetacher()
{
    self endon( "kill_turret_detach_thread" );
    self endon( "dropped_gun" );
    self waittill( "death" );

    if ( !isdefined( self ) )
        return;

    dropturret();
}

turretdetacher()
{
    self endon( "death" );
    self endon( "kill_turret_detach_thread" );
    self waittill( "dropped_gun" );
    self detach( self.turretmodel, level.portable_mg_gun_tag );
}

restoredefaults()
{
    self.run_overrideanim = undefined;
}

restorepitch()
{
    self waittill( "turret_deactivate" );
    self restoredefaultdroppitch();
}

update_enemy_target_pos_while_running( ent )
{
    self endon( "death" );
    self endon( "end_mg_behavior" );
    self endon( "stop_updating_enemy_target_pos" );

    for (;;)
    {
        self waittill( "saw_enemy" );
        ent.origin = self.last_enemy_sighting_position;
    }
}

move_target_pos_to_new_turrets_visibility( ent, _id_708A7A37920A2C36 )
{
    self endon( "death" );
    self endon( "end_mg_behavior" );
    self endon( "stop_updating_enemy_target_pos" );
    _id_0AAC5742AF70FC90 = self.turret.origin + ( 0, 0, 16 );
    _id_F39A2FE3E0A3BAE8 = _id_708A7A37920A2C36.origin + ( 0, 0, 16 );

    for (;;)
    {
        wait 0.05;

        if ( sighttracepassed( ent.origin, _id_F39A2FE3E0A3BAE8, 0, undefined ) )
            continue;

        angles = vectortoangles( _id_0AAC5742AF70FC90 - ent.origin );
        forward = anglestoforward( angles );
        forward = forward * 8;
        ent.origin = ent.origin + forward;
    }
}

record_bread_crumbs_for_ambush( ent )
{
    self endon( "death" );
    self endon( "end_mg_behavior" );
    self endon( "stop_updating_enemy_target_pos" );
    ent.bread_crumbs = [];

    for (;;)
    {
        ent.bread_crumbs[ent.bread_crumbs.size] = self.origin + ( 0, 0, 50 );
        wait 0.35;
    }
}

aim_turret_at_ambush_point_or_visible_enemy( turret, ent )
{
    if ( !isalive( self.current_enemy ) && self cansee( self.current_enemy ) )
    {
        ent.origin = self.last_enemy_sighting_position;
        return;
    }

    forward = anglestoforward( turret.angles );

    for ( _id_AC0E594AC96AA3A8 = ent.bread_crumbs.size - 3; _id_AC0E594AC96AA3A8 >= 0; _id_AC0E594AC96AA3A8-- )
    {
        _id_B7CFBED145E14A60 = ent.bread_crumbs[_id_AC0E594AC96AA3A8];
        normal = vectornormalize( _id_B7CFBED145E14A60 - turret.origin );
        dot = vectordot( forward, normal );

        if ( dot < 0.75 )
            continue;

        ent.origin = _id_B7CFBED145E14A60;

        if ( sighttracepassed( turret.origin, _id_B7CFBED145E14A60, 0, undefined ) )
            continue;

        break;
    }
}

find_a_new_turret_spot( ent )
{
    array = get_portable_mg_spot( ent );
    _id_708A7A37920A2C36 = array["spot"];
    _id_AE413E3D7D38E5C6 = array["type"];

    if ( !isdefined( _id_708A7A37920A2C36 ) )
        return;

    reserve_turret( _id_708A7A37920A2C36 );
    thread update_enemy_target_pos_while_running( ent );
    thread move_target_pos_to_new_turrets_visibility( ent, _id_708A7A37920A2C36 );

    if ( _id_AE413E3D7D38E5C6 == "ambush" )
        thread record_bread_crumbs_for_ambush( ent );

    if ( _id_708A7A37920A2C36.issetup )
        leave_gun_and_run_to_new_spot( _id_708A7A37920A2C36 );
    else
    {
        pickup_gun( _id_708A7A37920A2C36 );
        run_to_new_spot_and_setup_gun( _id_708A7A37920A2C36 );
    }

    self notify( "stop_updating_enemy_target_pos" );

    if ( _id_AE413E3D7D38E5C6 == "ambush" )
        aim_turret_at_ambush_point_or_visible_enemy( _id_708A7A37920A2C36, ent );

    _id_708A7A37920A2C36 settargetentity( ent );
}

snap_lock_turret_onto_target( turret )
{
    turret setmode( "manual" );
    wait 0.5;
    turret setmode( "manual_ai" );
}

leave_gun_and_run_to_new_spot( _id_0C3EA9B1A20FF199 )
{
    self stopuseturret();
    _id_3433EE6B63C7E243::placeweaponon( self.primaryweapon, "none" );
    _id_D6FFD4AA576F23DE = get_turret_setup_anim( _id_0C3EA9B1A20FF199 );
    org = getstartorigin( _id_0C3EA9B1A20FF199.origin, _id_0C3EA9B1A20FF199.angles, _id_D6FFD4AA576F23DE );
    self waittill( "runto_arrived" );
    use_the_turret( _id_0C3EA9B1A20FF199 );
}

pickup_gun( _id_0C3EA9B1A20FF199 )
{
    self stopuseturret();
    self.turret hide_turret();
}

get_turret_setup_anim( turret )
{
    _id_8A45ECC4EF510BA3 = [];
    _id_8A45ECC4EF510BA3["saw_bipod_stand"] = level.mg_animmg["bipod_stand_setup"];
    _id_8A45ECC4EF510BA3["saw_bipod_crouch"] = level.mg_animmg["bipod_crouch_setup"];
    _id_8A45ECC4EF510BA3["saw_bipod_prone"] = level.mg_animmg["bipod_prone_setup"];
    return _id_8A45ECC4EF510BA3[turret.weaponinfo];
}

run_to_new_spot_and_setup_gun( _id_0C3EA9B1A20FF199 )
{
    _id_6DA37E0E07826838 = self.health;
    _id_0C3EA9B1A20FF199 endon( "turret_deactivate" );
    self.mg42 = _id_0C3EA9B1A20FF199;
    self endon( "death" );
    self endon( "dropped_gun" );
    _id_D6FFD4AA576F23DE = get_turret_setup_anim( _id_0C3EA9B1A20FF199 );
    self.turretmodel = "weapon_mg42_carry";
    self notify( "kill_get_gun_back_on_killanimscript_thread" );
    _id_3433EE6B63C7E243::placeweaponon( self.weapon, "none" );

    if ( self isbadguy() )
        self.health = 1;

    self attach( self.turretmodel, level.portable_mg_gun_tag );
    thread turretdeathdetacher();
    org = getstartorigin( _id_0C3EA9B1A20FF199.origin, _id_0C3EA9B1A20FF199.angles, _id_D6FFD4AA576F23DE );
    wait 0.05;
    scripts\engine\utility::clear_exception( "move" );
    scripts\engine\sp\utility::set_exception( "cover_crouch", ::hold_indefintely );

    while ( distance( self.origin, org ) > 16 )
        wait 0.05;

    self notify( "kill_turret_detach_thread" );

    if ( self isbadguy() )
        self.health = _id_6DA37E0E07826838;

    if ( soundexists( "weapon_setup" ) )
        playworldsound( "weapon_setup", self.origin );

    self animscripted( "setup_done", _id_0C3EA9B1A20FF199.origin, _id_0C3EA9B1A20FF199.angles, _id_D6FFD4AA576F23DE );
    restoredefaults();
    self waittillmatch( "setup_done", "end" );
    _id_0C3EA9B1A20FF199 notify( "restore_default_drop_pitch" );
    _id_0C3EA9B1A20FF199 show_turret();
    _id_3433EE6B63C7E243::placeweaponon( self.primaryweapon, "right" );
    use_the_turret( _id_0C3EA9B1A20FF199 );
    self detach( self.turretmodel, level.portable_mg_gun_tag );
    self notify( "bcs_portable_turret_setup" );
}

hold_indefintely()
{
    self endon( "killanimscript" );
    self waittill( "death" );
}

using_a_turret()
{
    if ( !isdefined( self.turret ) )
        return 0;

    return self.turret.owner == self;
}

turret_user_moves()
{
    if ( !using_a_turret() )
    {
        scripts\engine\utility::clear_exception( "move" );
        return;
    }

    array = find_connected_turrets( "connected" );
    _id_8AB70D362C5F5BBF = array["spots"];

    if ( !_id_8AB70D362C5F5BBF.size )
    {
        scripts\engine\utility::clear_exception( "move" );
        return;
    }

    _id_643B764A9F01A3F0 = self.node;

    if ( !isdefined( _id_643B764A9F01A3F0 ) || !scripts\engine\utility::array_contains( _id_8AB70D362C5F5BBF, _id_643B764A9F01A3F0 ) )
    {
        _id_B64A2C06FA3074BE = gettakennodes();

        for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < _id_8AB70D362C5F5BBF.size; _id_AC0E594AC96AA3A8++ )
        {
            _id_643B764A9F01A3F0 = scripts\engine\utility::random( _id_8AB70D362C5F5BBF );

            if ( isdefined( _id_B64A2C06FA3074BE[_id_643B764A9F01A3F0.origin + ""] ) )
                return;
        }
    }

    turret = _id_643B764A9F01A3F0.turret;

    if ( isdefined( turret.reserved ) )
        return;

    reserve_turret( turret );

    if ( turret.issetup )
        leave_gun_and_run_to_new_spot( turret );
    else
        run_to_new_spot_and_setup_gun( turret );

    scripts\sp\mg_penetration::gunner_think( _id_643B764A9F01A3F0.turret );
}

use_the_turret( _id_0C3EA9B1A20FF199 )
{
    _id_B0FCC63733F0C969 = self useturret( _id_0C3EA9B1A20FF199 );

    if ( _id_B0FCC63733F0C969 )
    {
        scripts\engine\sp\utility::set_exception( "move", ::turret_user_moves );
        self.turret = _id_0C3EA9B1A20FF199;
        thread mg42_firing( _id_0C3EA9B1A20FF199 );
        _id_0C3EA9B1A20FF199 setmode( "manual_ai" );
        _id_0C3EA9B1A20FF199 thread restorepitch();
        self.turret = _id_0C3EA9B1A20FF199;
        _id_0C3EA9B1A20FF199.owner = self;
        return 1;
    }
    else
    {
        _id_0C3EA9B1A20FF199 restoredefaultdroppitch();
        return 0;
    }
}

get_portable_mg_spot( ent )
{
    _id_7E9CCE41BA25C33B = [];
    _id_7E9CCE41BA25C33B[_id_7E9CCE41BA25C33B.size] = ::find_different_way_to_attack_last_seen_position;
    _id_7E9CCE41BA25C33B[_id_7E9CCE41BA25C33B.size] = ::find_good_ambush_spot;
    _id_7E9CCE41BA25C33B = scripts\engine\utility::array_randomize( _id_7E9CCE41BA25C33B );

    for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < _id_7E9CCE41BA25C33B.size; _id_AC0E594AC96AA3A8++ )
    {
        array = [[ _id_7E9CCE41BA25C33B[_id_AC0E594AC96AA3A8] ]]( ent );

        if ( !isdefined( array["spots"] ) )
            continue;

        array["spot"] = scripts\engine\utility::random( array["spots"] );
        return array;
    }
}

gettakennodes()
{
    array = [];
    ai = getaiarray();

    for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < ai.size; _id_AC0E594AC96AA3A8++ )
    {
        if ( !isdefined( ai[_id_AC0E594AC96AA3A8].node ) )
            continue;

        array[ai[_id_AC0E594AC96AA3A8].node.origin + ""] = 1;
    }

    return array;
}

find_connected_turrets( _id_AE413E3D7D38E5C6 )
{
    _id_FDC11BA76911059E = level.shared_portable_turrets;
    _id_C62CF039AB4009CF = [];
    _id_223A6F5757803299 = getarraykeys( _id_FDC11BA76911059E );
    _id_B64A2C06FA3074BE = gettakennodes();
    _id_B64A2C06FA3074BE[self.node.origin + ""] = undefined;

    for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < _id_223A6F5757803299.size; _id_AC0E594AC96AA3A8++ )
    {
        export = _id_223A6F5757803299[_id_AC0E594AC96AA3A8];

        if ( _id_FDC11BA76911059E[export] == self.turret )
            continue;

        keys = getarraykeys( self.turret.shared_turrets[_id_AE413E3D7D38E5C6] );

        for ( _id_AC0E424AC96A7113 = 0; _id_AC0E424AC96A7113 < keys.size; _id_AC0E424AC96A7113++ )
        {
            if ( _id_FDC11BA76911059E[export].export + "" != keys[_id_AC0E424AC96A7113] )
                continue;

            if ( isdefined( _id_FDC11BA76911059E[export].reserved ) )
                continue;

            if ( isdefined( _id_B64A2C06FA3074BE[_id_FDC11BA76911059E[export].node.origin + ""] ) )
                continue;

            if ( distance( self.goalpos, _id_FDC11BA76911059E[export].origin ) > self.goalradius )
                continue;

            _id_C62CF039AB4009CF[_id_C62CF039AB4009CF.size] = _id_FDC11BA76911059E[export];
        }
    }

    array = [];
    array["type"] = _id_AE413E3D7D38E5C6;
    array["spots"] = _id_C62CF039AB4009CF;
    return array;
}

find_good_ambush_spot( ent )
{
    return find_connected_turrets( "ambush" );
}

find_different_way_to_attack_last_seen_position( ent )
{
    array = find_connected_turrets( "connected" );
    _id_C62CF039AB4009CF = array["spots"];

    if ( !_id_C62CF039AB4009CF.size )
        return;

    _id_65E20ED241369A89 = [];

    for ( _id_AC0E594AC96AA3A8 = 0; _id_AC0E594AC96AA3A8 < _id_C62CF039AB4009CF.size; _id_AC0E594AC96AA3A8++ )
    {
        if ( !scripts\engine\utility::within_fov( _id_C62CF039AB4009CF[_id_AC0E594AC96AA3A8].origin, _id_C62CF039AB4009CF[_id_AC0E594AC96AA3A8].angles, ent.origin, 0.75 ) )
            continue;

        if ( !sighttracepassed( ent.origin, _id_C62CF039AB4009CF[_id_AC0E594AC96AA3A8].origin + ( 0, 0, 16 ), 0, undefined ) )
            continue;

        _id_65E20ED241369A89[_id_65E20ED241369A89.size] = _id_C62CF039AB4009CF[_id_AC0E594AC96AA3A8];
    }

    array["spots"] = _id_65E20ED241369A89;
    return array;
}

portable_mg_spot()
{
    save_turret_sharing_info();
    _id_D43AEF2C94B7D080 = 1;
    self.issetup = 1;
    self.reserved = undefined;

    if ( isdefined( self.isvehicleattached ) )
        return;

    if ( self.spawnflags & _id_D43AEF2C94B7D080 )
        return;

    hide_turret();
}

hide_turret()
{
    self notify( "stop_checking_for_flanking" );
    self.issetup = 0;
    self hide();
    self.solid = 0;
    self makeunusable();
    self setdefaultdroppitch( 0 );
    thread restoredefaultpitch();
}

show_turret()
{
    self show();
    self.solid = 1;
    self makeusable();
    self.issetup = 1;
    thread stop_mg_behavior_if_flanked();
}

stop_mg_behavior_if_flanked()
{
    self endon( "stop_checking_for_flanking" );
    self waittill( "turret_deactivate" );

    if ( isalive( self.owner ) )
        self.owner notify( "end_mg_behavior" );
}

turret_is_mine( turret )
{
    owner = turret getturretowner();

    if ( !isdefined( owner ) )
        return 0;

    return owner == self;
}

end_turret_reservation( turret )
{
    waittill_turret_is_released( turret );
    turret.reserved = undefined;
}

waittill_turret_is_released( turret )
{
    turret endon( "turret_deactivate" );
    self endon( "death" );
    self waittill( "end_mg_behavior" );
}

reserve_turret( turret )
{
    turret.reserved = self;
    thread end_turret_reservation( turret );
}

zuluinit()
{
    thread turret_watchplayeruse( turret_getplayerusefuncs() );
    thread turret_impactquakes();
}

turret_impactquakes()
{
    self endon( "death" );

    for (;;)
    {
        self waittill( "missile_fire", missile );
        missile thread missile_explode_quakes();
    }
}

missile_explode_quakes()
{
    self waittill( "explode", position );
    earthquake( 0.18, 0.75, position, 500 );
    playrumbleonposition( "artillery_rumble_light", position );
}

turret_getplayerusefuncs()
{
    _id_34EDB5BEEA39A217 = spawnstruct();
    _id_34EDB5BEEA39A217.startfuncs = [ ::turretplayerstartfunc ];
    _id_34EDB5BEEA39A217.stopfuncs = [ ::turretplayerstopfunc ];
    return _id_34EDB5BEEA39A217;
}

turret_watchplayeruse( _id_34EDB5BEEA39A217 )
{
    self endon( "death" );

    for (;;)
    {
        self waittill( "turretownerchange" );
        _id_C424C88C44314576 = self getturretowner();

        if ( isdefined( _id_C424C88C44314576 ) && isplayer( _id_C424C88C44314576 ) )
        {
            foreach ( startfunc in _id_34EDB5BEEA39A217.startfuncs )
                self thread [[ startfunc ]]();

            _id_C424C88C44314576 notify( "turret_mount" );
            self waittill( "turretownerchange" );

            foreach ( _id_EEBE32B9ACFE66AB in _id_34EDB5BEEA39A217.stopfuncs )
                self thread [[ _id_EEBE32B9ACFE66AB ]]();

            _id_C424C88C44314576 notify( "turret_dismount" );
        }
    }
}

turretplayerstartfunc()
{
    self.ogplayerweapon = level.player getcurrentweapon();
    level.player giveweapon( self.weaponinfo );
    level.player switchtoweaponimmediate( self.weaponinfo );
    level.player _meth_ F61FB1CE72ED501();
}

turretplayerstopfunc()
{
    level.player takeweapon( self.weaponinfo );

    if ( isdefined( self.ogplayerweapon ) )
        level.player switchtoweaponimmediate( self.ogplayerweapon );

    level.player _meth_5773CD2DCAA3AEEE();
}
