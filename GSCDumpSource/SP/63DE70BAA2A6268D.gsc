// IW9 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

get_closed_door_closest_to_nav_modifier( pos )
{
    doors = scripts\sp\door::get_all_doors_ai_should_open();

    if ( doors.size > 0 )
    {
        doors = sortbydistance( doors, pos );
        distsqrd = distancesquared( pos, doors[0].origin );

        if ( distsqrd < 5041 )
            return doors[0];
    }
}

door_manage_openers()
{
    self endon( "entitydeleted" );
    self notify( "new_door_opener" );
    self endon( "new_door_opener" );
    _id_41189BD90DE937BA = scripts\sp\door_internal::get_door_center();
    _id_96C01E635124A007 = ( randomfloat( 1 ), randomfloat( 1 ), randomfloat( 1 ) );
    _id_8994092A0CEDF84A = 72;

    for (;;)
    {
        if ( scripts\sp\door_internal::door_is_at_max_yaw( 1 ) || !self.active )
            return;

        self.openers = scripts\engine\utility::array_removedead_or_dying( self.openers );

        if ( !self.openers.size )
            return;

        self.openers = sortbydistance( self.openers, self.origin );
        opener = self.openers[0];
        _id_42CA41C7DADAE0C0 = distance2d( _id_41189BD90DE937BA, opener.origin );
        _id_C540C5719CF990D5 = 110;

        if ( opener aigettargetspeed() > 90 )
            _id_C540C5719CF990D5 = 230;

        if ( _id_42CA41C7DADAE0C0 <= _id_C540C5719CF990D5 && abs( _id_41189BD90DE937BA[2] - opener.origin[2] ) < _id_8994092A0CEDF84A && !self.breached && length2dsquared( opener.velocity ) > 0 )
        {
            if ( !isdefined( self.tryingopener ) || self.opener == opener && !isdefined( opener._blackboard.doortoopen ) )
            {
                if ( isdefined( opener getmodifierlocationonpath( "door", _id_C540C5719CF990D5 + 50 ) ) )
                    thread door_manager_try_ai_opener( opener );
            }
        }

        foreach ( guy in self.openers )
        {
            if ( guy == opener && !self.breached )
            {
                if ( isdefined( guy.waitingfordoor ) )
                    guy stop_waiting_for_door();

                continue;
            }
        }

        waitframe();
    }
}

door_manager_try_ai_opener( opener )
{
    if ( istrue( self.lockedforai ) )
        return;

    self.tryingopener = 1;
    result = opener ai_open_try_animated( self );

    if ( !istrue( result ) )
    {
        scripts\engine\sp\utility::array_notify( self.openers, "reset_door_check" );
        self.tryingopener = undefined;
        return;
    }
}

ai_open_try_animated( door )
{
    self endon( "death" );
    door endon( "entitydeleted" );
    door notify( "unusable" );

    if ( isdefined( self.waitingfordoor ) )
        stop_waiting_for_door();

    door.opener = self;
    self._blackboard.doortoopen = door;
    result = scripts\engine\utility::waittill_notify_or_timeout_return( "opening_door", 6 );
    _id_8E4A6A3FE2D3E51C = result != "timeout";

    if ( _id_8E4A6A3FE2D3E51C )
    {
        door thread scripts\sp\door::remove_open_ability();
        scripts\engine\utility::waittill_notify_or_timeout( "opening_door_done", 4 );
    }

    if ( isdefined( self._blackboard.doortoopen ) && self._blackboard.doortoopen == door )
    {
        self._blackboard.doortoopen = undefined;
        self.isopeningdoor = 0;
    }

    return _id_8E4A6A3FE2D3E51C;
}

door_add_opener( door )
{
    if ( isdefined( self.currentdoor ) && self.currentdoor != door )
        self.currentdoor.openers = scripts\engine\utility::array_remove( self.currentdoor.openers, self );

    self.currentdoor = door;
    door.openers[door.openers.size] = self;
    thread door_speed_modifier_monitor();
}

remove_as_opener()
{
    if ( isdefined( self.currentdoor ) )
    {
        self.currentdoor.openers = scripts\engine\utility::array_remove( self.currentdoor.openers, self );
        self.currentdoor = undefined;
        self notify( "add_door_speed_monitor" );
        remove_door_speed_modifiers();
    }
}

add_door_speed_modifiers()
{
    _id_2F10825BA72AADD1 = self aigetdesiredspeed();
    self.saveddoorspeed = _id_2F10825BA72AADD1;
    _id_F0B748AE159F6B83 = 0.15;
    _id_05DA114C79116631 = max( 0.5, 1 - _id_F0B748AE159F6B83 * self.currentdoor.openers.size );
    _id_EFC4E0686536F8E8 = _id_2F10825BA72AADD1 * _id_05DA114C79116631;
    self aisetdesiredspeed( _id_EFC4E0686536F8E8 );
    self.old_doavoidanceblocking = self.doavoidanceblocking;
    self.doavoidanceblocking = 0;
}

door_speed_modifier_monitor()
{
    self endon( "death" );
    self notify( "add_door_speed_monitor" );
    self endon( "add_door_speed_monitor" );
    mindistance = 160000;
    _id_DC7BF1E196B97912 = self.currentdoor.origin;
    _id_807CD8789B963DF2 = anglestoforward( self.currentdoor.angles );
    remove_door_speed_modifiers();

    for (;;)
    {
        if ( lengthsquared( self.origin - _id_DC7BF1E196B97912 ) < mindistance )
            break;

        waitframe();
    }

    if ( !isdefined( self.currentdoor ) )
        return;

    if ( self.currentdoor.openers.size > 1 )
        add_door_speed_modifiers();

    timeout = gettime() + 5000;
    _id_AA1F3E198643DE9A = vectornormalize( _id_DC7BF1E196B97912 - self.origin );
    _id_3A7BDFD10383C0A2 = vectordot( _id_807CD8789B963DF2, _id_AA1F3E198643DE9A ) > 0;

    for (;;)
    {
        _id_07F79491DA859D2D = vectornormalize( _id_DC7BF1E196B97912 - self.origin );
        _id_7B16E4BB387DB7FD = vectordot( _id_807CD8789B963DF2, _id_07F79491DA859D2D ) > 0;

        if ( _id_7B16E4BB387DB7FD != _id_3A7BDFD10383C0A2 )
            break;

        if ( gettime() > timeout )
            break;

        wait 0.1;
    }

    remove_door_speed_modifiers();
}

remove_door_speed_modifiers()
{
    if ( isdefined( self.saveddoorspeed ) )
    {
        self aisetdesiredspeed( self.saveddoorspeed );
        self.saveddoorspeed = undefined;
    }

    if ( isdefined( self.old_doavoidanceblocking ) )
    {
        self.doavoidanceblocking = self.old_doavoidanceblocking;
        self.old_doavoidanceblocking = undefined;
    }
}

stop_waiting_for_door()
{
    self.waitingfordoor = undefined;
}

draw_node_line( node, time, color )
{
    self endon( "death" );
    timer = gettime() + time * 1000;

    while ( gettime() < timer )
        wait 0.05;
}
