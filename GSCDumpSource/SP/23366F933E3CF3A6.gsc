// IW9 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

loopanimfortime( asmname, statename, params )
{
    self endon( statename + "_finished" );
    self endon( "terminate_ai_threads" );
    _id_6DE89AC92D7FA442 = "loop_end";
    t = 2;

    if ( isarray( params ) )
    {
        if ( params.size > 0 )
            t = params[0];

        if ( params.size > 1 )
            _id_6DE89AC92D7FA442 = params[1];
    }
    else
        t = params;

    thread scripts\asm\asm::_id_FB56C9527636713F( asmname, statename, 1 );
    wait( t );
    scripts\asm\asm::asm_fireevent( asmname, _id_6DE89AC92D7FA442 );
}

_id_148EE35E7BB45D3A( asmname, statename, params )
{
    self endon( statename + "_finished" );
    _id_6DE89AC92D7FA442 = "loop_end";
    t = 2;

    if ( isarray( params ) )
    {
        if ( params.size > 0 )
            t = params[0];

        if ( params.size > 1 )
            _id_6DE89AC92D7FA442 = params[1];
    }
    else
        t = params;

    _id_0C8AAF5BC74C22BB = scripts\asm\asm::asm_lookupanimfromalias( statename, "blank" );
    self aisetanim( statename, _id_0C8AAF5BC74C22BB );
    thread _id_EC21AA2F5413BF19( asmname, statename );
    wait( t );
    scripts\asm\asm::asm_fireevent( asmname, _id_6DE89AC92D7FA442 );
}

_id_EC21AA2F5413BF19( asmname, statename )
{
    self endon( statename + "_finished" );

    for (;;)
        scripts\asm\asm::asm_donotetracks( asmname, statename );
}

_id_AD537378D1E07015( asmname, statename, params )
{
    _id_2C8936D08F85C5C1 = scripts\asm\asm::asm_getanim( asmname, statename, params );
    xanim = scripts\asm\asm::asm_getxanim( statename, _id_2C8936D08F85C5C1 );
    self _meth_50CE1815D713CDC6( statename, xanim, 1, 0.2, 1 );
    thread _id_EC21AA2F5413BF19( asmname, statename );
}

_id_6DDF61E941FD9B74( asmname, statename, params )
{
    self endon( statename + "_finished" );
    _id_6DE89AC92D7FA442 = "loop_end";
    t = 2;

    if ( isarray( params ) )
    {
        if ( params.size > 0 )
            t = params[0];

        if ( params.size > 1 )
            _id_6DE89AC92D7FA442 = params[1];
    }
    else
        t = params;

    _id_2C8936D08F85C5C1 = scripts\asm\asm::asm_getanim( asmname, statename );
    xanim = scripts\asm\asm::asm_getxanim( statename, _id_2C8936D08F85C5C1 );
    self setanimknob( xanim, 1, 0.2, 1 );
    thread _id_EC21AA2F5413BF19( asmname, statename );
    wait( t );
    scripts\asm\asm::asm_fireevent( asmname, _id_6DE89AC92D7FA442 );
}

handlenotetrack( _id_A234A65C378F3289, flagname )
{
    switch ( _id_A234A65C378F3289 )
    {
        case "start_aim":
            scripts\asm\asm::asm_setupaim( undefined, flagname, 0.3 );
            break;
    }
}

asm_powerdown()
{
    self.bpowerdown = 1;
}

asm_powerup()
{
    self.bpowerdown = undefined;
}

wantstocrouch()
{
    return self.currentpose == "crouch";
}

arrivalhack_emptywait()
{
    self waittill( self.a.arrivalasmstatename + "_finished" );
}

delayslowmotion( delay, start, end, time )
{
    level.player endon( "meleegrab_interupt" );
    level.player endon( "crawlmeleegrab_interrupt" );
    wait( delay );
    setslowmotion( start, end, time );
}

delaymodifybasefov( delay, fov, time )
{
    level.player endon( "meleegrab_interupt" );
    level.player endon( "crawlmeleegrab_interrupt" );
    wait( delay );
    level.player _meth_1D98630AA343510D( fov, time );
}

delayenabledof( delay, _id_E0AF59BA48C8CB09, _id_FF6B46DA0D04E078, nearblur, _id_2FE3DC2F1289D072, _id_7A6976D1E774FE57, farblur, time )
{
    level.player endon( "meleegrab_interupt" );
    level.player endon( "crawlmeleegrab_interrupt" );
    wait( delay );
    scripts\sp\art::dof_enable_script( _id_E0AF59BA48C8CB09, _id_FF6B46DA0D04E078, nearblur, _id_2FE3DC2F1289D072, _id_7A6976D1E774FE57, farblur, time );
}

delaydisabledof( delay )
{
    level.player endon( "meleegrab_interupt" );
    level.player endon( "crawlmeleegrab_interrupt" );
    wait( delay );
    scripts\sp\art::dof_disable_script( 0.5 );
}

#using_animtree("player");

spawnplayerrig()
{
    player_rig = spawn( "script_model", level.player.origin );
    player_rig.root = %root;
    player_rig setmodel( "viewmodel_base_viewhands_iw7" );
    player_rig useanimtree( #animtree );
    player_rig hide();
    return player_rig;
}

playergrabbed( type )
{
    level.player _id_3B64EB40368C1450::set( "PlayerGrabbed", "action_slot_weapon", 0 );

    if ( !isdefined( type ) )
    {
        level.player disableweapons();
        level.player disableusability();
        level.player allowstand( 1 );
        level.player allowcrouch( 0 );
        level.player allowprone( 0 );
    }
    else if ( type == "seeker" )
    {
        level.player disableweapons();
        level.player allowstand( 1 );
        level.player allowcrouch( 0 );
        level.player allowprone( 0 );
    }
    else if ( type == "crawlmelee" )
    {
        level.player disableusability();
        level.player allowstand( 0 );
        level.player allowcrouch( 1 );
        level.player allowprone( 0 );
    }

    level.player allowoffhandshieldweapons( 0 );
    level.player _meth_9163E162C36DBE68( 0.2, 0.5 );
}

playerletgo()
{
    level.player allowstand( 1 );
    level.player allowcrouch( 1 );
    level.player allowprone( 1 );
    level.player enableweapons();
    level.player allowoffhandshieldweapons( 1 );
    level.player _meth_62E24429AE4BE81B();
    level.player enableusability();
    level.player _id_3B64EB40368C1450::_id_C9D0B43701BDBA00( "PlayerGrabbed" );
}

playerhealth()
{
    self endon( "death" );
    wait 0.2;
    time = 3;
    timer = gettime() + time * 1000;
    self.health_overlay.alpha = self.health_overlay.alpha + ( 1 - level.player.health_overlay.alpha ) * 0.8;
    self.health_overlay fadeovertime( 3 );
    self.health_overlay.alpha = 0;

    while ( gettime() < timer )
    {
        if ( self.health <= 0 )
            return;

        if ( isdefined( self.disable_breathing_sound ) && self.disable_breathing_sound )
            continue;

        if ( isdefined( level.gameskill_breath_func ) )
            [[ level.gameskill_breath_func ]]( "breathing_hurt" );
        else
            self playlocalsound( "breathing_hurt" );

        _id_399177F7EEB779B7 = 0.1;
        wait( _id_399177F7EEB779B7 + randomfloat( 0.8 ) );
    }
}

meleegrab_common()
{
    self.hackable = 0;
    self._id_8DA037CBE81E4F8F = 1;

    if ( isdefined( anim ) )
    {
        if ( isplayer( self._id_9BFC452192B23C7A ) )
            anim.meleechargeplayertimers[self.unittype] = gettime() + anim.meleechargeplayerintervals[self.unittype];
        else
            anim.meleechargetimers[self.unittype] = gettime() + anim.meleechargeintervals[self.unittype];
    }
}

meleegrab_counterinput( _id_EB5B1F36E255152D )
{
    level.player endon( "meleegrab_interupt" );
    level.player endon( "bt_stop_meleegrab" );
    _id_A7C377795BD0850E = 0.5;
    time = gettime();
    start_delay = _id_EB5B1F36E255152D - _id_A7C377795BD0850E;
    start_time = time + start_delay * 1000;
    _id_E8807713F4B2054A = _id_EB5B1F36E255152D;
    end_time = time + _id_E8807713F4B2054A * 1000;
    thread meleegrab_slowmo( start_delay, _id_E8807713F4B2054A );
    thread meleegrab_counterhint( start_delay, _id_A7C377795BD0850E );

    while ( playercounterpress() )
        wait 0.05;

    for (;;)
    {
        time = gettime();

        if ( time >= end_time )
            break;

        if ( playercounterpress() )
        {
            if ( time > start_time && time < end_time )
            {
                if ( isdefined( self.melee.meleecounterhint ) )
                    level.player thread counterhintdestroy( 0.1 );

                self.melee.countersuccess = 1;
                level.player notify( "bt_meleegrab_slowmo" );
                return;
            }
        }

        wait 0.05;
    }

    level.player notify( "bt_meleegrab_slowmo" );
}

meleegrab_slowmo( start_delay, _id_E8807713F4B2054A )
{
    level.player endon( "meleegrab_interupt" );
    wait( start_delay );
    setslowmotion( 1, 0.3, 0.1 );

    if ( !isdefined( self.melee.countersuccess ) )
        level.player waittill( "bt_meleegrab_slowmo" );
    else
        wait 0.05;

    setslowmotion( 0.2, 1, 0.05 );
}

playercounterpress()
{
    return isalive( level.player ) && level.player meleebuttonpressed();
}

meleegrab_counterhint( delay, _id_0E5486D00EBBA6E9 )
{
    level.player endon( "meleegrab_interupt" );
    _id_B54C12788DC982C7 = 0.2;
    _id_A4972F5C6A743696 = 0.3;
    wait( delay - _id_B54C12788DC982C7 - 0.05 );

    if ( isdefined( self.melee.meleecounterhint ) )
        self.melee.meleecounterhint destroy();

    self.melee.meleecounterhint = newclienthudelem( level.player );
    self.melee.meleecounterhint.color = ( 1, 1, 1 );
    self.melee.meleecounterhint settext( &"SCRIPT_PLATFORM/HINT_MELEE_COUNTER" );
    self.melee.meleecounterhint.x = 0;
    self.melee.meleecounterhint.y = 20;
    self.melee.meleecounterhint.alignx = "center";
    self.melee.meleecounterhint.aligny = "middle";
    self.melee.meleecounterhint.horzalign = "center";
    self.melee.meleecounterhint.vertalign = "middle";
    self.melee.meleecounterhint.foreground = 1;
    self.melee.meleecounterhint.alpha = 0;
    self.melee.meleecounterhint.fontscale = 0.5;
    self.melee.meleecounterhint.hidewhendead = 1;
    self.melee.meleecounterhint.sort = -1;
    self.melee.meleecounterhint endon( "death" );
    self.melee.meleecounterhint fadeovertime( _id_B54C12788DC982C7 );
    self.melee.meleecounterhint changefontscaleovertime( _id_B54C12788DC982C7 );
    self.melee.meleecounterhint.fontscale = 1.3;
    self.melee.meleecounterhint.alpha = 1;
    wait( _id_B54C12788DC982C7 );

    if ( !isdefined( self.melee.meleecounterhint ) )
        return;

    self.melee.meleecounterhint fadeovertime( _id_A4972F5C6A743696 );
    self.melee.meleecounterhint changefontscaleovertime( _id_A4972F5C6A743696 );
    self.melee.meleecounterhint.fontscale = 1.2;
}

meleeset( asmname, statename, params )
{
    return isdefined( level.player.melee.countersuccess );
}

meleecountered( asmname, statename, params )
{
    return isdefined( level.player.melee.countersuccess ) && level.player.melee.countersuccess;
}

meleecounteredfailed( asmname, statename, params )
{
    return isdefined( level.player.melee.countersuccess ) && !level.player.melee.countersuccess;
}

counterhintdestroy( fade )
{
    if ( isdefined( fade ) )
    {
        level.player.melee.meleecounterhint fadeovertime( fade );
        level.player.melee.meleecounterhint changefontscaleovertime( fade );
        level.player.melee.meleecounterhint.fontscale = 2;
        level.player.melee.meleecounterhint.alpha = 0;
        wait( fade );
    }

    if ( level.player._id_A97AC004F00C5DF9 && isdefined( level.player.melee.meleecounterhint ) )
        level.player.melee.meleecounterhint destroy();
}
